<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chainguys.github.io</id>
    <title>Chainguys&apos;Blog</title>
    <updated>2022-11-22T04:44:45.606Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chainguys.github.io"/>
    <link rel="self" href="https://chainguys.github.io/atom.xml"/>
    <subtitle>A blockchain guy who likes making memes and translating tech articles &lt;/br&gt;All Information NOT Financial Adivice&lt;/br&gt; 一个区块链的老韭菜 &lt;/br&gt;兴趣是做meme和翻译技术文章 &lt;/br&gt;一切均非投资建议</subtitle>
    <logo>https://chainguys.github.io/images/avatar.png</logo>
    <icon>https://chainguys.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Chainguys&apos;Blog</rights>
    <entry>
        <title type="html"><![CDATA[zkEVM]]></title>
        <id>https://chainguys.github.io/post/zkevm/</id>
        <link href="https://chainguys.github.io/post/zkevm/">
        </link>
        <updated>2022-11-22T04:38:06.000Z</updated>
        <content type="html"><![CDATA[<p><em>We thank Vitalik Buterin, Barry Whitehat, Chih-Cheng Liang, Kobi Gurkan and Georgios Konstantopoulos for their reviews and insightful comments.</em></p>
<p><em>我们感谢 Vitalik Buterin、Barry Whitehat、Chih-Cheng Liang、Kobi Gurkan 和 Georgios Konstantopoulos 的评价和有见地的评论。</em></p>
<h2 id="省流助手-tldr">省流助手 (TL;DR)</h2>
<p>We believe zk-Rollup to be the holy grail — a best-in-class Layer 2 scaling solution that is very cheap and secure. However, existing zk-Rollups are application-specific, which makes it hard to build general composable DApps inside a zk-Rollup and migrate existing applications. We introduce zkEVM, which can generate zk proofs for general EVM verification. This allows us to build a fully EVM-compatible zk-Rollup, which any existing Ethereum application can easily migrate to.</p>
<p>我们相信 zk-Rollup 是圣杯——一种非常便宜，安全，顶流的第 2 层扩容解决方案。然而，现有的 zk-Rollups 是应用特定的，这使得在 zk-Rollup 中构建通用的可组合 DApps 和迁移现有应用变得困难。我们引入了 zkEVM，它可以为一般的 EVM 验证生成 zk 证明。这使我们能够构建一个完全兼容 EVM 的 zk-Rollup，任何现有的以太坊应用都可以轻松迁移其上。</p>
<p>In this article, we identify the design challenges of zkEVM and why it’s possible now. We also give a more specific intuition and describe the high-level ideas of how to build it from scratch.</p>
<p>在本文中，我们确定了 zkEVM 的设计挑战以及为什么现在成为可能。我们还给出了更具体的直觉，并描述了如何从头开始构建它的宏观想法。</p>
<h2 id="背景-background">背景 (Background)</h2>
<p><a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/">zk-Rollup</a> is recognized as the best scaling solution for Ethereum. It is as secure as Ethereum Layer 1 and has the shortest finalizing time comparing to all other Layer 2 solutions (Detailed comparisons <a href="https://vitalik.ca/general/2021/01/05/rollup.html">here</a>).</p>
<p><a href="https://docs.ethhub.io/ethereum-roadmap/layer-2-scaling/zk-rollups/">zk-Rollup</a> 被公认为以太坊的最佳扩展解决方案。它与以太坊第 1 层一样安全，并且与所有其他第 2 层解决方案相比，具有最短的完成时间(详细比较请查看<a href="https://vitalik.ca/general/2021/01/05/rollup.html">此处</a>)。</p>
<blockquote>
<p>In the medium to long term, ZK rollups will win out in all use cases as ZK-SNARK technology improves. — Vitalik Buterin</p>
<p>从中长期来看，随着 ZK-SNARK 技术的改进，ZK rollups 将在所有用例中胜出。 — Vitalik Buterin</p>
</blockquote>
<p>The basic idea of zk-Rollup is to aggregate a huge number of transactions into one Rollup block and generate a succinct proof for the block off-chain. Then the smart contract on Layer 1 only needs to verify the proof and apply the updated state directly without re-executing those transactions. This can help save gas fee for an order of magnitude since proof verification is much cheaper than re-executing computations. Another saving comes from data compression (i.e., only keep minimum on-chain data for verification)</p>
<p>zk-Rollup 的基本思想是将海量的交易聚合到一个 Rollup 区块中，并为该区块下生成一个简洁的证明。然后第 1 层的智能合约只需要验证证明并直接应用更新状态，而无需重新执行这些交易。如此就可以帮助节省一个数量级的 gas 费用，因为证明验证比重新执行计算便宜得多。另一个节省来自数据压缩(即只保留最少的链上数据用于验证)</p>
<p>Although zk-Rollup is secure and efficient, its applications are still limited to payments and swaps. It’s hard to build general-purpose DApps due to the following two reasons.</p>
<p>尽管 zk-Rollup 安全高效，但其应用仍然仅限于支付和互换。由于以下两个原因，很难构建通用的 DApp。</p>
<ul>
<li>
<p>First, if you want to develop DApps in a zk-Rollup, you need to write all your smart contract logic using a special language (i.e. <a href="https://tlu.tarilabs.com/cryptography/r1cs-bulletproofs/mainreport.html#rank-1-constraint-systems">R1CS</a>). Not only is the syntax of required language complicated, but doing so also demands extremely strong expertise in zero-knowledge proof.<br>
首先，如果你想在 zk-Rollup 中开发 DApps，你需要使用一种特殊的语言(即 <a href="https://tlu.tarilabs.com/cryptography/r1cs-bulletproofs/mainreport.html#rank-1-constraint-systems">R1CS</a>)。不仅语法复杂，而且还需要极强的零知识证明专业知识。</p>
</li>
<li>
<p>Second, current zk-Rollup doesn’t support composability[1]. It means different zk-Rollup applications can’t interact with each other within Layer 2. Such quality significantly undermines the composability of DeFi applications.<br>
其次，当前的 zk-Rollup 不支持可组合性[1]。这意味着不同的 zk-Rollup 应用无法在第 2 层内相互交互。这种质量严重破坏了 DeFi 应用的可组合性。</p>
</li>
</ul>
<p>In a nutshell, zk-Rollup is developer-unfriendly and has limited functionality for now.<br>
That’s the biggest problem we want to tackle. We want to provide the best developer experience and support composability within Layer 2 by supporting native EVM verification directly, so that existing Ethereum applications can simply migrate over onto the zk-Rollup as is.</p>
<p>简而言之，zk-Rollup 对开发者不友好，且目前功能有限。这是我们想要解决的最大问题。我们希望通过直接支持原生 EVM 验证，来提供最佳的开发者体验并支持第 2 层内的可组合性，以便现有的以太坊应用可以简单地按原样迁移到 zk-Rollup。</p>
<h2 id="在-zk-rollup-中构建通用-dapp-build-general-dapps-in-zk-rollup">在 zk-Rollup 中构建通用 DApp (Build general DApps in zk-Rollup)</h2>
<p>There are two ways to build general DApps in zk-Rollup.</p>
<p>有两种方法在 zk-Rollup 中构建通用 DApp 。</p>
<ul>
<li>
<p>One is building application-specific circuit (“ASIC”) for different DApps.<br>
一种是为不同的 DApp 构建专用回路(“ASIC”)。</p>
</li>
<li>
<p>The other is building a universal “EVM” circuit for smart contract execution.<br>
另一个是为智能合约执行构建一个通用的“EVM”回路。</p>
</li>
</ul>
<blockquote>
<p><a href="https://tlu.tarilabs.com/cryptography/r1cs-bulletproofs/mainreport.html#arithmetic-circuits">“circuit”</a> refer to the program representation used in zero-knowledge proof. For example, if you want to prove hash(x) = y, you need to re-write the hash function using the circuit form. The circuit form only supports very limited expressions (i.e., R1CS only support addition and multiplication). So, it’s very hard to write program using the circuit language — you have to build all your program logic (including if else, loop and so on) using add and mul.</p>
<p><a href="https://tlu.tarilabs.com/cryptography/r1cs-bulletproofs/mainreport.html#arithmetic-circuits">“回路”</a> 即零知识证明中使用的程序表示。例如，如果要证明hash(x) = y，就需要用回路形式重写hash函数。回路形式仅支持非常有限的表达式(即 R1CS 仅支持加法和乘法)。因此，使用回路语言编写程序非常困难——您必须使用 add 和 mul 构建所有程序逻辑(包括 if else、循环等)。</p>
</blockquote>
<p>The first approach requires developer to design specialized “ASIC” circuits for different DApps. It is the most traditional way to use zero-knowledge proof. Each DApp will have a smaller overhead through customized circuit design. However, it brings the problem of composability since the circuit is “static” and terrible developer experience since it needs strong expertise in circuit design[2].</p>
<p>第一种方法需要开发人员为不同的 DApp 设计专门的“ASIC”回路。这是使用零知识证明的最传统方式。通过定制化的回路设计，每个DApp都会有更小的开销。然而，它带来了可组合性问题，因为回路是“静态的”，而且开发者体验很糟糕，因为它需要强大的回路设计专业知识[2]。</p>
<p>The second approach doesn’t require any special design or expertise for developer. The high-level idea of such machine-based proof is that any program will eventually run on CPU, so we only need to build a universal CPU circuit to verify the low-level CPU step. Then we can use this CPU circuit to verify any program execution. In our scenario, program is smart contract and CPU is EVM. However, this approach is not commonly adopted in the past years due to its large overhead. For example, even if you only want to prove the result of <code>add</code> is correct in one step, you still need to afford the overhead of an entire EVM circuit. If you have thousands of steps in your execution trace, it will be 1000x EVM circuit overhead on the prover side.[3]</p>
<p>第二种方法不需要开发人员的任何特殊设计或专业知识。这种基于机器的证明的宏观思想是任何程序最终都会在 CPU 上运行，所以我们只需要构建一个通用的 CPU 回路来验证低层 CPU 这一步。然后我们可以使用这个 CPU 回路来验证任何程序的执行。在我们的场景中，程序是智能合约，CPU 是 EVM。然而，由于开销极大，这种方法在过去几年中并不普遍采用。例如，即使您只想一步证明 <code>add</code> 的结果正确，您仍然需要承担整个 EVM 回路的开销。如果您的执行跟踪中有数千个步骤，那么证明方的 EVM 回路开销将增加 1000 倍。 [3]</p>
<p>Recently, there has been a lot of research going on to optimize zk proofs following those two approaches, including (i) proposing new zk-friendly primitives i.e. <a href="https://www.poseidon-hash.info/">Poseidon hash</a> can achieve 100x efficiency than SHA256 in circuit, (ii) ongoing work on improving efficiency of general-purpose verifiable VMs, as in <a href="https://eprint.iacr.org/2013/507">TinyRAM</a>, and (iii) a growing number of general-purpose optimization tricks like Plookup, and even more generally faster cryptographic libraries.</p>
<p>最近，根据这两种方法，进行了大量研究来优化 zk 证明，包括 (i) 提出新的 zk 友好原语，比如 <a href="https://www.poseidon-hash.info/">Poseidon hash</a> 可以在回路中实现比 SHA256 高 100 倍的效率，(ii) 正在进行的提高通用可验证 VM 效率的工作，如 <a href="https://eprint.iacr.org/2013/507">TinyRAM</a>，以及 (iii) 不断增长的一些通用优化技巧，如 Plookup，甚至更快的加密库。</p>
<p>In our <a href="https://scroll-official.medium.com/scroll-a-layer-2-ecosystem-based-on-zk-rollup-186ff0d764c">previous article</a>, We propose to design “ASIC” circuit for each DApp and let them communicate through cryptographic commitments. However, based on the feedback from the community, we changed our priority and will focus on building a general EVM circuit (so called “zkEVM”) first following the second approach. zkEVM will allow exactly the same developer experience as developing on Layer 1. Instead of leaving design complexity to the developer, we will take over it and solve the efficiency problem through customized EVM circuit design.</p>
<p>在我们的<a href="https://scroll-official.medium.com/scroll-a-layer-2-ecosystem-based-on-zk-rollup-186ff0d764c">上一篇文章</a>中，我们建议为每个DApp设计“ASIC”回路，并让它们通过加密承诺进行通信。但是，根据社区的反馈，我们改变了优先顺序，将按照第二种方法首先专注于构建通用 EVM 回路(所谓的“zkEVM”)。 zkEVM将使得开发者获得在 Layer 1 上开发完全相同的体验。我们不会将设计复杂性留给开发人员，而是接管并通过定制的 EVM 回路设计来解决效率问题。</p>
<h2 id="zkevm-的设计挑战-design-challenges-of-zkevm">zkEVM 的设计挑战 (Design challenges of zkEVM)</h2>
<p>zkEVM is hard to build. Even though the intuition is clear for years, no one has built a native EVM circuit successfully. Different from TinyRAM, it’s even more challenging to design and implement zkEVM due to the following reasons:</p>
<p>zkEVM 很难构建。尽管直觉多年来一直很清晰，但没有人成功构建原生 EVM 回路。与 TinyRAM 不同，由于以下原因，设计和实现 zkEVM 更具挑战性：</p>
<ul>
<li>
<p><strong>First, EVM has limited support of elliptic curves.</strong> For now, EVM only supports BN254 pairing. It’s hard to do proof recursion since <a href="https://github.com/daira/halographs/blob/master/halographs.pdf">cyclic elliptic curve</a> is not directly supported. It’s also hard to use other specialized protocols under this setting. The verification algorithm has to be EVM friendly.<br>
<strong>首先，EVM 对椭圆曲线的支持有限。</strong> 目前，EVM 仅支持 BN254 配对。由于不直接支持 <a href="https://github.com/daira/halographs/blob/master/halographs.pdf">循环椭圆曲线</a>，因此很难进行递归证明。在此设置下也很难使用其它专用协议。验证算法必须对 EVM 友好。</p>
</li>
<li>
<p><strong>Second, EVM word size is 256bit.</strong> EVM operates over 256-bit integers (much like most regular VMs operate over 32-64 bit integers), whereas zk proofs most “naturally” work over prime fields. Doing “mismatched field arithmetic” inside a circuit requires range proofs, which will add ~100 constraints per EVM step. This will blow up EVM circuit size by two orders of magnitudes.<br>
<strong>其次，EVM的字大小为256位。</strong> EVM在256位整数上操作(就像大多数常规VM在32-64位整数上操作一样)，而zk证明最 &quot;自然 &quot;地在素数域上工作。在回路中进行 &quot;不匹配字段算术 &quot;需要范围证明，这将在每个EVM步骤中增加约100个约束。这将使EVM回路的大小增加两个数量级。</p>
</li>
<li>
<p><strong>Third, EVM has many special opcodes.</strong> EVM is different from traditional VM, it has many special <a href="https://www.ethervm.io/">opcodes</a> like <code>CALL</code> and it also has error types related to the execution context and gas. This will bring new challenges to circuit design.<br>
<strong>第三，EVM有许多特殊的操作码。</strong> EVM与传统的VM不同，它有许多特殊的<a href="https://www.ethervm.io/">操作码</a>，如<code>CALL</code>，它也有与执行环境和gas有关的错误类型。这将给回路设计带来新的挑战。</p>
</li>
<li>
<p><strong>Fourth, EVM is a stack-based virtual machine.</strong> The <a href="https://zksync.io/dev/contracts/#sync-vm">SyncVM</a> (zksync) and <a href="https://eprint.iacr.org/2021/1063">Cario</a> (starkware) architecture defines its own IR/AIR in the register-based model. They built a specialized compiler to compile smart contract code into a new zk-friendly IR. Their approach is language compatible instead of native EVM-compatible. It’s harder to prove for stack-based model and support native tool chain directly.<br>
<strong>第四，EVM是一个基于(技术)堆栈的虚拟机。</strong><a href="https://zksync.io/dev/contracts/#sync-vm">SyncVM</a> (zksync)和<a href="https://eprint.iacr.org/2021/1063">Cario</a> (starkware)架构在基于注册表的模型中定义了自己的IR/AIR。他们建立了一个专门的编译器，将智能合约代码编译成一个新的zk友好的IR。他们的方法是语言兼容的，而不是本地EVM兼容的。对于基于(技术)堆栈的模型，它更难证明及直接支持原生工具链。</p>
</li>
<li>
<p><strong>Fifth, Ethereum storage layout carries a huge overhead.</strong> The Ethereum storage layout highly relies on <a href="https://keccak.team/files/Keccak-reference-3.0.pdf">Keccak</a> and a huge <a href="https://eth.wiki/en/fundamentals/patricia-tree">MPT</a>[4], both of them are not zk-friendly and have a huge proving overhead. For example, Keccak hash is 1000x larger than Poseidon hash in circuit. However, if you replace Keccak with another hash, it will cause some compatibility problems for the existing Ethereum infrastructure.<br>
<strong>第五，以太坊的存储布局带有巨大的开销。</strong> 以太坊的存储布局高度依赖<a href="https://keccak.team/files/Keccak-reference-3.0.pdf">Keccak</a>和巨大的<a href="https://eth.wiki/en/fundamentals/patricia-tree">MPT</a>[4]，它们都对zk不友好，并且有巨大的证明开销。例如，Keccak hash在回路上比Poseidon hash大1000倍。然而，如果你用另一个哈希值取代Keccak，会对现有的以太坊基础设施造成一些兼容性问题。</p>
</li>
<li>
<p><strong>Sixth, machine-based proof has a gigantic overhead.</strong> Even if you can handle all the aforementioned problems properly, you still need to find an efficient way to compose them together to get a complete EVM circuit. As I mentioned in previous section, even simple opcodes like <code>add</code> might result in the overhead of the entire EVM circuit.<br>
<strong>第六，基于机器的证明有巨大的开销。</strong> 即使你能妥善处理上述所有问题，你仍然需要找到一种有效的方法来将它们组合在一起，以获得一个完整的EVM回路。正如我在上一节提到的，即使是像 &quot;add &quot;这样简单的操作码也可能引发整个EVM回路的开销。</p>
</li>
</ul>
<h2 id="为什么现在反而可能-why-possible-now">为什么现在(反而)可能？- Why possible now?</h2>
<p>Thanks for the great progress made by researchers in this area, more and more efficiency problems are solved in the last two years, the proving cost for zkEVM is eventually feasible! The biggest technology improvement comes from the following aspects:</p>
<p>由于研究人员在这一领域取得了巨大的进步，在过去两年中，越来越多的效率问题得到了解决，zkEVM的证明成本最终可行! 最大的技术改进来自于以下几个方面。</p>
<ul>
<li>
<p><strong>The usage of polynomial commitment.</strong> In the past few years, most succinct zero-knowledge proof protocols stick to R1CS with PCP query encoded in an application-specific trusted setup. The circuit size usually blows up and you can’t do many customized optimizations since the degree of each constraint needs to be 2 (<a href="https://vitalik.ca/general/2017/01/14/exploring_ecp.html">bilinear pairing</a> only allows one multiplication in the exponent). With <a href="https://www.youtube.com/watch?v=BfV7HBHXfC0">polynomial commitment schemes</a>, you can lift your constraints to any degree with a universal setup or even transparent setup. This allows great flexibility in the choice of backend.<br>
<strong>多项式承诺的使用。</strong> 在过去的几年中，大多数简洁的零知识证明协议坚持使用R1CS与PCP查询编码在一个应用特定的信任设置中。回路大小通常会爆炸，而且你不能做很多定制的优化，因为每个约束的程度需要2个(<a href="https://vitalik.ca/general/2017/01/14/exploring_ecp.html">双线性配对</a>只允许在指数中进行一次乘法)。通过<a href="https://www.youtube.com/watch?v=BfV7HBHXfC0">多项式承诺方案</a>，你可以通过通用设置，甚至是透明设置，将你的约束提升到任何程度。这使得在选择后端时有很大的灵活性。</p>
</li>
<li>
<p><strong>The appearance of lookup table arguments and customized gadgets.</strong> Another strong optimization comes from the usage of lookup tables. The optimization is firstly proposed in <a href="https://eprint.iacr.org/2018/380">Arya</a> and then gets optimized in <a href="https://eprint.iacr.org/2020/315">Plookup</a>. This can save A LOT for zk-unfriendly primitives (i.e., bitwise operations like AND, XOR, etc.) . <a href="https://kobi.one/2021/05/20/plonk-custom-gates.html">Customized gadgets</a> allow you to do high degree constraints with efficiency. <a href="https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf">TurboPlonk</a> and <a href="https://zcash.github.io/halo2/concepts/arithmetization.html">UltraPlonk</a> defines elegant program syntax to make it easier to use lookup tables and define customized gadgets. This can be extremely helpful for reducing the overhead of EVM circuit.</p>
</li>
</ul>
<p><strong>查找表参数的出现和定制的小工具。</strong> 另一个强大的优化来自查找表的使用。这个优化首先是在<a href="https://eprint.iacr.org/2018/380">Arya</a>中提出的，然后在<a href="https://eprint.iacr.org/2020/315">Plookup</a>中得到优化。这可以节省很多对zk不友好的基元(即像AND、XOR等位操作)。 <a href="https://kobi.one/2021/05/20/plonk-custom-gates.html">定制化小工具</a>可以让你高效地进行高度约束。 <a href="https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf">TurboPlonk</a>和<a href="https://zcash.github.io/halo2/concepts/arithmetization.html">UltraPlonk</a>定义了优雅的程序语法，使其更容易使用查找表和自定义小工具。这对减少EVM回路的开销有很大帮助。</p>
<ul>
<li>
<p><strong>Recursive proof is more and more feasible.</strong> Recursive proof has a huge overhead in the past since it relies on special pairing-friendly cyclic elliptic curves (i.e. <a href="https://eprint.iacr.org/2014/595">MNT curve-based construction</a>). This introduces a large computation overhead. However, more techniques are making this possible without sacrificing the efficiency. For example, <a href="https://eprint.iacr.org/2019/1021">Halo</a> can avoid the need of pairing-friendly curve and amortize the cost of recursion using special inner product argument. Aztec shows that you can do proof aggregation for existing protocols directly (lookup tables can reduce the overhead of <a href="https://hackmd.io/@arielg/B13JoihA8">non-native field operation</a> thus can make the verification circuit smaller). It can highly improve the scalability of supported circuit size.<br>
<strong>递归证明越来越可行。</strong> 递归证明在过去有巨大的开销，因为它依赖于特殊的配对友好循环椭圆曲线(即<a href="https://eprint.iacr.org/2014/595">基于MNT曲线的构建</a>)。这引入了大量的计算开销。然而，更多的技术在不牺牲效率的情况下使之成为可能。例如，<a href="https://eprint.iacr.org/2019/1021">Halo</a>可以避免对友好曲线的需要，并使用特殊的内积参数来摊销递归的成本。Aztec表明，你可以直接对现有协议进行证明聚合(查找表可以减少<a href="https://hackmd.io/@arielg/B13JoihA8">非原生字段操作</a>的开销，从而可以使验证回路更小)。它可以高度提高支持回路大小的可扩展性。</p>
</li>
<li>
<p><strong>Hardware acceleration is making proving more efficient.</strong> To the best of our knowledge, we have made the fastest GPU and ASIC/FPGA accelerator for the prover. <a href="https://people.iiis.tsinghua.edu.cn/~gaomy/pubs/pipezk.isca21.pdf">Our paper</a> describing ASIC prover has already been accepted by the largest computer conference (ISCA) this year. The GPU prover is around 5x-10x faster than <a href="https://github.com/filecoin-project/bellperson">Filecoin’s implementation</a>. This can greatly improve the prover’s computation efficiency.<br>
<strong>硬件加速使证明更有效。</strong> 据我们所知，我们已经为证明者制作了最快的GPU和ASIC/FPGA加速器。 <a href="https://people.iiis.tsinghua.edu.cn/~gaomy/pubs/pipezk.isca21.pdf">我们的论文</a>描述的ASIC验证器已经被今年最大的计算机会议(ISCA)接受。GPU验证器比<a href="https://github.com/filecoin-project/bellperson">Filecoin的实现</a>快5倍-10倍左右。这可以极大地提高验证器的计算效率。</p>
</li>
</ul>
<h2 id="好它如何工作如何构建ok-so-how-does-it-work-and-how-to-build-it">好，它如何工作，如何构建？(Ok, so how does it work and how to build it?)</h2>
<p>Besides the strong intuition and technology improvement, we still need to have a more clear idea of what we need to prove and figure out a more specific architecture. We will introduce more technical details and comparisons in the follow up articles. Here, we describe the overall workflow and some key ideas.</p>
<p>除了强烈的直觉和技术改进，我们仍然得对需要证明的东西有一个更清晰的概念，并找出一个更具体的架构。我们将在后续的文章中介绍更多的技术细节和比较。在这里，我们描述一下整体的工作流程和一些关键的想法。</p>
<h3 id="开发者和用户的工作流程-workflow-for-developers-and-users">开发者和用户的工作流程 (Workflow for Developers and Users)</h3>
<p>For developers, they can implement smart contracts using any EVM-compatible language and deploy the compiled bytecode on Scroll. Then, users can send transactions to interact with those deployed smart contracts. The experience for both users and developers will be the exactly the same as Layer 1. However, the gas fee is significantly reduced and transactions are pre-confirmed instantly on Scroll (withdraw only takes a few minutes to finalize).</p>
<p>对于开发者来说，他们可以使用任何与EVM兼容的语言实现智能合约，并将编译好的字节码部署在Scroll上。然后，用户可以发送交易，与这些部署的智能合约进行互动。用户和开发者的体验将与第1层完全相同。然而，gas费大大降低，交易在Scroll上即时得到预先确认(提款只需要几分钟就能最终达成)。</p>
<h3 id="zkevm的工作流程-workflow-for-zkevm">ZkEVM的工作流程 (Workflow for zkEVM)</h3>
<p>Even if the workflow outside remains the same, the underlying processing procedure for Layer 1 and Layer 2 are entirely different:</p>
<p>即使外面的工作流程保持不变，第1层和第2层的基本处理程序也完全不同。</p>
<ul>
<li>
<p>Layer 1 relies on the re-execution of smart contracts.<br>
第1层依靠的是智能合约的重新执行</p>
</li>
<li>
<p>Layer 2 relies on the validity proof of zkEVM circuit.<br>
第2层依赖于zkEVM回路的有效性证明。</p>
</li>
</ul>
<p>Let’s give a more detailed explanation of how things are going differently for transactions on Layer 1 and Layer 2.</p>
<p>让我们更详细地解释一下第1层和第2层的交易的情况到底如何不同。</p>
<p>In Layer 1, the bytecodes of the deployed smart contracts are stored in the Ethereum storage. Transactions will be broadcasted in a P2P network. For each transaction, each full node needs to load the corresponding bytecode and execute it on EVM to reach the same state (transaction will be used as input data).</p>
<p>在第1层，已部署的智能合约的字节码被存储在以太坊的存储器中。交易将在一个P2P网络中广播。对于每个交易，每个完整的节点需要加载相应的字节码并在EVM上执行，以达到相同的状态(交易将被用作输入数据)。</p>
<p>In Layer 2, the bytecode is also stored in the storage and users will behave in the same way. Transactions will be sent off-chain to a centralized zkEVM node. Then, instead of just executing the bytecode, zkEVM will generate a succinct proof to prove the states are updated correctly after applying the transactions. Finally, Layer 1 contract will verify the proof and update the states without re-executing the transactions.</p>
<p>在第2层，字节码也被存储在存储器中，用户将以同样的方式进行操作。交易将被发送至链外的中心化zkEVM节点。然后，zkEVM将生成一个简洁的证明，来证明在应用交易后状态被正确更新，而不是仅仅执行字节码。最后，第1层合约将验证该证明并更新状态，而不重新执行交易。</p>
<p>Let’s take a deeper look at the execution process and see what zkEVM needs to prove at the end of the day. In native execution, EVM will load the bytecode and execute the opcodes in the bytecode one by one from beginning. Each opcode can be thought as doing the following three sub-steps : (i) Read elements from stack, memory or storage (ii) Perform some computation on those elements (iii) Write back results to stack, memory or storage.[5] For example, <code>add</code> opcode needs to read two elements from stack, add them up and write the result back to stack.</p>
<p>让我们深入了解一下执行过程，看看zkEVM在最后需要证明什么。在本地执行中，EVM将加载字节码并从头开始逐一执行字节码中的操作码。每个操作码可以被认为是在做以下三个子步骤：(i)从堆栈、内存或存储中读取元素(ii)对这些元素进行一些计算(iii)将结果写回堆栈、内存或存储。</p>
<p>So, it’s clear that the proof of zkEVM needs to contain the following aspects corresponding to the execution process</p>
<p>所以，很明显，zkEVM的证明需要包含与执行过程相对应的以下方面</p>
<ul>
<li>
<p>The bytecode is correctly loaded from persistent storage<br>
(You are running the correct opcode loaded from a given address)<br>
字节码被正确地从持久性存储中加载<br>
(你正在运行从给定地址加载的正确的操作码)</p>
</li>
<li>
<p>The opcodes in the bytecode are executed one by one consistently<br>
(They bytecode is executed in order without missing or skipping any opcode)<br>
字节码中的操作码被一个一个地执行。<br>
(字节码是按顺序执行的，没有遗漏或跳过任何操作码)</p>
</li>
<li>
<p>Each opcode is executed correctly<br>
(Three sub-steps in each opcode are carried out correctly, R/W + computation)<br>
每个操作码都被正确执行<br>
(每个操作码中的三个子步骤是正确执行的，R/W+计算)</p>
</li>
</ul>
<h3 id="zkevm设计亮点-zkevm-design-highlight">zkEVM设计亮点 (zkEVM Design highlight)</h3>
<p>When designing the architecture for zkEVM, we need to handle/address the aforementioned three aspects one by one.</p>
<p>在设计zkEVM的架构时，我们需要逐一处理/解决上述的三个方面。</p>
<ol>
<li>
<p>We need to design a circuit for some cryptographic accumulator.<br>
我们需要为一些加密累积器设计一个回路。</p>
<p>This part acts like a “verifiable storage”, we need some technique to prove we are reading correctly. A cryptographic accumulator can be used to achieve this efficiently.[6]<br>
Let’s take Merkle Tree as an example. The deployed bytecode will be stored as a leaf in the Merkle Tree. Then, verifier can verify the bytecode is loaded correctly from a given address using a succinct proof (i.e., verify Merkle Path in circuit). For Ethereum storage, we need the circuit to be compatible with Merkle Patricia Trie and Keccak hash function.</p>
<p>这一部分就像一个 &quot;可验证的存储&quot;，我们需要一些技术来证明我们的读取是正确的。加密累加器可以有效地实现这一点[6] 。<br>
让我们以Merkle Tree为例。部署的字节码将作为叶子存储在Merkle树上。然后，验证者可以使用简洁证明(即在回路中验证Merkle Path)来验证字节码是否从给定的地址正确加载。对于Ethereum存储，我们需要回路与Merkle Patricia Trie和Keccak哈希函数兼容。</p>
</li>
<li>
<p>We need to design a circuit to link the bytecode with the real execution trace.<br>
我们需要设计一个回路，将字节码与实际执行轨迹联系起来。</p>
<p>One problem to move bytecode into a static circuit is conditional opcodes like <code>jump</code> (corresponding to loop, if else statement in smart contracts). It can jump anywhere. The destination is not determined before one has run the bytecode with specific input. That’s the reason why we need to verify the real execution trace. The execution trace can be thought as “unrolled bytecode”, it will include the sequence of opcodes in the real execution order (i.e., if you jump to another position, the trace will contain the destined opcode and position).</p>
<p>将字节码移入静态回路的一个问题是条件操作码，如<code>jump</code>(对应于智能合约中的循环、if else语句)。它可以跳到任何地方。在人们用特定的输入运行字节码之前，目的地是不确定的。这就是为什么我们需要验证真正执行跟踪的原因。执行跟踪可以被认为是 &quot;未滚动的字节码&quot;，它将包括真实执行顺序的操作码序列(即，如果你跳到另一个位置，跟踪将包含预定的操作码和位置)。</p>
<p>Prover will provide the execution trace directly as witness to the circuit. We need to prove that the provided execution trace is indeed the one “unrolled” from the bytecode with specific input. The idea is forcing the value of program counter to be consistent. To deal with the undetermined destination, the <a href="https://hackmd.io/5vKFGDcITKuNPHSRT8H9jA">idea</a> is letting prover provide everything. Then you can check the consistency efficiently using a lookup argument (i.e., prove the opcodes with proper global counter is included in the “bus”).</p>
<p>验证器将直接提供执行轨迹作为回路的见证。我们需要证明所提供的执行轨迹确实是由特定输入字节码 &quot;解卷 &quot;出来的。我们的想法是，迫使程序计数器的值保持一致。为了处理不确定的目的地，<a href="https://hackmd.io/5vKFGDcITKuNPHSRT8H9jA">思路</a>是让验证者提供一切。然后，你可以使用查找参数有效地检查一致性(即证明具有适当的全局计数器的操作码被包含在 &quot;总线 &quot;中)。</p>
</li>
<li>
<p>We need to design circuits for each opcode (Prove read, write and computations in each opcode are correct).<br>
我们需要为每个操作码设计回路(证明每个操作码的读、写和计算是正确的)。</p>
<p>This is the most important part — Prove each opcode in the execution trace is correct and consistent. It will bring a huge overhead if you put all the things together directly. The important optimization idea here is that</p>
<p>这是最重要的部分--证明执行跟踪中的每个操作码都是正确和一致的。如果你直接把所有的东西放在一起，会带来巨大的开销。这里的重要优化思想是：</p>
<ul>
<li>
<p>We can separate R/W and computation into two proofs. One will fetch the elements needed for all the opcodes into a “bus”. The other will prove the computation performed on the elements from the “bus” is carried out correctly. This can greatly reduce the overhead of each part (i.e., you don’t need to consider the entire EVM storage in the computation proof). In a <a href="https://github.com/appliedzkp/zkevm-specs">more detailed specification</a>, the first one is called “state proof” and the second one is called “EVM proof”. Another observation is that “bus mapping” can be efficiently handled by the lookup argument.</p>
<p>我们可以把R/W和计算分成两个证明。一个将获取所有操作码所需的元素汇总到一个 &quot;总线 &quot;中。另一个将证明对 &quot;总线 &quot;中的元素进行的计算是正确的。这可以大大减少每个部分的开销(也就是说，你不需要在计算证明中考虑整个EVM的存储)。在一个<a href="https://github.com/appliedzkp/zkevm-specs">更详细的规范</a>中，第一个被称为 &quot;状态证明&quot;，第二个被称为 &quot;EVM证明&quot;。另一个观察是，&quot;总线映射 &quot;可以通过查找参数有效地处理。</p>
</li>
<li>
<p>We can design higher degree customized constraint for each opcode (i.e., EVM word can be solved efficiently by chopping off it into several chunks). We can choose whether to “open” a constraint through a selector polynomial according to our need. This can avoid the overhead of the entire EVM circuit in each step.</p>
<p>我们可以为每个操作码设计更高程度的定制约束(即，EVM字可以通过将其分割成几块来有效解决)。我们可以根据自己的需要选择是否通过选择器多项式 &quot;打开 &quot;一个约束。这可以避免每一步中整个EVM回路的开销。</p>
</li>
</ul>
</li>
</ol>
<p>This architecture is firstly specified by Ethereum Foundation. It’s still at an early stage and under active development. We are collaborating with them closely on this to find the best way to implement the EVM circuit. So far, the most important traits are defined and some opcodes have already been implemented <a href="https://github.com/appliedzkp/zkevm-circuits">here</a> (using UltraPlonk syntax in the Halo2 repo). More details will be introduced in the follow up articles. We refer interested readers to read this <a href="https://hackmd.io/Hy_nqH4yTOmjjS9nbOArgw?view">document</a>. The development process will be transparent. This will be a community-effort and fully open-sourced design. Hope more people can join and contribute to this.</p>
<p>这个架构首先由Ethereum基金会指定的。它仍然处于早期阶段，正在积极开发中。我们正在与他们密切协作，来找到实现EVM回路的最佳方式。到目前为止，最重要的特征已经被定义，一些操作码已经被实现<a href="https://github.com/appliedzkp/zkevm-circuits">可以在这里查看</a>(使用Halo2 repo中的UltraPlonk语法)。更多的细节将在后续的文章中介绍。我们推荐感兴趣的读者阅读这个<a href="https://hackmd.io/Hy_nqH4yTOmjjS9nbOArgw?view">文件</a>。开发过程将是透明的。这将是一个社区的努力和完全开源的设计。希望更多的人能够加入并为此做出贡献。</p>
<h3 id="它还能带来什么what-else-it-can-bring">它还能带来什么？(What else it can bring?)</h3>
<p>zkEVM is much more than just Layer 2 scaling. It can be thought as a direct way to scale Ethereum Layer 1 via Layer-1 validity proof. That means you can scale existing Layer 1 without any special Layer 2.</p>
<p>zkEVM远不止是第2层的扩展。它可以被认为是通过第1层有效性证明来扩展以太坊第1层的一种直接方式。这意味着你可以扩展现有的第1层而不需要任何特殊的第2层。</p>
<p>For example, you can use zkEVM as a full node. The proof can be used for proving transitions between existing states directly — No need to port anything to Layer 2, you can prove for all Layer 1 transactions directly! More broadly, you can use zkEVM to generate a succinct proof for the whole Ethereum like Mina. The only thing you need to add is proof recursion (i.e. embed the verification circuit of a block to the zkEVM)[7].</p>
<p>例如，你可以使用zkEVM作为一个完整的节点。该证明可以直接用于证明现有状态之间的转换--不需要移植任何东西到第2层，你可以直接为所有第1层的交易进行证明! 更广泛地说，你可以使用zkEVM为整个以太坊生成一个简洁的证明，就像Mina一样。你唯一需要添加的是证明递归(即把一个区块的验证回路嵌入到zkEVM中)[7]。</p>
<h2 id="结论-conclusion">结论 (Conclusion)</h2>
<p>zkEVM can provide the same experience for developers and users. It’s order of magnitudes cheaper without sacrificing security. There has been proposed architecture to build it in a modular way. It leverages recent breakthrough in zero-knowledge proof to reduce the overhead (including customized constraint, lookup argument, proof recursion and hardware acceleration). We look forward to seeing more people joining the zkEVM community effort and brainstorming with us!</p>
<p>zkEVM可以为开发者和用户提供同样的体验。在不牺牲安全性的情况下，它的成本要低好几个数量级。目前已经提出了以模块化方式构建的架构。它利用最近在零知识证明方面的突破来减少开销(包括自定义约束、查找参数、证明递归和硬件加速)。我们期待看到更多的人加入zkEVM社区的努力，并与我们一起进行头脑风暴!</p>
<h2 id="关于我们-a-little-about-us">关于我们 (A little about us)</h2>
<p><em>Scroll Tech is a newly built tech-driven company. We aim to build an EVM-compatible zk-Rollup with a strong proving network (<a href="https://scroll.io/blog/Scroll-Overview">See an overview here</a>). The whole team is now focusing on the development. We are actively hiring more passionate developers, reach out to us at <a href="mailto:hire@scroll.io">hire@scroll.io</a>. If you have any question about the technical content, reach out to me at <a href="mailto:ye@scroll.io">ye@scroll.io</a>. <a href="https://twitter.com/yezhang1998">DM</a> is also open.</em></p>
<p><em>Scroll Tech是一家新建立的技术驱动型公司。我们的目标是建立一个与EVM兼容的zk-Rollup，拥有强大的证明网络(<a href="https://scroll.io/blog/Scroll-Overview">概述在此</a>)。整个团队现在正专注于开发。我们正在积极招聘更多有激情的开发人员，请通过<a href="mailto:hire@scroll.io">hire@scroll.io</a>与我们联系。如果你有任何关于技术内容的问题，请联系我：<a href="mailto:ye@scroll.io">ye@scroll.io</a>。 <a href="https://twitter.com/yezhang1998">私信 DM</a>也是开放的。</em></p>
<h2 id="脚注-footnotes">脚注 (Footnotes)</h2>
<p>[1]: Starkware claims to achieve composability a few days ago (<a href="https://medium.com/starkware/starknet-alpha-2-4aa116f0ecfc">reference here</a>)</p>
<p>[2]: Circuit is fixed and static. For example, you can’t use variable upper bound loop when implementing a program as a circuit. The upper bound has to be fixed to its maximum value. It can’t deal with dynamic logic.</p>
<p>[3]: To make it more clear, We elaborate about the cost of EVM circuit here. As we described earlier, circuit is fixed and static. So, EVM circuit needs to contain all possible logic (10000x larger than pure <code>add</code>). That means even if you only want to prove for <code>add</code>, you still need to afford the overhead of all possible logics in the EVM circuit. It will 10000x amplify the cost. In the execution trace, you have a sequence of opcodes to prove and each opcode will have such a large overhead.</p>
<p>[4]: EVM itself is not tightly bound to the Merkle Patricia tree. MPT is just how Ethereum states are stored for now. A different one can easily be plugged in (i.e., the current proposal to replace MPT with <a href="https://vitalik.ca/general/2021/06/18/verkle.html">Verkle trees</a>).</p>
<p>[5]: This is a highly simplified abstraction. Technically, the list of “EVM state” is longer including PC, gas remaining, call stack (all of the above plus address and staticness per call in the stack), a set of logs, and transaction-scoped variables (warm storage slots, refunds, self-destructs). Composability can be supported directly with additional identifier for different call context.</p>
<p>[6]: We use accumulator for storage since the storage is huge. For memory and stack, one can use editable Plookup (“RAM” can be implemented efficiently in this way).</p>
<p>[7]: It’s non-trivial to add a complete recursive proof to the zkEVM circuit. The best way to do recursion is still using cyclic elliptic curves (i.e., Pasta curve). Need some <a href="https://hackmd.io/u_2Ygx8XS5Ss1aObgOFjkA">“wrapping”</a> process to make it verifiable on Ethereum Layer 1.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fuel内幕-2022年10月 (Inside Fuel-October 2022)]]></title>
        <id>https://chainguys.github.io/post/fuel-nei-mu-2022-nian-10-yue-inside-fuel-october-2022/</id>
        <link href="https://chainguys.github.io/post/fuel-nei-mu-2022-nian-10-yue-inside-fuel-october-2022/">
        </link>
        <updated>2022-11-17T02:48:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/10/blog-banner-2.png" alt="Inside Fuel — October 2022" loading="lazy"></figure>
<hr>
<p>Welcome to <strong>Inside Fuel</strong>, our review of technical developments and everything happening on the Fuel Network. Take a moment to catch up on all the latest news.</p>
<p>欢迎来到<strong>Fuel内幕</strong>，我们对技术发展和Fuel网络上发生的一切进行回顾。请拨冗了解所有最新消息。</p>
<h2 id="最新入职-newest-additions-to-fuel">最新入职 (Newest Additions To Fuel)</h2>
<p>Building the fastest modular execution layer would not be possible without an incredible contributor team.  Here are the newest additions to the team this month:</p>
<p>没有一个令人难以置信的贡献者团队，不可能建立最快的模块化执行层。  以下是这个月最新入职的同事：</p>
<figure data-type="image" tabindex="2"><img src="https://fuel-labs.ghost.io/content/images/2022/11/October-2.png" alt="" loading="lazy"></figure>
<h2 id="新闻报道-in-the-news">新闻报道 (In The News)</h2>
<figure data-type="image" tabindex="3"><img src="https://fuel-labs.ghost.io/content/images/2022/06/image.png" alt="" loading="lazy"></figure>
<p>According to the <strong>Rust In Blockchain</strong> <a href="https://rustinblockchain.org/newsletters/rib-newsletter-41/">monthly review</a>, Fuel is one of the most active Rust-based projects this October with 316 merged PRs, 236 closed issues, and 143 open issues.  We are ranked fifth right behind Aptos, Parity, Solana, and Sui.</p>
<p>根据<strong>Rust In Blockchain</strong><a href="https://rustinblockchain.org/newsletters/rib-newsletter-41/">月度回顾</a>，Fuel是今年10月最活跃的基于Rust的项目之一，有316个合并的PR，236个关闭的问题，以及143个开放的问题。  我们排名第五，紧随Aptos、Parity、Solana和Sui之后。</p>
<h2 id="️-播客和amas-podcasts-amas">🎙️ 播客和AMAs (Podcasts &amp; AMAs)</h2>
<p><strong>John Adler</strong> gave an <strong>AMA</strong> with <strong>vVv Fund</strong><br>
<strong>John Adler</strong>与<strong>vVv Fund</strong>进行了一次<strong>AMA</strong>。</p>
<p><strong>Camila Ramos</strong> on <strong>Devs Do Something</strong>'s <strong>Podcast</strong><br>
<strong>Camila Ramos</strong>在<strong>Devs Do Something</strong>的播客上发言。</p>
<h2 id="️-工作坊-workshops">⚙️ 工作坊 (Workshops)</h2>
<p><a href="https://youtube.com/watch?v=19tQwOrybzc&amp;t=2442s"><strong>Fullstack Fuel</strong></a>: <em>Writing Smart Contracts in Rust with Sway</em><br>
<a href="https://youtube.com/watch?v=19tQwOrybzc&amp;t=2442s"><strong>Fullstack Fuel</strong></a>: 在Rust中用Sway编写智能合约。</p>
<p><strong><a href="https://youtu.be/_vZaezteYz8">Minority Programmers</a></strong>: <em>Building Smart Contracts on Fuel with Sway</em><br>
<strong><a href="https://youtu.be/_vZaezteYz8">少数派程序员</a></strong>: <em>用Sway在Fuel上构建智能合约</em></p>
<h2 id="sway日-sway-day">🌴 Sway日 (Sway Day)</h2>
<p>We hosted the first edition of <strong>Sway Day</strong>, a monthly discussion about all-things Sway, where we had the chance to have the founders of <a href="https://elix.finance/">Elix Finance</a>, one of the first granted projects on Fuel.</p>
<p>我们举办了第一期<strong>Sway Day</strong>，这是一个关于Sway所有事情的月度讨论，我们有机会请到了<a href="https://elix.finance/">Elix Finance</a>的创始人，这是Fuel上首批授予的项目之一。</p>
<blockquote>
<p>The first episode of Sway Day was a BIG hit 🌴<br>
Special thanks to our guests <a href="https://twitter.com/MauriceWbr?ref_src=twsrc%5Etfw">@MauriceWbr</a> and <a href="https://twitter.com/namakxyz?ref_src=twsrc%5Etfw">@namakxyz</a> from <a href="https://twitter.com/elixfinance?ref_src=twsrc%5Etfw">@elixfinance</a><br>
Some highlights in case you missed it 👇🧵 <a href="https://t.co/ffFZlaJY9Z">https://t.co/ffFZlaJY9Z</a><br>
— Sway (@SwayLang) <a href="https://twitter.com/SwayLang/status/1583478571548278784?ref_src=twsrc%5Etfw">October 21, 2022</a></p>
</blockquote>
<blockquote>
<p>第一期 &quot;Sway Day &quot;是一个巨大的冲击🌴<br>
特别感谢我们的嘉宾<a href="https://twitter.com/MauriceWbr?ref_src=twsrc%5Etfw">@MauriceWbr</a>和 来自<a href="https://twitter.com/elixfinance?ref_src=twsrc%5Etfw">@elixfinance</a>  的<a href="https://twitter.com/namakxyz?ref_src=twsrc%5Etfw">@namakxyz</a></p>
<p>一些亮点，别错过👇🧵 <a href="https://t.co/ffFZlaJY9Z">https://t.co/ffFZlaJY9Z</a></p>
<ul>
<li>Sway (@SwayLang) <a href="https://twitter.com/SwayLang/status/1583478571548278784?ref_src=twsrc%5Etfw">October 21, 2022</a></li>
</ul>
</blockquote>
<h2 id="公开露面-public-appearances">公开露面 (Public Appearances)</h2>
<h3 id="-devcon-波哥大-devcon-bogota">🇨🇴 - Devcon, 波哥大 (Devcon, Bogota)</h3>
<p>We flew to Colombia to attend one of the most significant events of the year, where we participated in various talks:</p>
<p>我们飞往哥伦比亚，参加今年最重要的活动之一，在那里我们参加了各种讲座。</p>
<figure data-type="image" tabindex="4"><img src="https://fuel-labs.ghost.io/content/images/2022/11/image-11.png" alt="" loading="lazy"></figure>
<p>Nick Dodson on a panel about Non-EVM Compatible L2s</p>
<p>Nick Dodson在一个关于非EVM兼容的L2的小组中发言</p>
<ul>
<li>
<p><a href="https://youtu.be/HTFvGjNfBeU">New Paradigms by Non-EVM Compatible L2s ft. Nick Dodson</a></p>
</li>
<li>
<p>Scaling Ethereum with the Fastest Modular Execution Layer, by John Adler</p>
</li>
<li>
<p><a href="https://youtu.be/2HP9MEUa1GQ">Machismo, Remittance, &amp; Inflation: Scaling Ethereum for Widespread Adoption in LATAM, by Camila Ramos</a></p>
</li>
<li>
<p><a href="https://youtu.be/HTFvGjNfBeU">非EVM兼容L2的新范例 作者：Nick Dodson </a></p>
</li>
<li>
<p>用最快的模块化执行层扩展以太坊，作者：John Adler</p>
</li>
<li>
<p><a href="https://youtu.be/2HP9MEUa1GQ">谈到以太坊，我想说的是：&quot;以太坊是一个很好的平台，它能让我们的生活变得更美好。以太坊在拉美地区的广泛采用，作者：Camila Ramos</a></p>
</li>
</ul>
<h2 id="-里斯本-lisbon">🇵🇹 - 里斯本 (Lisbon)</h2>
<p>We participated in various events in Lisbon this month, here is an overview of a few of them:</p>
<p>我们本月在里斯本参加了各种活动，以下是其中一些活动的概述：</p>
<h3 id="trgc圆桌谈话-trgc-panel">TRGC圆桌谈话 (TRGC Panel)</h3>
<p><a href="https://twitter.com/IAmNickDodson">Nick Dodson</a> was on stage during the panel organized by <a href="https://twitter.com/trgcapi"><strong>TRGC</strong></a> intituled: <em>Post Tornado Cash: Can Web3 Ever Be Truly Decentralized?</em> Watch the replay <a href="https://twitter.com/i/broadcasts/1mnxeRDMbbZKX">here</a>.</p>
<p><a href="https://twitter.com/IAmNickDodson">Nick Dodson</a> 在由 <a href="https://twitter.com/trgcapi"><strong>TRGC</strong></a> 组织的小组讨论会上登台演讲：<em>Post Tornado Cash：Web3 能否永远真正去中心化？</em> 观看重播<a href="https://twitter.com/i/broadcasts/1mnxeRDMbbZKX">此处</a>。</p>
<h3 id="eth-里斯本黑客马拉松-eth-lisbon-hackathon">ETH 里斯本黑客马拉松 (ETH Lisbon Hackathon)</h3>
<p>We sponsored ETH Lisbon, a 3 day-long hackathon during which hackers teamed up to build DApps. Read more about the winners <a href="https://fuel-labs.ghost.io/ethlisbon22-recap/"><strong>here</strong></a>.</p>
<p>我们赞助了 ETH Lisbon，这是一个为期 3 天的黑客马拉松，在此期间黑客们组队构建 DApp。在 <a href="https://fuel-labs.ghost.io/ethlisbon22-recap/"><strong>此处</strong></a> 阅读有关获奖者的更多信息。</p>
<figure data-type="image" tabindex="5"><img src="https://fuel-labs.ghost.io/content/images/2022/11/image-7.png" alt="" loading="lazy"></figure>
<h3 id="starknetcc圆桌谈话-starknetcc-panel">StarknetCC圆桌谈话 (StarknetCC panel)</h3>
<p>Nick Dodson participated in a panel during StarknetCC around <em>high-level-languages implementation on top of Rollups</em>, where he explained the reasons and needs for Sway. Read the <a href="https://twitter.com/fuellabs_/status/1587482177645658113?s=20&amp;t=ZRIKD0_geZIYmcw-G6KD_w">TL;DR</a> or watch the full panel replay <a href="https://youtu.be/3UnRIOmkrs8">here</a>.</p>
<p>Nick Dodson 参加了 StarknetCC 期间，围绕 Rollups 之上的高级语言实施的小组讨论，他在会上解释了 Sway 的原因和需求。阅读 <a href="https://twitter.com/fuellabs_/status/1587482177645658113?s=20&amp;t=ZRIKD0_geZIYmcw-G6KD_w">TL;DR</a> 或在<a href="https://youtu.be/3UnRIOmkrs8">此处</a>观看完整的圆桌谈话回放 .</p>
<figure data-type="image" tabindex="6"><img src="https://fuel-labs.ghost.io/content/images/2022/11/image-14.png" alt="" loading="lazy"></figure>
<hr>
<h2 id="技术更新-technical-updates">技术更新 (Technical Updates)</h2>
<h3 id="fuelup">Fuelup</h3>
<h4 id="fuelup是什么-what-is-fuelup">Fuelup是什么 (What is Fuelup?)</h4>
<blockquote>
<p><a href="https://github.com/FuelLabs/fuelup#installation">Fuelup</a> is the official package manager and multiplexer for <a href="https://fuel.network/">Fuel</a> that installs <strong>The Fuel Toolchain</strong> from the official release channels. It enables you to easily install pre-packaged toolchains, keep them up to date or even create custom toolchains and switch between them.</p>
<p><a href="https://github.com/FuelLabs/fuelup#installation">Fuelup</a> 是 <a href="https://fuel.network/">Fuel</a> 的官方包管理器和复用器，它从官方发布渠道安装<strong>Fuel工具链 (The Fuel Toolchain)</strong>。它使您能够轻松安装预打包的工具链，使其保持最新状态，甚至创建自定义工具链并在它们之间切换。</p>
<p>Binaries are executed through Fuelup as proxies which allow for flexibility in the execution of tools.</p>
<p>二进制文件通过 Fuelup 作为代理执行，使得工具的执行变得灵活。</p>
<p>It simplifies building and maintaining Sway applications with <a href="https://github.com/FuelLabs/sway/tree/master/forc">forc</a> and <a href="https://github.com/FuelLabs/fuel-core">fuel-core</a> for common platforms.</p>
<p>它为一般平台使用 <a href="https://github.com/FuelLabs/sway/tree/master/forc">forc</a> 和 <a href="https://github.com/FuelLabs/fuel-core">fuel-core</a> 简化了 Sway 应用的构建和维护。</p>
</blockquote>
<p>The <code>forc-wallet</code> now comes with the toolchain by default, i.e. running <code>fuelup toolchain install latest</code> grabs <code>forc-wallet</code> automatically as well.</p>
<p><code>forc-wallet</code> 现在默认带有工具链，即自动运行 <code>fuelup toolchain install latest</code> grabs <code>forc-wallet</code>。</p>
<hr>
<h2 id="sway">Sway</h2>
<h4 id="sway是什么-what-is-sway">Sway是什么 (What is Sway?)</h4>
<blockquote>
<p>Sway is a language for writing smart contracts for the <a href="https://github.com/FuelLabs/fuel-specs">Fuel Virtual Machine (FuelVM)</a>, a blazing-fast, blockchain-optimized VM designed for the Fuel blockchain. It is heavily inspired by Rust and aims to bring modern language development and performance to the blockchain ecosystem. Start learning the <a href="https://twitter.com/SwayLang">Sway language</a> today with the <a href="https://fuellabs.github.io/sway/latest/">Sway Book</a> and the <a href="https://www.youtube.com/watch?v=GKNuaFcPaXc">FuelVM Bootcamp</a>.<br>
Sway 是一种用于为 <a href="https://github.com/FuelLabs/fuel-specs">Fuel 虚拟机 (FuelVM)</a> 编写智能合约的语言，这是一种专为 Fuel 区块链设计的超快、区块链优化的虚拟机。它深受 Rust 的启发，旨在为区块链生态系统带来现代语言开发和性能。立即通过 <a href="https://fuellabs.github.io/sway/latest/">Sway Book</a> 和 [FuelVM Bootcamp](https: //www.youtube.com/watch?v=GKNuaFcPaXc) 来学习吧！</p>
</blockquote>
<h3 id="常规更新-general-updates">常规更新 (General Updates)</h3>
<ul>
<li>
<p>New support for generic traits in the type system, allowing the writing of more advanced, composable programs with advanced types;</p>
</li>
<li>
<p>类型系统中对泛型特征的新支持，允许编写更高级、可组合的高级类型程序；</p>
</li>
<li>
<p>Significant improvements to compile times by making optimizations to dead code analysis, Bytecode generation, Type checking, Register allocation, and more;<br>
通过优化死代码分析、字节码生成、类型检查、注册分配等，显着缩短编译时间；</p>
</li>
<li>
<p>New support for <code>asm</code> control flow for previously unsupported cases;<br>
对以前不受支持的情况的 <code>asm</code> 控制流的新支持；</p>
</li>
<li>
<p>A new <code>raw_ptr</code> type and a new <code>**</code> operator;<br>
新的 <code>raw_ptr</code> 类型和新的 <code>**</code> 运算符</p>
</li>
<li>
<p>Rework of method application syntax so that <code>~</code> is no longer needed;<br>
方法应用语法的返工，因此不再需要 <code>~</code> ；</p>
</li>
<li>
<p>New support for adding Turbofish-type arguments (<code>::&lt;T, F&gt;</code>) to method calls;<br>
新支持将 Turbofish 类型的参数 (<code>::&lt;T, F&gt;</code>) 添加到方法调用；</p>
</li>
<li>
<p>An updated way of representing function calls in the compiler backend that helps align the high-level compiler design with our vision of Sway features in the future;<br>
一种在编译器后端表示函数调用的更新方式，有助于使高级编译器设计与我们对未来 Sway 功能的愿景保持一致；</p>
</li>
<li>
<p>Removal of the <code>byte</code> type in favor of using the <code>u8</code> type;<br>
删除 <code>byte</code> 类型来支持使用 <code>u8</code> 类型；</p>
</li>
<li>
<p>Introduce a <code>__revert</code> intrinsic and disallow <code>rvrt</code>, <code>ret</code> and <code>retd</code> in <code>asm</code> blocks;<br>
在 <code>asm</code> 块中引入 <code>__revert</code> 内在函数并禁止使用 <code>rvrt</code>、<code>ret</code> 和 <code>retd</code>；</p>
</li>
<li>
<p>Disallow <code>impl self</code> blocks for <code>Contract</code>;<br>
不允许 <code>impl self</code> 冻结 <code>Contract</code> ；</p>
</li>
<li>
<p>Enable predicate-specific <code>asm</code> checks;<br>
启用谓词特定的<code>asm</code>检查；</p>
</li>
<li>
<p>Detect and disallow multiple methods with the same name;<br>
检测并禁止多个同名方法；</p>
</li>
<li>
<p>Improvements to error recovery during compilation;<br>
改进了编译期间的错误恢复；</p>
</li>
</ul>
<h3 id="标准库更新-standard-library-updates">标准库更新 (Standard Library Updates)</h3>
<ul>
<li>
<p>New function <code>set</code> for the <code>Vec&lt;T&gt;</code> type;<br>
<code>Vec&lt;T&gt;</code> 类型的新函数<code>set</code>；</p>
</li>
<li>
<p>New <code>Root</code>, <code>Logarithm</code>, and <code>BinaryLogarithm</code> traits implemented for <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> and <code>U128</code>;<br>
为 u8、u16、u32、u64 和 u128 实现了新的根、对数和二元对数特征；</p>
</li>
<li>
<p>新特征</p>
</li>
<li>
<p>New trait <code>core::ops::Not</code> with method <code>not()</code> to replace the free function <code>core::ops::not(b: bool)</code>;<br>
新特征 <code>core::ops::Not</code> 和方法 <code>not()</code> ，来替换自由函数 <code>core::ops::not(b: bool)</code>；</p>
</li>
<li>
<p>Add <code>StorageMap</code> to the standard library prelude;<br>
将 StorageMap 添加到标准库序曲；</p>
</li>
<li>
<p>Rename <code>transfer_to_output</code> to <code>transfer_to_address</code>;<br>
将 <code>transfer_to_output</code> 重命名为 <code>transfer_to_address</code>；</p>
</li>
<li>
<p>Revamped implementation of <code>send_message</code>;<br>
改进了 <code>send_message</code> 的实现；</p>
</li>
<li>
<p>Remove <code>raw_ptr::addr()</code>;<br>
删除<code>raw_ptr::addr()</code>；</p>
</li>
</ul>
<h3 id="fuel-orchestrator-forc-更新-fuel-orchestrator-forc-updates">Fuel Orchestrator (Forc) 更新-Fuel Orchestrator (Forc) Updates</h3>
<ul>
<li>
<p>New <code>forc-doc</code> plugin for automatically generating documentation from doc comments;<br>
新的 <code>forc-doc</code> 插件，用于从文档评论自动生成文档；</p>
</li>
<li>
<p>Introduce support for <code>[contract-dependencies]</code>  to <code>Forc.toml</code>;<br>
将对<code>[contract-dependencies]</code> 的支持引入<code>Forc.toml</code>；</p>
</li>
<li>
<p>Support for <code>forc-client</code> for signing transactions without <code>stdio</code> prompts;<br>
支持在没有<code>stdio</code> 提示的情况下签署交易的 <code>forc-client</code>；</p>
</li>
<li>
<p>New <code>--silent</code> and <code>--log-level</code> flags;<br>
新的 <code>--silent</code> 和 <code>--log-level</code> 标志；</p>
</li>
</ul>
<h3 id="forc后端-forc-backend">Forc后端 (Forc Backend)</h3>
<ul>
<li>
<p>Better error message when fetching a git dependency failed;<br>
获取 git 依赖项失败时更好的错误消息；</p>
</li>
<li>
<p>Improve how dependencies are fetched when local git sources are available;<br>
改进本地 git 源可用时获取依赖项的方式；</p>
</li>
<li>
<p>Additions to the Sway formatter;<br>
添加了 Sway 格式化程序；</p>
</li>
<li>
<p>Remove Rust integration testing behavior from <code>forc test</code>;<br>
从 <code>forc test</code> 中删除 Rust 集成测试行为；</p>
</li>
<li>
<p>Extract tracing utilities from <code>forc-util</code> into a dedicated <code>forc-tracing</code> plugin;<br>
从<code>forc-util</code>中提取跟踪实用程序到专用的 <code>forc-tracing</code>插件中；</p>
</li>
</ul>
<h3 id="sway语言服务器协议-sway-language-server-protocol-lsp">Sway语言服务器协议- Sway Language Server Protocol (LSP)</h3>
<ul>
<li>
<p>New support for inlay hints for variables;<br>
对变量的嵌入提示的新支持；</p>
</li>
<li>
<p>New support for showing formatted documentation on hover;<br>
新支持在悬停时显示格式化文档；</p>
</li>
<li>
<p>Errors and warnings are now displayed to users inside of their editors;<br>
错误和警告现在会在其编辑器中向用户显示；</p>
</li>
</ul>
<h2 id="fuel核心更新-fuel-core-updates">Fuel核心更新 (Fuel Core Updates)</h2>
<ul>
<li>
<p>Configurable block production modes (instant, interval, hybrid) for Proof of Authority (PoA);<br>
权威证明 (PoA) 的可配置块生产模式（即时、间隔、混合）</p>
</li>
<li>
<p>PoA block signing has been implemented;<br>
已实施 PoA 区块签名；</p>
</li>
<li>
<p>Multi-transaction blocks;<br>
多交易区块；</p>
</li>
<li>
<p>Cross-chain asset bridging to/from ETH;<br>
与 ETH 之间的跨链资产桥接；</p>
</li>
<li>
<p>Coinbase* transactions;<br>
Coinbase* 交易；</p>
</li>
<li>
<p>Generically typed transactions;<br>
一般类型的交易；</p>
</li>
<li>
<p>State opcodes now return whether the storage is unset or zeroed via <code>$rB</code> flag;<br>
状态操作码现在通过 <code>$rB</code> 标志返回存储是未设置还是归零；</p>
</li>
</ul>
<blockquote>
<p>*<strong>Coinbase</strong> refers to the validators paying themselves for processing a block from the transaction fees. Having a coinbase transaction on each block make this process transparent to all users.</p>
<p>*<strong>Coinbase</strong> 指的是验证者为处理一个区块支付自己的交易费用。在每个区块上都有一个 coinbase 交易使这个过程对所有用户透明。</p>
</blockquote>
<h2 id="fuels-rsrust-sdk更新-fuels-rs-rust-sdk-updates">Fuels-rs（Rust SDK）更新 - Fuels-rs (Rust SDK) Updates</h2>
<ul>
<li>
<p>Generate <code>ParamTypes</code> from your JSON ABI <code>TypeApplications</code>;<br>
从您的 JSON ABI <code>TypeApplications</code> 生成<code>ParamTypes</code>；</p>
</li>
<li>
<p>Automatic variable output estimation: no need to guess the variable outputs for your transactions;<br>
自动变量输出估计：无需猜测交易的变量输出；</p>
</li>
<li>
<p>You can now <code>.estimate_tx_dependencies(number_of_tries)</code> do update your transaction with the correct number of variable outputs. The same is coming for contract inputs;<br>
您现在可用 <code>.estimate_tx_dependencies(number_of_tries)</code> ，用正确数量变量输出更新您的交易。合约输入也是如此；</p>
</li>
<li>
<p>Contract instance creation now takes a <code>Bech32ContractId</code>, not a string, improving the type-safety around contract instantiation;<br>
合约实例的创建，现在采用 Bech32ContractId 而不是字符串，从而提高了合约实例化类型的安全性；</p>
</li>
<li>
<p>Notable QoL improvements<br>
显着的QoL质量改善</p>
</li>
<li>
<p>Query the balance from your contract through the <code>contract_instance</code>;<br>
通过 <code>contract_instance</code> 从您的合约中查询余额；</p>
<ul>
<li>
<p>Create <code>Bits256</code> from strings;<br>
从字符串创建 <code>Bits256</code>；</p>
</li>
<li>
<p>Many improvements to the <code>Provider</code> API and many new methods for it;<br>
<code>Provider</code> API 的许多改进和许多新方法；</p>
</li>
</ul>
</li>
</ul>
<h2 id="fuels-tstypescript-sdk更新-fuels-ts-typescript-sdk-updates">Fuels-ts（Typescript SDK）更新 Fuels-ts (Typescript SDK) Updates</h2>
<ul>
<li>
<p>New wallet functionality: vault export;<br>
新的钱包功能：保险库导出；</p>
</li>
<li>
<p>Full support for messages, which will enable bridge communication with the base layer, which is a major upcoming release;<br>
全面支持消息，这将启用与基础层的桥接通信，这是即将发布的主要版本；</p>
</li>
<li>
<p>The wallet now splits into <code>WalletLocked</code> for read-only operations and WalletUnlocked for write operations;<br>
钱包现在分为用于只读操作的 <code>WalletLocked</code> 和用于写入操作的 WalletUnlocked；</p>
</li>
<li>
<p>Automatic variable output estimation;<br>
自动变量输出估计</p>
</li>
</ul>
<hr>
<h2 id="敬请关注-follow-us"><strong>敬请关注 (Follow Us)</strong></h2>
<ul>
<li><a href="https://twitter.com/fuellabs_"><strong>Twitter</strong></a></li>
<li><a href="http://discord.com/invite/xfpK4Pe"><strong>Discord</strong></a></li>
<li><a href="https://www.linkedin.com/company/fuel-labs/"><strong>LinkedIn</strong></a></li>
<li><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong>YouTube</strong></a></li>
</ul>
<h2 id="关于我们-about-us"><strong>关于我们 (About Us)</strong></h2>
<p><a href="https://www.fuel.network/">Fuel</a> is the <strong>fastest execution layer</strong> for the modular blockchain stack. Powerful and sleek, the technology enables parallel transaction execution, empowering developers with the <strong>highest flexible throughput</strong> and <strong>maximum security</strong> required to scale. Developers choose the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> for its <strong>superior developer experience</strong> and the ability to go <strong>beyond the limitations of the EVM</strong>.</p>
<p><a href="https://www.fuel.network/">Fuel</a> 是模块化区块链技术栈的<strong>最快执行层</strong>。该技术功能强大且时尚，支持并行交易执行，为开发人员提供了扩展所需的<strong>最高灵活吞吐量</strong>和<strong>最大安全性</strong>。开发人员选择 <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> 是因为它<strong>卓越的开发人员体验和运行能力</strong> ，突破了 EVM 的限制**。</p>
<h2 id="成为贡献者-become-a-contributor"><strong>成为贡献者 (Become a Contributor)</strong></h2>
<ul>
<li>
<p><a href="https://jobs.lever.co/fuellabs">Explore our current job openings</a><br>
<a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></p>
</li>
<li>
<p><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">Apply for a grant</a><br>
<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请资助</a></p>
</li>
<li>
<p><a href="https://fuellabs.github.io/sway/v0.24.5/">Learn Sway</a><br>
<a href="https://fuellabs.github.io/sway/v0.24.5/">学习Sway</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[“Beta-2”官宣：Fuel的第二次公开测试(Announcing “Beta-2”： Fuel's Second Public Testnet)]]></title>
        <id>https://chainguys.github.io/post/beta-2guan-xuan-fuel-de-di-er-ci-gong-kai-ce-shi-announcing-beta-2-fuels-second-public-testnet/</id>
        <link href="https://chainguys.github.io/post/beta-2guan-xuan-fuel-de-di-er-ci-gong-kai-ce-shi-announcing-beta-2-fuels-second-public-testnet/">
        </link>
        <updated>2022-11-15T07:23:13.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/11/Beta-2-TestnetV2.png" alt="Announcing “Beta-2”: Fuel's Second Public Testnet" loading="lazy"></figure>
<hr>
<p>We are excited to announce the launch of the new Fuel <code>beta-2</code> testnet! This represents yet another milestone in our journey towards mainnet, and a modular execution layer that will bring true scalability to the Ethereum ecosystem.</p>
<p>我们很高兴地宣布推出全新的 Fuel <code>beta-2</code> 测试网！这代表了我们迈向主网和模块化执行层的又一个里程碑，它将为以太坊生统带来真正的可扩展性！</p>
<p>In September, <a href="https://fuel-labs.ghost.io/introducing-beta-1-testnet/">we launched <code>beta-1</code></a>, the first public Fuel testnet, offering open access for developers and users. This has already seen significant traction, with over 130,000 transactions in the span of 2 months. In addition, we've been amazed at the number of exciting new applications already building on Fuel, with <a href="https://github.com/FuelLabs/awesome-fuel#projects-building-on-fuel">over ten applications publicly launched</a> and many more in the works.</p>
<p>9 月，<a href="https://fuel-labs.ghost.io/introducing-beta-1-testnet/">我们推出了 <code>beta-1</code></a>，第一个公共 Fuel 测试网，向开发人员和用户开放访问。这已经产生了巨大的吸引力，在 2 个月内完成了超过 130,000 笔交易。此外，我们对已经在 Fuel 上构建的，令人兴奋的新应用数量感到惊讶，我们<a href="https://github.com/FuelLabs/awesome-fuel#projects-building-on-fuel">公开发布了十多个应用</a> 以及更多作品。</p>
<h2 id="在fuel-进行跨链-cross-chain-bridging-now-on-fuel">在Fuel 进行跨链 (Cross-Chain Bridging Now on Fuel)</h2>
<p>Expanding on the features of <code>beta-1</code>, the <code>beta-2</code> testnet is launching with a bridge to Ethereum's Goerli test network. Now, developers will be able to build and test cross-chain dapps, laying the foundations for projects building on Fuel to tap into Ethereum's massive liquidity and existing user base.</p>
<p>扩展了 <code>beta-1</code> 的功能，<code>beta-2</code> 测试网正在启动，并与以太坊的 Goerli 测试网络建立了跨链桥。现在，开发人员将能够构建和测试跨链 dapp，为基于 Fuel 构建的项目奠定基础，以利用以太坊的巨大流动性和用户群。</p>
<blockquote>
<p><em>Please note that <code>beta-2</code> is not an incentivized testnet. There will be no direct rewards for participation in this network.</em></p>
<p><em>请注意，<code>beta-2</code> 不是激励测试网。参与该网络不会有直接奖励。</em></p>
</blockquote>
<hr>
<h2 id="主要特征-key-features">主要特征 (Key Features)</h2>
<p>Below is a full list of key features for the <code>beta-2</code> testnet:</p>
<p>以下是 <code>beta-2</code> 测试网的主要功能的完整列表：</p>
<h3 id="跨链桥-bridge">🌉 跨链桥 (Bridge)</h3>
<p>The Fuel (<code>beta-2</code> testnet) &lt;&gt; Ethereum (Goerli testnet) bridge enables arbitrary message-passing between the two networks. It also supports enshrined ETH bridging, and ERC-20 token bridging <a href="https://github.com/FuelLabs/bridge-message-predicates">at the application level</a> thanks to account abstraction.</p>
<p>Fuel (<code>beta-2</code> 测试网) &lt;&gt; Ethereum (Goerli 测试网) 跨链桥支持两个网络之间的任意消息传递。感谢帐户抽象，它还<a href="https://github.com/FuelLabs/bridge-message-predicates">在应用级别</a>支持ETH 桥接和 ERC-20 代币桥接。</p>
<h3 id="单一共享网络-single-shared-network">🤝 单一共享网络 (Single Shared Network)</h3>
<p><code>beta-2</code> is a shared, public developer- and user-facing testnet. Developers can deploy contracts and users can then interact with those contracts.</p>
<p><code>beta-2</code> 是一个共享的、面向开发人员和用户的公共测试网。开发人员可以部署合约，然后用户可以与这些合约进行交互。</p>
<h3 id="水龙头-faucet">🚰 水龙头 (Faucet)</h3>
<p>Anyone can use the faucet to get some test ETH to deploy or interact with contracts. <a href="https://faucet-beta-2.fuel.network/">Available here</a>.</p>
<p>任何人都可以使用水龙头获得测试 ETH 来部署或与合约交互。 <a href="https://faucet-beta-2.fuel.network/">在此处获取</a>。</p>
<h3 id="graphql-端点-graphql-endpoint">📃 GraphQL 端点 (GraphQL Endpoint)</h3>
<p>The <a href="https://github.com/FuelLabs/fuel-core">Fuel Core</a> node uses GraphQL instead of JSON RPC. A playground for the public GraphQL endpoint for <code>beta-2</code> is <a href="https://node-beta-2.fuel.network/playground">available here</a>.</p>
<p><a href="https://github.com/FuelLabs/fuel-core">Fuel Core</a> 节点使用 GraphQL 而不是 JSON RPC。 <code>beta-2</code> 的公共 GraphQL 端点的游乐场/模拟处<a href="https://node-beta-2.fuel.network/playground">在此处可用</a>。</p>
<h3 id="区块浏览器-block-explorer">🔍 区块浏览器 (Block Explorer)</h3>
<p>A block explorer (still heavily a work-in-progress) is <a href="https://fuellabs.github.io/block-explorer-v2">available here</a>.</p>
<p>区块浏览器（仍在大量开发中）<a href="https://fuellabs.github.io/block-explorer-v2">可在此处获得</a>。</p>
<p><em>If you have any questions (development-related or otherwise), you can join the <a href="https://discord.gg/xfpK4Pe">Fuel Labs Discord</a> and head to the #questions channel under the Testnet category. Be sure to follow our <a href="https://twitter.com/fuellabs_">Twitter</a> for updates.</em></p>
<p><em>如果您有任何问题（与开发相关或其他），您可以加入 <a href="https://discord.gg/xfpK4Pe">Fuel Labs Discord</a> 并前往 Testnet 类别下的 #questions 频道。请务必关注我们的 <a href="https://twitter.com/fuellabs_">Twitter</a> 获取更新。</em></p>
<hr>
<h2 id="什么是新的-whats-new">什么是新的? (What's New)</h2>
<h3 id="️-sdks">⚙️ SDKs</h3>
<p>Both the <a href="https://github.com/FuelLabs/fuels-rs">Rust</a> and <a href="https://github.com/FuelLabs/fuels-ts">TypeScript</a> SDKs now support automatic log parsing. This allows developers to respond to events emitted during transaction execution, making their frontends responsive.</p>
<p><a href="https://github.com/FuelLabs/fuels-rs">Rust</a> 和 <a href="https://github.com/FuelLabs/fuels-ts">TypeScript</a> SDK 现在都支持自动日志解析。这允许开发人员响应交易执行期间发出的事件，使其前端可以响应。</p>
<p>Both SDKs also now support the Vec type as inputs to a contract call, enabling users to pass in variable-length input. If you're coming from Solidity, this is analogous to a dynamic-length array.</p>
<p>这两个 SDK 现在还支持 Vec 类型作为合约的调用来输入，使用户能够传入可变长度的输入。如果您来自 Solidity，这类似于动态长度数组。</p>
<h3 id="sway">🌴 Sway</h3>
<p>The compiler now produces bytecode that is 20-40% smaller in size, depending on the application. In addition to this, <a href="https://fuellabs.github.io/sway/v0.31.0/">Sway</a> now supports generic traits and trait constraints, allowing for more expressive libraries and abstractions.</p>
<p>编译器现在生成的字节码大小减少了 20-40%，具体取决于应用。除此之外，<a href="https://fuellabs.github.io/sway/v0.31.0/">Sway</a> 现在支持通用特征和特征约束，允许更具表现力的库和抽象。</p>
<p>Additional static analysis passes have been added, including one that enforces the checks-effects-interactions pattern when calling external contracts. In-language unit tests are also supported now, denoted by the #[test] annotation, similarly to Rust.</p>
<p>额外静态分析通道得到添加，包括在调用外部合约时强制执行检查-效果-交互模式的通道。现在也支持语言内单元测试，由 #[test] 注释表示，类似于 Rust。</p>
<p>The Sway compiler is now more performant, with 10-30% performance gains depending on the situation.</p>
<p>Sway 编译器现在性能更高，根据情况可提高 10-30% 的性能。</p>
<h3 id="lsp">🧩 LSP</h3>
<p>The language server now provides inlay hints for variables, allowing users to see the types their let expressions are resolved to.</p>
<p>语言服务器现在为变量提供内嵌提示，允许用户查看其 let 表达式解析的类型。</p>
<p>Hover support has been added, showing information such as the type, mutability and visibility of variables and parameters, function signatures, and formatted markdown documentation complete with syntax highlighting for in-documentation examples.</p>
<p>添加了悬停支持，显示变量和参数的类型、可变性和可见性、函数签名和格式化的 markdown 文档等信息，以及文档中示例的语法高亮。</p>
<h3 id="工具-tooling">🔧 工具 (Tooling)</h3>
<p><a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a> now provides support for declaring contract dependencies in your Forc.toml. This feature provides a simple way to pin contracts and refer to their unique IDs in code, avoiding the need to manually update each contract dependency's address on each change.</p>
<p><a href="https://github.com/FuelLabs/sway/tree/master/forc">Forc</a> 现在支持在 Forc.toml 中声明的合约依赖。此功能提供了一种简单的方法来固定合约，并在代码中引用其唯一 ID，避免嘞在每次更改时手动更新每个合约依赖的地址。</p>
<p>Forc also introduces support for workspaces, allowing to build, deploy or run multiple Forc projects under a single command. Initial support for a <code>forc doc</code> command has landed, aimed at generating a package's reference documentation from its doc-comments (i.e. <code>///</code>), though the output is still quite raw for now.</p>
<p>Forc 还引入了对工作区的支持，允许在单个命令下构建、部署或运行多个 Forc 项目。对 <code>forc doc</code> 命令的初步支持已经落地，旨在从其文档注释（即 <code>///</code>）生成包的参考文档，尽管目前输出仍然很原始。</p>
<p>Offline support has greatly improved as Forc gains the ability to share its dependency source cache between projects. This is further improved by fuelup’s new toolchain installation behavior which now pre-populates the cache with the core and std libraries.</p>
<p>随着 Forc 获得在项目之间共享其依赖源之缓存的能力，离线支持得到了极大的改善。 fuelup 的新工具链安装行为进一步改进了这一点，该行为现在使用核心和标准库预填缓存。</p>
<h3 id="客户端-client">🌐 客户端 (Client)</h3>
<p>The <a href="https://github.com/FuelLabs/fuel-core">Fuel client</a> now has support for bridging via a new kind of message UTXO, as well as a built-in relayer which interacts with Ethereum. It also now supports multi-transaction blocks in a proof-of-authority configuration. This allows for a diverse set of block production modes such as instant (for testing), fixed interval, and also dynamic block times based on the txpool size.</p>
<p><a href="https://github.com/FuelLabs/fuel-core">Fuel 客户端</a> 现在支持通过一种新型消息 UTXO 以及与以太坊交互的内置中继器，进行跨链。它现在还支持权威证明配置中的多交易块。这允许一组不同的块生产模式，例如即时（用于测试）、固定间隔以及基于 txpool 大小的动态块时间。</p>
<h3 id="钱包扩展-wallet-extension">🔌 钱包扩展 (Wallet Extension)</h3>
<p>Fuel now has a <a href="https://github.com/FuelLabs/fuels-wallet">browser extension wallet</a> that enables users to manage their assets and interact with dapps. This wallet was built from scratch and also exposes an SDK API directly on the user's browser, enabling developers to just focus on developing their application without the need to bundle an application-specific wallet.</p>
<p>Fuel 现在有一个<a href="https://github.com/FuelLabs/fuels-wallet">浏览器扩展钱包</a>，使用户能够管理他们的资产并与 dapp 交互。这个钱包是从头开始构建的，还直接在用户的浏览器上公开了一个 SDK API，使开发人员能够专注于开发他们的应用，而无需捆绑特定于应用的钱包。</p>
<hr>
<h2 id="对于开发者-for-developers">对于开发者 (For Developers)</h2>
<h3 id="水龙头-faucet-2">🚰 水龙头 (Faucet)</h3>
<ul>
<li>Valid transactions are required to deploy contracts and interact with the network, which require coins. Testnet ETH can be obtained from the <a href="https://faucet-beta-2.fuel.network/">faucet</a> by completing a captcha.<br>
需要有效交易才能部署合约并与网络交互，这需要代币。可以通过完成验证码从 <a href="https://faucet-beta-2.fuel.network/">水龙头</a> 获得测试 ETH。</li>
</ul>
<h3 id="钱包-wallet">💰 钱包 (Wallet)</h3>
<ul>
<li>
<p>A persistent CLI wallet (with binaries for Linux and MacOS) is <a href="https://github.com/FuelLabs/forc-wallet/releases/latest">available here</a>.<br>
持续性CLI 钱包（带有适用于 Linux 和 MacOS 的二进制文件）<a href="https://github.com/FuelLabs/forc-wallet/releases/latest">可在此处获得</a></p>
</li>
<li>
<p>A web/browser plugin wallet is under active development, <a href="https://github.com/FuelLabs/fuels-wallet">available here</a>.<br>
网络/浏览器插件钱包正在积极开发中，<a href="https://github.com/FuelLabs/fuels-wallet">可在此处获得</a>。</p>
</li>
</ul>
<h3 id="️-开始-getting-started">⚡️ 开始 (Getting Started)</h3>
<ul>
<li>
<p>For an overview of Fuel, take a look at the <a href="https://fuellabs.github.io/fuel-docs/master/index.html">Fuel documentation</a>.<br>
有关 Fuel 的概述，请查看 <a href="https://fuellabs.github.io/fuel-docs/master/index.html">Fuel 文档</a>。</p>
</li>
<li>
<p>To begin building on Fuel, check out the <a href="https://fuellabs.github.io/fuel-docs/master/developer-quickstart.html">developer quickstart</a>. This guide provides an end-to-end walkthrough for developers building a dapp on Fuel.<br>
要开始在 Fuel 上构建，请查看 <a href="https://fuellabs.github.io/fuel-docs/master/developer-quickstart.html">开发人员快速入门</a>。本指南为开发人员在 Fuel 上构建 dapp 提供了端到端的指导。</p>
</li>
</ul>
<h3 id="智能合约语言sway-smart-contract-language-sway">🌴 智能合约语言(Sway)-Smart Contract Language (Sway)</h3>
<ul>
<li>To begin developing a contract for Fuel, take a look at the <a href="https://fuellabs.github.io/sway/latest">Sway Book</a>, along with the <a href="https://github.com/FuelLabs/fuels-rs">Rust SDK</a> and <a href="https://github.com/FuelLabs/fuels-ts">TypeScript SDK</a>.<br>
要开始为 Fuel 开发合约，请查看 <a href="https://fuellabs.github.io/sway/latest">Sway Book</a>，以及 [Rust SDK](https://github.com/ FuelLabs/fuels-rs) 和 <a href="https://github.com/FuelLabs/fuels-ts">TypeScript SDK</a>。</li>
</ul>
<h3 id="申请自助-apply-for-a-grant">💸 申请自助 (Apply for a Grant)</h3>
<ul>
<li>If you're interested in going even further, we're supporting early-stage projects with our grants program, <a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">available here</a>.<br>
如果您有兴趣更进一步，我们将通过我们的<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">资助计划</a> 来支持早期项目。</li>
</ul>
<blockquote>
<p><em>Note that the <code>beta-2</code> testnet is under active development and may see breaking upgrades and even regenesis events.</em><br>
<em>请注意，<code>beta-2</code> 测试网正在积极开发中，可能会出现重大升级甚至重启事件。</em></p>
</blockquote>
<hr>
<h2 id="超越单片链-beyond-monolithic">超越单片链 (Beyond Monolithic)</h2>
<p>Modular blockchain design is quickly becoming the foremost solution to the challenge of scaling blockchains by orders of magnitude. The industry is rapidly moving away from monolithic blockchain designs and towards modular ones.</p>
<p>模块化区块链设计正迅速成为应对数量级扩展区块链挑战的最重要解决方案。该行业正在迅速从单一的区块链设计转向模块化设计。</p>
<p>We believe innovation does not require launching a new L1, but can rather happen at the execution layer. Fuel Labs is leading this charge with <a href="https://www.fuel.network/">Fuel</a>, the fastest modular execution layer.</p>
<p>我们认为创新不需要启动新的 L1，而是可以发生在执行层。 Fuel Labs 以最快的模块化执行层 <a href="https://www.fuel.network/">Fuel</a> 成为行业领先。</p>
<p>Unconstrained by the limitations of the EVM, Fuel approaches scalable execution from a modular-first perspective, allowing for <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">significant improvements over the EVM</a>'s inefficient execution environment and thus enabling maximum decentralization and the highest flexible throughput.</p>
<p>不受 EVM 限制，Fuel 从模块化优先的角度实现可扩展执行，使得 <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html"> EVM显着改进</a> 其低效执行环境，从而实现最大程度的去中心化和最高的灵活吞吐量。</p>
<p>With this new movement, we have an opportunity to start fresh and build a fundamentally new generation of blockchains that go <strong>#BeyondMonolithic</strong>.</p>
<p>通过这一新运动，我们有机会重新开始并构建从根本上走向 <strong>#超越单片链</strong> 的新一代区块链。</p>
<hr>
<h2 id="敬请关注-follow-us"><strong>敬请关注 (Follow Us)</strong></h2>
<ul>
<li><a href="https://twitter.com/fuellabs_"><strong>Twitter</strong></a></li>
<li><a href="http://discord.com/invite/xfpK4Pe"><strong>Discord</strong></a></li>
<li><a href="https://www.linkedin.com/company/fuel-labs/"><strong>LinkedIn</strong></a></li>
<li><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong>YouTube</strong></a></li>
</ul>
<h2 id="关于我们-about-us"><strong>关于我们 (About Us)</strong></h2>
<p><a href="https://www.fuel.network/">Fuel</a> is the <strong>fastest execution layer</strong> for the modular blockchain stack. Powerful and sleek, the technology enables parallel transaction execution, empowering developers with the <strong>highest flexible throughput</strong> and <strong>maximum security</strong> required to scale. Developers choose the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> for its <strong>superior developer experience</strong> and the ability to go <strong>beyond the limitations of the EVM</strong>.</p>
<p><a href="https://www.fuel.network/">Fuel</a> 是模块化区块链技术栈的<strong>最快执行层</strong>。该技术功能强大且时尚，支持并行交易执行，为开发人员提供了扩展所需的<strong>最高灵活吞吐量</strong>和<strong>最大安全性</strong>。开发人员选择 <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> 是因为它<strong>卓越的开发人员体验和运行能力</strong> ，突破了 EVM 的限制**。</p>
<h2 id="成为贡献者-become-a-contributor"><strong>成为贡献者 (Become a Contributor)</strong></h2>
<ul>
<li>
<p><a href="https://jobs.lever.co/fuellabs">Explore our current job openings</a><br>
<a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></p>
</li>
<li>
<p><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">Apply for a grant</a><br>
<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请资助</a></p>
</li>
<li>
<p><a href="https://fuellabs.github.io/sway/v0.24.5/">Learn Sway</a><br>
<a href="https://fuellabs.github.io/sway/v0.24.5/">学习Sway</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[“Oh Ottie！” 12月NFT收藏空投：即日起加入白名单！(“Oh Ottie!” NFT Collection Drop in December：Get Whitelisted today!)]]></title>
        <id>https://chainguys.github.io/post/oh-ottie-12-yue-nft-shou-cang-kong-tou-ji-ri-qi-jia-ru-bai-ming-dan-oh-ottie-nft-collection-drop-in-decemberget-whitelisted-today/</id>
        <link href="https://chainguys.github.io/post/oh-ottie-12-yue-nft-shou-cang-kong-tou-ji-ri-qi-jia-ru-bai-ming-dan-oh-ottie-nft-collection-drop-in-decemberget-whitelisted-today/">
        </link>
        <updated>2022-11-07T03:30:28.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/1*YSjiQ3jrelHE8SmHtSjXyA.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>Mint Oh Ottie! using native assets bridged from Ethereum, BNB Chain &amp; Polygon<br>
铸币Ottie！使用从以太坊、BNB 链和Polygon跨链原生资产</p>
</li>
<li>
<p>Read Instructions &amp; Whitelist <a href="https://sograph.xyz/space/altlayer/campaign/yVFDYdj1ao">Here</a> from 8 November — 4 December<br>
从 11月8日至12月4日：阅读说明和白名单 [此处]</p>
</li>
</ul>
<hr>
<p>We’ve got some exciting news for you. Following the great feedback we’ve had on our loving mascot Ottie since we introduced him to you all, we’ve decided to release a collection of 2,000 unique Ottie avatars as part of an NFT collection titled <strong>‘<em>Oh Ottie</em>!’</strong></p>
<p>我们有一些让人兴奋的消息要告诉你。自从我们向大家介绍可爱的吉祥物 Ottie 以来，我们收到了很好的反馈，我们决定发布一个包含 2,000 个独特 Ottie 头像的集合，作为 NFT 集合的一部分，标题为 <strong>‘<em>Oh Ottie</em>！’</strong></p>
<p>Each avatar represents Ottie with his different facets — be it hobbies, professions or moods! Each of them will entail special rights and privileges.</p>
<p>每个头像都代表着Ottie的不同方面——无论是爱好、职业还是心情！他们每个人都将有不同的权利和好处。</p>
<p>Similar to the OG Badge Drop, the <strong>Oh Ottie!</strong> mint will showcase Altlayer’s superior flashlayer technology, which enables NFT minting in a gasless manner across EVM and non-EVM chains.</p>
<p>与 OG Badge Drop 类似，<strong>Oh Ottie!</strong> 铸币将展示 Altlayer 卓越的 flashlayer 技术，该技术可以跨 EVM 和非 EVM 链以无gas方式进行 NFT 铸币。</p>
<p>But this time around, we’re taking it to the next level. <strong>Oh Ottie!</strong> NFTs can be minted using native assets bridged from Ethereum, BNB Chain and Polygon, and eventually roll up the assets to Ethereum for trading.</p>
<p>但这一次，我们将其提升到了一个新的水平。 <strong>Oh Ottie！</strong> NFT 可以使用从以太坊、BNB 链和Polygon跨链的原生资产铸币，并最终将资产汇总到以太坊进行交易。</p>
<h2 id="总供应量-total-supply"><strong>总供应量 (Total Supply)</strong></h2>
<p>Of the 2,000 avatars in the <strong>Oh Ottie!</strong> collection:<br>
在 <strong>Oh Ottie!</strong> 系列中的 2,000 个头像中：</p>
<ul>
<li>
<p>1,200 will be minted on our flashlayer at a mint price of 0.08 ETH or equivalent on 9 December<br>
12月9日将在我们的 flashlayer 上以 0.08 ETH 或等值的价格铸币 1,200 个</p>
</li>
<li>
<p>420 will be airdropped to existing OG Badge NFT holders prior to the mint event<br>
420 将在铸币活动之前空投给现有的 OG Badge NFT 持有者</p>
</li>
<li>
<p>180 will be distributed to partner projects and communities for lucky draws before the mint event<br>
180个将在铸币活动前分发给合作项目和社区进行幸运抽奖</p>
</li>
<li>
<p>200 avatars will be specially reserved for future community engagement and partnership usage<br>
200个头像将专门为未来的社区参与和合作伙伴使用而保留</p>
</li>
</ul>
<h2 id="为什么要得到-oh-ottie-nftwhy-get-an-oh-ottie-nft"><strong>为什么要得到 Oh Ottie NFT？Why get an Oh Ottie NFT?</strong></h2>
<p>We’ll be sharing our love for Ottie with our community via online and offline engagement, and social impact activities. Here are some of the privileges for <strong>Oh Ottie!</strong> holders.</p>
<p>我们将通过在线和离线参与，以及社会影响活动与我们的社区分享对 Ottie 的热爱。以下是 <strong>Oh Ottie!</strong> 持有者的一些特权。</p>
<ul>
<li>
<p>Future claim to token/NFT airdrop<br>
未来声索代币/NFT 空投</p>
</li>
<li>
<p>Exclusive access to merchandise and offline events<br>
独家访问商品和线下活动</p>
</li>
<li>
<p>Priority access to testnet validator program<br>
优先访问测试网验证程序</p>
</li>
<li>
<p>AltLayer will represent the community to adopt &amp; sponsor otters in zoos globally including but not limited to Singapore Zoo<br>
AltLayer 将代表社区在全球动物园收养和赞助水獭，包括但不限于新加坡动物园</p>
</li>
</ul>
<h2 id="重要的日子-important-dates"><strong>重要的日子 (Important Dates)</strong></h2>
<ul>
<li>
<p>Whitelisting opens at 18.00 PM SGT on <strong>8 November</strong> and ends on <strong>4 December</strong> at 23.59 PM SGT.<br>
白名单于 <strong>11月8日</strong> 晚上 18:00 SGT 开始，并于<strong>12 月 4 日</strong> 下午 23:59 SGT 结束。</p>
</li>
<li>
<p>On <strong>7 December,</strong> we will publish the how-to-mint guide and open the <strong><em>one-way</em> <em>bridge</em></strong> for you to transfer your ETH, BNB and Matic tokens to our flashlayer.<br>
<strong>12 月 7 日</strong>  我们将发布铸币指南并打开 <strong><em>one-way</em> <em>bridge</em></strong> 供您将您的 ETH、BNB 和 Matic 代币转移到我们的 flashlayer。</p>
</li>
</ul>
<p>Note that there will be only one flashlayer rollup that spans across Ethereum, BNB Chain and Polygon, and supports ETH, BNB and Matic tokens. Users can opt for one or more token types (among ETH, BNB and Matic) to mint, as long as you have sufficient balance of the relevant token on our flashlayer.</p>
<p>请注意，只有一个 flashlayer rollup 跨越以太坊、BNB 链和Polygon，并支持 ETH、BNB 和 Matic 代币。用户可以选择一种或多种代币类型（ETH、BNB 和 Matic）来铸币，只要您在我们的 flashlayer 上有足够的相关代币余额即可。</p>
<p>Also note that you <strong><em>won’t</em></strong> be able to withdraw your bridged token assets on our flashlayer until the mint event is over. Please be mindful of the token amount to bridge for minting.</p>
<p>另请注意，在铸币活动结束之前，您 <strong><em>不能</em></strong>  在我们的 flashlayer 上提取您的跨链代币资产。请注意用于铸币的代币数量。</p>
<h2 id="铸币活动-mint-event"><strong>铸币活动 (Mint Event)</strong></h2>
<p>The mint event lasts for 24 hours and has two parts.</p>
<p>铸币事件持续 24 小时，分为两部分。</p>
<p><strong><em>Part 1 — Private Mint:</em></strong> On 9 December, we’ll start private minting for whitelisted addresses between 12.00 PM — 16.00 PM SGT .<br>
<em>第 1 部分 - 私密铸币：</em>**12 月 9 日，我们将在 12.00 PM - 16.00 PM SGT 之间开始对列入白名单的地址进行私密铸币。</p>
<p><strong><em>Part 2 — Public Mint:</em></strong> Public minting is open for all. It starts at 16.00 PM SGT on 9 December and lasts for the next 20 hours. The one-way bridge will remain open until the mint event is over.<br>
<em>第 2 部分——公开铸币：</em> **公开铸币对所有人开放。它从 12 月 9 日 SGT 下午 16 点开始，持续接下来的 20 个小时。单向跨链桥将保持开放，直到铸币活动结束。</p>
<ul>
<li>
<p>The mint event ends either when all 1,200 avatars are fully minted or when the 24 hour mint period is over.<br>
当所有 1,200 个头像全部铸币完毕或 24 小时铸币期结束时，铸币活动结束。</p>
</li>
<li>
<p>Each wallet address is allowed to mint a maximum of 10 avatars regardless of the token used.<br>
无论使用何种代币，每个钱包地址最多可铸造 10 个头像。</p>
</li>
<li>
<p>Note that only $ETH, $BNB and Matic tokens are supported on our flashlayer. You won’t be able to bridge over other tokens.<br>
请注意，我们的 flashlayer 仅支持 $ETH、 $BNB 和 Matic 代币。您将无法跨越其他代币。</p>
</li>
</ul>
<h2 id="铸币后活动-post-mint-event"><strong>铸币后活动 (Post Mint Event)</strong></h2>
<ul>
<li>
<p>After the end of the mint event, we will automatically bridge all the minted avatars back to Ethereum and all the remaining token assets back to Ethereum, BNB Chain and Polygon via rollup process. You won’t have to bridge your assets back to L1 yourselves.<br>
铸币活动结束后，我们将通过汇总流程，将所有铸币头像自动跨链回以太坊，并将所有剩余的代币资产跨链回以太坊、BNB 链和 Polygon。您不必自己将资产跨链到 L1。</p>
</li>
<li>
<p>Upon receiving your minted avatars on Ethereum mainnet, you will be able to trade the <strong>Oh Ottie!</strong> Collection on Opensea, Looksrare, X2Y2 and Blur, etc<br>
在以太坊主网上收到您铸造的头像后，您将能够在 Opensea、Looksrare、X2Y2 和 Blur 等平台上交易 <strong>Oh Ottie!</strong> 收藏</p>
</li>
</ul>
<h2 id="如何获得空投资格how-can-you-qualify-for-the-airdrop"><strong>如何获得空投资格？(How can you qualify for the airdrop?)</strong></h2>
<p>If you are holders of our existing OG Badge NFTs, you can just sit tight and will automatically receive an airdrop of <strong>Oh Ottie!</strong> avatar prior to our mint event. We will disclose details including snapshot time later.</p>
<p>如果您是我们现有的 OG 徽章 NFT 的持有者，您只需坐好，就会在我们的铸币活动开始前自动收到 <strong>Oh Ottie!</strong> 头像的空投。我们将在稍后披露包括快照时间在内的详细信息。</p>
<h2 id="如何才能有资格参加铸币活动how-can-you-qualify-for-the-mint-event"><strong>如何才能有资格参加铸币活动？(How can you qualify for the mint event?)</strong></h2>
<p>You can increase the odds of getting hold of the <strong>Oh Ottie!</strong> avatars by <strong>joining the whitelisting process.</strong></p>
<p>您可以通过加入白名单流程来增加获得 <strong>Oh Ottie!</strong> 头像的几率。</p>
<p>Please complete the following tasks on <a href="https://sograph.xyz/space/altlayer/campaign/yVFDYdj1ao">this</a> page.</p>
<p>请在 <a href="https://sograph.xyz/space/altlayer/campaign/yVFDYdj1ao">这个</a> 页面上完成以下任务。</p>
<ul>
<li>
<p>Follow <a href="https://twitter.com/alt_layer">Yaoqi Jia</a> on Twitter<br>
在 Twitter 上关注 <a href="https://twitter.com/alt_layer">Yaoqi Jia</a></p>
</li>
<li>
<p>Follow <a href="https://twitter.com/alt_layer">Altlayer</a> on Twitter<br>
在 Twitter 上关注 <a href="https://twitter.com/alt_layer">Altlayer</a></p>
</li>
<li>
<p>Like and Retweet the pinned <strong>Oh Ottie!</strong> <a href="https://twitter.com/alt_layer/status/1589918467377205248">announcement</a><br>
喜欢并转发置顶的****Oh Ottie！** <a href="https://twitter.com/alt_layer/status/1589918467377205248">公告</a></p>
</li>
<li>
<p>Join our <a href="https://discord.gg/altlayer">Discord server</a> and complete the necessary steps<br>
加入我们的 <a href="https://discord.gg/altlayer">Discord 服务器</a> 并完成必要的步骤</p>
</li>
<li>
<p>Connect with your Ethereum wallet address<br>
连接您的以太坊钱包地址</p>
</li>
</ul>
<p>让白名单开始吧！<br>
Let the whitelisting begin!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ETH里斯本活动回顾 (ETH Lisbon Recap)]]></title>
        <id>https://chainguys.github.io/post/eth-li-si-ben-huo-dong-hui-gu-eth-lisbon-recap/</id>
        <link href="https://chainguys.github.io/post/eth-li-si-ben-huo-dong-hui-gu-eth-lisbon-recap/">
        </link>
        <updated>2022-11-04T08:02:12.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/10/EthLisbonRecap-3.png" alt="🇵🇹 — ETH Lisbon Recap" loading="lazy"></figure>
<p>During 3 days (October 28 - 30), hackers from around the world gathered at the Academia das Ciências in Lisbon for hacking. Here is an in-depth look at the winning projects.</p>
<p>在3天内(10 月 28 日至 30 日），来自世界各地的黑客聚集在里斯本的 Academia das Ciências 进行黑客活动。以下是对获奖项目的深入观察。</p>
<hr>
<p>During 3 days (October 28 - 30), hackers from all over the world gathered at the <em>Academia das Ciências</em> in Lisbon for hacking. For this occasion, we sponsored 3 open bounties for bold hackers eager to build on <strong>Fuel</strong> <strong>Beta-1</strong> testnet using <strong>Sway</strong>:</p>
<p>在3天内(10 月 28 日至 30 日），来自世界各地的黑客聚集在里斯本的 Academia das Ciências 进行黑客活动。为此，我们为渴望使用 <strong>Sway</strong> 在 <strong>Fuel</strong> <strong>Beta-1</strong> 测试网上构建的大胆黑客赞助了 3 项公开赏金：</p>
<ul>
<li>🥇 <strong>First Prize 1等奖</strong>  — $3,000</li>
<li>🥈 <strong>Second Prize 2等奖</strong>** — $2,000</li>
<li>🥉 <strong>Third Prize 3等奖</strong>** — $1,000</li>
</ul>
<h2 id="获胜者-the-winners">🏆 获胜者 (The winners)</h2>
<p>Let's go over the winning projects:<br>
让我们一起回顾这些获奖项目</p>
<h3 id="一等奖authsome-first-prize-authsome">🥇 一等奖—Authsome (First Prize — Authsome)</h3>
<p>Authsome implements a multi-signature wallet using the predicate system of the FuelVM and Sway. This wallet is then used as the basis for a pluggable authentication infrastructure, similar to <a href="https://web3auth.io/docs/overview/what-is-web3auth">Web3Auth</a>.</p>
<p>Authsome 使用 FuelVM 和 Sway 的谓词系统实现了一个多签钱包。然后将此钱包用作可插入身份验证基础设施的底层，类似于 <a href="https://web3auth.io/docs/overview/what-is-web3auth">Web3Auth</a>。</p>
<blockquote>
<p>Fuel Predicates<br>
Fuel谓词</p>
<p>Fuel predicates work in a similar way to scripts for pay-to-script-hash (P2SH) transactions in Bitcoin. This offers a number of important advantages over implementing account abstraction on the smart contract layer:</p>
<p>Fuel 谓词的工作方式与比特币中支付-脚本-哈希（P2SH）交易的脚本类似。这给在智能合约层实现账户抽象提供了许多重要的优势。</p>
<ul>
<li>Reduced gas cost, as signature aggregation can be done off-chain and verification can be done as a single step without smart contract function calls;<br>
降低了gas成本，因为签名聚合可以在链外完成，验证可以作为一个单一的步骤完成，不需要调用智能合约函数。</li>
<li>Improved flexibility, because different signature schemes can be swapped in by implementing them as on-chain smart contract libraries and using them in predicates; and<br>
提高了灵活性，因为不同的签名方案可以通过作为链上智能合约库实现进而转换并在谓词中使用而；以及</li>
<li>Minimal state bloat, because predicate byte code is processed once as part of the transaction validation, and then discarded - thus never entering the blockchain state.<br>
最小的状态膨胀，因为谓词字节码作为交易验证的一部分被处理一次，然后被丢弃--因此从未进入区块链状态。</li>
</ul>
</blockquote>
<p>This project leverages the power of account abstraction and multi-signatures to create Web2-like experiences with Web3 custodial properties.</p>
<p>该项目利用帐户抽象和多重签名的力量来创建具有 Web3 托管属性的类似 Web2 的体验。</p>
<p>Check out their demo video below:</p>
<p>在下面查看他们的演示视频：</p>
<iframe width="720" height="540" src="https://www.youtube.com/embed/3CwjZpXR1SM" title="Authsome  ETH Lisbon" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 id="它是如何工作-how-does-it-work">它是如何工作? (How does it work?)</h3>
<p>You first need to log in with an email address and a password of your choice. Authsome will then generate a 2 of 3 addresses multi-signature wallet, which means that you need 2 addresses to execute a transaction or log in to Authsome. Each key will be stored in different places.</p>
<p>你首先需要一个电子邮件和密码登录。然后，Authsome将生成一组2-3个地址的多签钱包，这意味着你需要2个地址来执行交易或登录Authsome。每个密钥将被存储在不同的地方。</p>
<p>Then you're all set to execute blazingly fast payments: You log in with your password to unlock the first key, and the second key is loaded from your browser's local storage.</p>
<p>然后你就可以执行极快的支付了。你用你的密码登录来解锁第一把秘钥，第二把秘钥从你的浏览器的本地存储中加载。</p>
<p>When you confirm your transaction on the Frontend, the DApp will generate a two-signature predicate transaction for each spended UTXO.</p>
<p>当你在前台确认你的交易时，DApp将为每个花费的UTXO生成一个双签名的谓词交易。</p>
<p>The real benefit of this application is that it supports spending multiple UTXOs with distinct predicate data.</p>
<p>这个应用真正的好处是，它支持用不同的谓词数据来花费(影响)多个UTXO。</p>
<p>For more information, check out their <a href="https://github.com/authsome/authsome">GitHub repository</a>.</p>
<p>欲了解更多信息，请查看他们的<a href="https://github.com/authsome/authsome">GitHub仓库</a>。</p>
<h3 id="二等奖fuel价格预言机-second-prize-fuel-price-oracle">🥈 二等奖—Fuel价格预言机 (Second Prize — Fuel Price Oracle)</h3>
<p>Fuel Price Oracle implements a simple ETH - DAI tokens price oracle. This project allows retrieving token prices from the outside world on the Fuel chain with a Sway smart contract.</p>
<p>Fuel价格预言机实现了一个简单的ETH-DAI代币的价格预言机。这个项目允许使用Sway智能合约从外界检索Fuel链上的代币价格。</p>
<p>Check out their demo video below:</p>
<p>请看下面的演示视频:</p>
<iframe width="720" height="540" src="https://www.youtube.com/embed/geJ-aKOZQTU" title="Fuel price oracle (ETH, DAI) demo" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>For more information, check out their <a href="https://github.com/chlenc/fuel-price-oracle">GitHub repository</a>.</p>
<p>欲了解更多信息，请查看他们的<a href="https://github.com/chlenc/fuel-price-oracle">GitHub仓库</a>。</p>
<h3 id="三等奖资本家猪-third-prize-capitalist-pigs">🥉 三等奖—资本家猪 (Third Prize — Capitalist Pigs)</h3>
<p>Enter the world of Capitalist Pigs, a Gamify staking for fees in a DeFi project using a set of NFTs.</p>
<p>进入Capitalist Pigs的世界，这是一个使用一套NFTs在DeFi项目中质押产生费用(收益)的Gamify。</p>
<p>Check out their demo video below:</p>
<p>请看下面他们的演示视频</p>
<iframe width="720" height="407" src="https://www.youtube.com/embed/WeVj2tXGa-M" title="Capitalist Pigs - 30 October 2022" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<h3 id="它如何工作-how-does-it-work">它如何工作? (How does it work?)</h3>
<p>First of all, you begin by generating a burner wallet on the upper right corner of the DApp. To start playing, you need to claim a <strong>Pig</strong>, a stakable collectible NFT asset. By staking it, you will earn <strong>Truffles</strong> and <strong>staking fees</strong> represented by <strong>Bacon</strong>. Truffles can be turned into <strong>Piglets</strong>. With those Piglets, you have 2 possibilities: you can either turn them into Pigs or delegate them to existing Pigs to increase their staking fee generation. And this is it, you're a Capitalist Pig! You can check in the lower right corner the evolution of your supply (Pigs, Piglets, Truffles, and Bacon).</p>
<p>首先，你开始在DApp的右上角生成一个燃烧钱包。要开始玩，你需要认领一只<strong>猪</strong>，这是一种可收藏的NFT资产。通过抵押，你将获得<strong>松露</strong>和<strong>培根</strong>代表的<strong>抵押费。松露可以转化为小猪</strong>。对于这些小猪，你有两种可能：你可以把它们变成小猪，或者把它们委托给现有的小猪，来增加它们的产出。就这样，你就是一只资本家猪了！你可以在右下角检查。你可以在右下角检查你的供应（猪、小猪、松露和培根）的演变。</p>
<p>Try it out now <a href="https://capitalistpi.gs/">here</a>.</p>
<p>现在就试试吧<a href="https://capitalistpi.gs/">这里</a>。</p>
<p>For more information, check out their <a href="https://github.com/afsardo/capitalist-pigs">GitHub repository</a>.</p>
<p>欲了解更多信息，请查看他们的<a href="https://github.com/afsardo/capitalist-pigs">GitHub仓库</a>。</p>
<hr>
<h1 id="今天就开始在fuel构建吧-start-building-on-fuel-today">今天就开始在Fuel构建吧! （Start Building On Fuel Today）</h1>
<blockquote>
<p>Building on Fuel means breaking free from the constraints of monolithic blockchains that have held us back.<br>
以 Fuel 为基础意味着摆脱阻碍我们前进的单片区块链的限制。</p>
</blockquote>
<h2 id="fuel的开发人员资源-developer-resources-for-building-with-fuel">Fuel的开发人员资源 (Developer Resources for Building with Fuel)</h2>
<ul>
<li>
<p>A step-by-step guide to building a full-stack dapp on Fuel can be found <a href="https://github.com/camiinthisthang/fullstack-fuel/blob/main/README.md">here</a>.<br>
<a href="https://github.com/camiinthisthang/fullstack-fuel/blob/main/README.md">这里</a> 可以找到在 Fuel 上构建全栈 dapp 的分步指南</p>
</li>
<li>
<p>The <strong>Fuel Book</strong> can be found <a href="https://fuellabs.github.io/fuel-docs/master/index.html">here</a>. It contains everything you need to know about Fuel, from its modular design to its key features.<br>
<strong>Fuel全书</strong> 可以在 <a href="https://fuellabs.github.io/fuel-docs/master/index.html">这里</a> 找到。它包含您需要了解的有关 Fuel 的所有信息，从模块化设计到主要功能。</p>
</li>
<li>
<p>The <strong>Sway Book</strong> can be found <a href="https://fuellabs.github.io/sway/v0.24.1/">here</a>.<br>
<strong>Sway全书</strong> 可以在 <a href="https://fuellabs.github.io/sway/v0.24.1/">这里</a> 找到。</p>
</li>
</ul>
<hr>
<h2 id="敬请关注-follow-us"><strong>敬请关注 (Follow Us)</strong></h2>
<ul>
<li><a href="https://twitter.com/fuellabs_"><strong>Twitter</strong></a></li>
<li><a href="http://discord.com/invite/xfpK4Pe"><strong>Discord</strong></a></li>
<li><a href="https://www.linkedin.com/company/fuel-labs/"><strong>LinkedIn</strong></a></li>
<li><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong>YouTube</strong></a></li>
</ul>
<h2 id="关于我们-about-us"><strong>关于我们 (About Us)</strong></h2>
<p><a href="https://www.fuel.network/">Fuel</a> is the <strong>fastest execution layer</strong> for the modular blockchain stack. Powerful and sleek, the technology enables parallel transaction execution, empowering developers with the <strong>highest flexible throughput</strong> and <strong>maximum security</strong> required to scale. Developers choose the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> for its <strong>superior developer experience</strong> and the ability to go <strong>beyond the limitations of the EVM</strong>.</p>
<p><a href="https://www.fuel.network/">Fuel</a> 是模块化区块链技术栈的<strong>最快执行层</strong>。该技术功能强大且时尚，支持并行交易执行，为开发人员提供了扩展所需的<strong>最高灵活吞吐量</strong>和<strong>最大安全性</strong>。开发人员选择 <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> 是因为它<strong>卓越的开发人员体验和运行能力</strong> ，突破了 EVM 的限制**。</p>
<h2 id="成为贡献者-become-a-contributor"><strong>成为贡献者 (Become a Contributor)</strong></h2>
<ul>
<li>
<p><a href="https://jobs.lever.co/fuellabs">Explore our current job openings</a><br>
<a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></p>
</li>
<li>
<p><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">Apply for a grant</a><br>
<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请资助</a></p>
</li>
<li>
<p><a href="https://fuellabs.github.io/sway/v0.24.5/">Learn Sway</a><br>
<a href="https://fuellabs.github.io/sway/v0.24.5/">学习Sway</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Alpha Venture DAO 和 Sei 携手推动 DeFi 创新 (Alpha Venture DAO and Sei Join Forces to Supercharge DeFi Innovations)]]></title>
        <id>https://chainguys.github.io/post/alpha-venture-dao-he-sei-xi-shou-tui-dong-defi-chuang-xin-alpha-venture-dao-and-sei-join-forces-to-supercharge-defi-innovations/</id>
        <link href="https://chainguys.github.io/post/alpha-venture-dao-he-sei-xi-shou-tui-dong-defi-chuang-xin-alpha-venture-dao-and-sei-join-forces-to-supercharge-defi-innovations/">
        </link>
        <updated>2022-11-03T02:06:15.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://blog.seinetwork.io/content/images/size/w2000/2022/11/FgannAiXEAAUKG7.jpg" alt="Alpha Venture DAO and Sei Join Forces to Supercharge DeFi Innovations" loading="lazy"></figure>
<p><em>Sei brings hands-on mentorship to Alpha Incubate Batch 2, a bespoke DeFi incubation program that serves as your Build Partner</em><br>
<em>Sei 为 Alpha Incubate Batch 2 带来实践指导，作为构建的合作伙伴，这是一个定制的 DeFi 孵化计划。</em></p>
<hr>
<p><a href="https://www.globenewswire.com/Tracker?data=y2KLbsD6XLpIrFf5U4-mTzyCGy_mH4juTq96w1MjUsooERoOgeq_rl_QGb1ckaNm1dxYIbwEsNbtUe7jRLErSg==">Sei</a>, a first sector specific Layer 1 specialized for trading and fastest chain to finality, joins together with <a href="https://www.globenewswire.com/Tracker?data=b8zfepe181ZtyeY-2vcAlZnbH7O7_d5yvL7PWJicpjPB87KfR1qeWUGGH6ToQi2NQB4M7BzHOCsMJrDfbKX6lMsPVyIIJs_l8LCh-be03QU=">Alpha Venture DAO</a>, a renowned Web 3.0 venture builder, to deliver the most competitive incubation program, ‘<a href="https://www.globenewswire.com/Tracker?data=b8zfepe181ZtyeY-2vcAlSOe2M-i9XQdUEgwX3S6PoEmC2-4Y54KEX-SUxWZqjRcb-f7v9DXEDNLHA6gbIqTg5WgDsOIOWy-EMtrUv2bc_TAUi7jSwfu5Bsheu7ZRs_o"><strong>Alpha Incubate Batch 2</strong></a>’ to DeFi builders. We collaborate to give innovators with hands-on mentorship experience in creating simple, secure, scalable dApps on Sei and to accelerate the growth of DeFi projects.</p>
<p><a href="https://www.globenewswire.com/Tracker?data=y2KLbsD6XLpIrFf5U4-mTzyCGy_mH4juTq96w1MjUsooERoOgeq_rl_QGb1ckaNm1dxYIbwEsNbtUe7jRLErSg==">Sei</a>是第一个专门用于交易的特定layer1，也是最快完成交易的链条，它与<a href="https://www.globenewswire.com/Tracker?data=b8zfepe181ZtyeY-2vcAlZnbH7O7_d5yvL7PWJicpjPB87KfR1qeWUGGH6ToQi2NQB4M7BzHOCsMJrDfbKX6lMsPVyIIJs_l8LCh-be03QU=">Alpha Venture DAO</a>，一个著名的Web 3.0风投建设者联合起来，向DeFi建设者提供最具竞争力的孵化计划，&quot;<a href="https://www.globenewswire.com/Tracker?data=b8zfepe181ZtyeY-2vcAlSOe2M-i9XQdUEgwX3S6PoEmC2-4Y54KEX-SUxWZqjRcb-f7v9DXEDNLHA6gbIqTg5WgDsOIOWy-EMtrUv2bc_TAUi7jSwfu5Bsheu7ZRs_o"><strong>Alpha Incubate Batch</strong></a>。我们的合作是为了给创新者提供在Sei上创建简单、安全、可扩展dApps的实践指导经验，并加速DeFi项目的发展。</p>
<p><strong>Alpha Incubate Batch 2</strong> is a 12-week DeFi-focused program that provides guidance, resources and support to innovative startups. We analyze each project 1 by 1 to find their areas of need and pair them with top-tier investors, operators, and founders who provide advice on strategy and the steps that incubatees should take to get to their milestones and move from 0 to 1 through the program. In short, successful candidates will receive personalized actionable steps specific to their sector and stage. These bespoke mentorships will be led by mentors from the <strong>Alpha Network</strong>, such as investors and operators from <strong>The Spartan Group, Nansen, 1Kx, Parafi Capital,</strong> and many others, including <strong>Sei</strong>.</p>
<p><strong>Alpha Incubate Batch 2</strong>是一个为期12周，以DeFi为重点的项目，给予创新创业公司指导、资源和支持。我们对每个项目进行逐一分析，找到其需求领域，并将他们与顶级投资者、运营商和创始人配对，由他们提供战略建议和被孵化者的未来行动，进而助力其达到里程碑，并通过该项目从0到1。简而言之，成功的候选人将收到针对其行业和阶段的个性化可实操指导。这些定制的指导将由来自<strong>Alpha网络的导师领导，例如来自</strong>斯巴达集团、南森、1Kx、Parafi资本<strong>和许多其他公司的投资者和经营者，包括</strong>Sei。</p>
<p>Sei has one of the most well-rounded ecosystems fully equipped to support DeFi projects to success.  The chain emphasizes reliability, security and high throughput above all else, enabling an entirely new echelon of ultra-high performance DeFi products built on top. By exploring the new design space in between app-chains and general purpose Layer 1's, Sei has carefully selected for a unique set of tradeoffs that make its Layer 1 the optimal environment for DEXs. In this program, projects will have the opportunity to get personalized mentorship from Sei and tap into a community of industry experts that will help them raise funds from top-tier investors hand-selected by Alpha Venture DAO after the Demo Day. Moreover, startups will also be fast tracked to be considered for grants from Sei, receive marketing support, and many more perks that builders can leverage. With the addition of Sei to our ecosystem, we hope to incubate the next generation of disruptive DeFi innovations that raise the standard for all DeFi projects, and move towards mass-adoption.</p>
<p>Sei拥有最全面的生态系统之一，完全有能力支持DeFi项目取得成功。Sei链强调可靠性、安全性和高吞吐量，使建立在上面的超高性能DeFi产品形成了一个全新的梯队。通过探索介于应用链和通用layer1之间的新设计空间，Sei已经精心选择了一套独特的折衷方案，使其layer1成为DEX的最佳环境。在这批孵化中，参与的项目将有机会得到Sei的个性化指导，并进入一个行业专家社区，帮助他们在演示日之后从Alpha Venture DAO精心挑选的顶级投资者那里筹集资金。此外，初创企业还将被快速考虑获得Sei的资助，获得营销支持，以及更多建设者可以利用的福利。随着Sei加入我们的生态系统，我们希望孵化下一代颠覆性的DeFi创新，提高所有DeFi项目的标准，并朝着大规模普及的方向发展。</p>
<p>The application window is now open until <strong>November 27, 2022 at 11:59pm UTC.</strong> Builders can apply <a href="https://www.globenewswire.com/Tracker?data=E2Osx27KvG8nMdskMAYYT1BJBamM--APtD6c4ZFSYH_X_DgWiBGMC5rWA3nQZUJ8Q9t9UEn7XG27m1l-OvgXtQ==">here</a> to join the Alpha Incubate Batch 2 program.</p>
<p>申请窗口现在开放，直到2022年11月27日11:59pm UTC。**建设者可以申请<a href="https://www.globenewswire.com/Tracker?data=E2Osx27KvG8nMdskMAYYT1BJBamM--APtD6c4ZFSYH_X_DgWiBGMC5rWA3nQZUJ8Q9t9UEn7XG27m1l-OvgXtQ==">这里</a>加入Alpha孵化器第二批项目。</p>
<p><em>Any questions regarding the application process can be directed to <a href="https://www.globenewswire.com/Tracker?data=zHKtHbT12Ubg3VrSoR7_odM8iyClz90d6iiN-KegNk3ub_LNBVFYqoV_dC9nX0Xn_-LTGSZEm1kUgTMv3FcFEkGofgvxR44-4lLpc7XRFuuZkyOkl3Xe77WimLdIEP43">here</a>.<br>
任何关于申请过程的问题都可以直接联系<a href="https://www.globenewswire.com/Tracker?data=zHKtHbT12Ubg3VrSoR7_odM8iyClz90d6iiN-KegNk3ub_LNBVFYqoV_dC9nX0Xn_-LTGSZEm1kUgTMv3FcFEkGofgvxR44-4lLpc7XRFuuZkyOkl3Xe77WimLdIEP43">这里</a>。</em></p>
<p>&quot;We are confident that our partnership with Sei will bring immense value to Web 3.0 builders through the Alpha Incubate Batch 2,” said Tascha Punyaneramitdee, Project Lead and Co-founder of Alpha Venture DAO. “Given Sei is one of the most user-friendly layer-1 blockchains that also provides tools and tutorials to help builders easily onboard and get started, and especially with the direct mentorship from Sei through the Alpha Incubate program that is tailored for each of our incubatees, this will definitely accelerate the growth of DeFi projects that are of high-quality.”</p>
<p>&quot;我们相信，我们与Sei的合作将通过Alpha Incubate Batch 2为Web 3.0建设者带来巨大的价值，&quot;Alpha Venture DAO的项目负责人和联合创始人Tascha Punyaneramitdee说。&quot;鉴于Sei是最方便用户的layer1区块链之一，还提供工具和教程，帮助建设者轻松上手，尤其是通过Alpha Incubate项目，Sei为我们每个孵化者量身定做的直接指导，这肯定会加速高质量的DeFi项目的发展。&quot;</p>
<p>“We are thrilled to join the most competitive incubation program through our partnership with Alpha Venture DAO, helping to accelerate Web 3.0 startups exploring the rapidly growing DeFi design space,” said Dan Edlebeck, Head of Ecosystem at Sei. “Alpha Incubate Batch 2 will deliver multiple exciting, scalable dApps through this cohort. I'm interested to see which DeFi applications are born and expand the Sei ecosystem leveraging Batch 2 program mentors' expertise, network, and long-term support.”</p>
<p>&quot;我们很高兴通过与Alpha Venture DAO的合作加入最具竞争力的孵化计划，帮助加速Web 3.0初创企业探索快速增长的DeFi设计领域，&quot;Sei公司生态系统主管Dan Edlebeck说。&quot;Alpha Incubate Batch 2将通过这批孵化提供多个令人兴奋、可扩展的dApps。我有兴趣看到哪些DeFi应用的诞生，并利用第2批(Batch 2)项目导师的专业知识、网络和长期支持来扩大Sei生态系统。&quot;</p>
<p><strong>关于Alpha Venture DAO (About Alpha Venture DAO)</strong></p>
<p><a href="https://www.globenewswire.com/Tracker?data=b8zfepe181ZtyeY-2vcAlbUrMwDByHLqoU3774qnIjLx28lGvJt-y6U0eW_9Hwtp-8vCgl9xq4k3jUizpCAgGFiCpCBonhl91FnAc1d4NCo=">Alpha Venture DAO</a> is a community-driven venture builder that builds and incubates Web 3.0 decentralized applications (dApp). Alpha Venture DAO is the team behind Alpha Homora, the top leveraged yield farming protocol that was ranked in the Top 10 DeFi protocol. Its vision is to become a multi-chain dApp ecosystem. By being a part of Alpha Venture DAO, anyone can build, contribute, and own Web 3.0 innovation. Builders now have a complete ecosystem to bootstrap their Web 3.0 projects.</p>
<p><a href="https://www.globenewswire.com/Tracker?data=b8zfepe181ZtyeY-2vcAlbUrMwDByHLqoU3774qnIjLx28lGvJt-y6U0eW_9Hwtp-8vCgl9xq4k3jUizpCAgGFiCpCBonhl91FnAc1d4NCo=">Alpha Venture DAO</a>是一个社区驱动的风险构建者，建立和孵化Web 3.0去中心化应用（dApp）。Alpha Venture DAO是Alpha Homora背后的团队，Alpha Homora是顶级的杠杆收益协议，曾被列入Top 10 DeFi协议。它的愿景是成为一个多链dApp生态系统。通过成为Alpha Venture DAO的一部分，任何人都可以建立、贡献和拥有Web 3.0创新。建设者现在有一个完整的生态系统来引导他们的Web 3.0项目。</p>
<p>Website 网站: <a href="https://www.globenewswire.com/Tracker?data=Fc_qTlMjBtPItlJk_BZn2M8I0zhCE4EsSlNppUbSzDuIafQHBdVS8d4QXfejE92mSORE_BhWGOhCMOObA04G_9z_t1YyjjqqVF4B9U6XGO4=">https://alphaventuredao.io/</a></p>
<p>Twitter 推特: <a href="https://www.globenewswire.com/Tracker?data=Fc_qTlMjBtPItlJk_BZn2FrjeM8HAk3Wo4FTRPnOSZT9MRrBftRs6zPBvLpGX827yhVDfMbieN7IGN3NPi62I91MoABUsKRjU16eGTYTQgDZHu5X9fTy-h90mrPeMjL6">https://twitter.com/alphaventuredao</a></p>
<p><strong>关于Sei (About Sei)</strong></p>
<p><a href="https://www.globenewswire.com/Tracker?data=Y-8Un8RH5mFnkKszqYslY6PIVrSCqoODNgmiHPATJISGpUxOXyQyHg285vdYOiPasBsALorE2VpjOrOVRWUJBQ==">Sei</a> serves as plumbing for the future financial system - infrastructure to support capital markets, starting with exchanges. As the first Layer 1 specialized for trading, Sei is the fastest chain to finality, optimizing every layer of its stack to give exchanges an unfair advantage. Exchanges are the killer app of crypto, but current Layer 1s hold them back. Most L1s fall into two extremes, general purpose and app-specific. Sei unlocks a new design space in between as a sector-specific L1. There are currently 60+ teams from Solana, Polkadot, Terra, and NEAR building on top of Sei going into mainnet launch. Sei is backed by Multicoin, Delphi, Tangent, and several MMs like Hudson River Trading, GSR.</p>
<p><a href="https://www.globenewswire.com/Tracker?data=Y-8Un8RH5mFnkKszqYslY6PIVrSCqoODNgmiHPATJISGpUxOXyQyHg285vdYOiPasBsALorE2VpjOrOVRWUJBQ==">Sei</a>作为未来金融系统的管道--支持资本市场的基础设施，从交易所开始。作为第一个专门用于交易的layer1，Sei是实现终态最快的链条，优化其技术栈的每一层，使交易所具有无可比拟的优势。交易所是加密货币的杀手级应用，但目前的layer1却阻碍了其发展。大多数L1属于两个极端，即通用型和特定应用型。Sei作为特定场景的L1，在两者之间解锁了一个新的设计空间。目前有60多个来自Solana、Polkadot、Terra和NEAR的团队在Sei的基础上进行建设，准备进入主网发布。Sei得到了Multicoin、Delphi、Tangent和几个MM的支持，如Hudson River Trading、GSR。</p>
<p>Follow Sei 关注Sei: <a href="https://www.globenewswire.com/Tracker?data=gJV1aps37SgJXrYurIhxNFLNIzjD7uwlWlWi7904kMBwDRWJ_IPig4-covnDFjykmv0MqykIoFPGzQQollUtgA==">Twitter</a> | <a href="https://www.globenewswire.com/Tracker?data=8NshhCUvF7cs4fWULYbggxVffsazGYDW1kd_umJSRI-yJqZqUFZCY845mn0zQ8HVEuUkTEeFQz4A9FTE0qBzyA==">Discord</a> | <a href="https://www.globenewswire.com/Tracker?data=gC7edtvYm2bed_6lTKfcyF4yQrhSt92ssqpESw6Dw3sz9OL6cp4R3-DUa209J4_jW-BQkRqVLfYn36-PExAeZQ==">Telegram</a> | <a href="https://www.globenewswire.com/Tracker?data=c5Z9k80VYenqHkiocr46Eyd55foNuU7j1urr2KSsZqR3S91fgZITgml7_03m0NwGshqrBs9XgklklcKduSHZJw==">Website</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[试播回顾!Alt View 欢迎来自以太坊基金会的 Barnabé Monnot, 看看我们都聊了什么? (Pilot recap! Alt View welcomed Barnabé Monnot from the Ethereum Foundation and here’s everything we chatted about)]]></title>
        <id>https://chainguys.github.io/post/shi-bo-hui-gu-alt-view-huan-ying-lai-zi-yi-tai-fang-ji-jin-hui-de-barnabe-monnot-kan-kan-wo-men-du-liao-liao-shi-me-pilot-recap-alt-view-welcomed-barnabe-monnot-from-the-ethereum-foundation-and-heres-everything-we-chatted-about/</id>
        <link href="https://chainguys.github.io/post/shi-bo-hui-gu-alt-view-huan-ying-lai-zi-yi-tai-fang-ji-jin-hui-de-barnabe-monnot-kan-kan-wo-men-du-liao-liao-shi-me-pilot-recap-alt-view-welcomed-barnabe-monnot-from-the-ethereum-foundation-and-heres-everything-we-chatted-about/">
        </link>
        <updated>2022-11-01T11:55:19.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/1*49kLlkhgxO0PF8EKRajiQA.png" alt="" loading="lazy"></figure>
<p>We kick off our Youtube show Alternative View or ‘Alt View’ this week! A no fuss, knowledge-focussed content channel for all things crypto, blockchain, L2s, scalability, Web3 and more, we will be hosting numerous industry leaders and researchers who are at the top of their game. For our pilot episode, we were honoured to have <a href="https://barnabemonnot.com/">Barnabé Monnot</a> from the Robust Incentives Group (RIG), Ethereum Foundation. His research expertise spans game theory, like large systems, crypto economics, and also decentralised systems. Here’s a quick summary on what he had to say on the subject of rollups, PBS, MEV, and the general state of L2s today.</p>
<p>我们本周开始了 Youtube 节目 Alternative View 或“Alt View”！对于加密、区块链、L2、扩容、Web3 等所有事物，我们将提供一个简单、以知识为中心的内容频道，我们将接待众多处于行业领先地位的行业领导者和研究人员。至于试播集，我们很荣幸邀请到来自以太坊基金会稳健激励小组 (RIG) 的 <a href="https://barnabemonnot.com/">Barnabé Monnot</a>。他的研究专长涵盖博弈论，如大型系统、加密经济学以及去中心化系统。以下是关于他在以下内容的快速总结：对汇总、PBS、MEV 和今天 L2 一般状态不得不说的话。</p>
<p>Catch the <a href="https://www.youtube.com/watch?v=viJqYMi6DMo">full episode</a> on our Youtube channel. Don’t forget to hit Subscribe!</p>
<p>我们的 Youtube 频道上可以观看 <a href="https://www.youtube.com/watch?v=viJqYMi6DMo">完整剧集</a>。不要忘记点击订阅！</p>
<p><strong>Summary</strong><br>
总结</p>
<ul>
<li>
<p><a href="https://barnabemonnot.com/">Barnabé</a> first touched upon proposal builder separation (PBS), a design philosophy for protocol. The idea behind it is that in block construction (<em>the roles that validators today have in the system of making blocks</em>) there are specialised aspects, which can potentially be done by people rather than the validators themselves.<br>
<a href="https://barnabemonnot.com/">Barnabé</a> 首先谈到了提案构建器分离 (PBS)，这是一种协议的设计理念。其背后的想法是，在区块构建中（<em>如今验证者在制作区块的系统中所扮演的角色</em>）有一些专门的方面，这些方面可能由(众)人而不是验证者自己来完成。</p>
</li>
<li>
<p>He explained: “<em>We can outsource bouts of block construction to players or to entities that are not necessarily part of the protocol. And the rationale behind the scenes, but do you have these filter things that intervene in block construction, you always ensure that block verification, so the fact that the data, so even full nodes that are not participating in the consensus, they are still able to verify the work. Verification remains cheap</em>.” Specialised parts of block construction are done by actors who have maybe better resources or better knowledge of how to do it.<br>
他解释说：“<em>我们可以将区块构建外包给玩家或不一定是协议一部分的实体。幕后的道理，是你有没有这些过滤器介入区块构建的东西，(如果)你总是确保区块验证，所以数据的事实(是)，即使是不参与共识的全节点，他们仍然能够来验证工作。验证仍然很便宜</em>。”区块构建的专门部分由可能拥有更好资源或更了解如何操作的参与者完成。</p>
</li>
<li>
<p>There are many ways to formalise PBS. Question is, what is the best way to do it? Most of PBS is done out of protocols. But when you see that the protocol starts depending so heavily on a third party network, but the protocol doesn’t necessarily have a view into it, there should be considerations about whether some of it can be brought back into the protocol. However, one must exercise caution before bringing too much into the protocol first as making changes to a protocol can be complicated.<br>
有很多方法可以使 PBS 形式化。问题是，最好的方法是什么？大部分 PBS 都是在协议之外完成的。但是当你看到协议开始严重依赖第三方网络，但协议不一定对其有态度时，应该考虑是否可以将其中的一部分带回协议中。但是，在对协议进行过多更改之前，必须谨慎行事，因为对协议进行更改可能会很复杂。</p>
</li>
<li>
<p><strong><em>MEV (Maximal extractable value) and PBS:</em></strong> Our guest stated that MEV is a deep reason why we are getting to PBS in a more formalised way. He explained: “MEV is when you send a transaction, as a user, sometimes your transaction exposes more value that can be captured. For instance, if you do a trade, there might be a possible arbitrage after your trade. And so people will see your transaction, they really want to be the next transaction, so that they can capture that arbitrage. And so to to extract any value, you need, kind of two things you need first, knowledge, so information that this is a strategy that I can deploy and capture the value. And the second thing, which is I would say, not necessary, but it’s kind of ultimate power is to be the proposer.” The power really lies in the hands of the proposer.<br>
<em><strong>MEV（最大可提取值）和 PBS</strong></em>  我们的客人表示，MEV 是我们以更正式方式进入 PBS 的深层原因。他解释说：“MEV 是当您发送交易时，作为用户，有时您的交易会暴露更多可捕获的价值(被别人截胡)。例如，如果您进行(可能存在套利)的交易，别人会看到你的交易，那他们真的很想成为下一笔交易，这样就可以抓住套利。因此，要提取任何价值，您首先需要两件事，即知识，这是我可以部署和获取价值的策略的信息。第二件事，我会说，没有必要，但它是一种终极权力，就是成为提议者/提案人。”权力真正掌握在提议者的手中。</p>
</li>
<li>
<p><strong><em>Outsourcing for a fairer market?</em></strong> <a href="https://barnabemonnot.com/">Barnabé</a> noted that PBS might have a positive impact, if you are able to outsource and provide a fair market for everyone, when everybody kind of has the same return, there is no economies of scale. But you have to be very sophisticated to be a good builder, However, a common problem within this is the principal-agent problem — the idea that you’re outsourcing things to someone, that person might not share the same value function, as you’re saying, we might not want to make the block the way you would have made. So both good because you get more, but also bad because your preferences as a proposer might not be shared by the builder. One has to make a trade off between providing censorship resistance to the network and getting the best value block.<br>
<em><strong>为更公平的市场而外包？</strong></em> <a href="https://barnabemonnot.com/">Barnabé</a> 指出，如果能够外包并为每个人提供公平的市场，当每个人收益率都差别不大，没有规模经济时，PBS 可能会产生积极影响的收益。但是您必须非常成熟才能成为一名优秀的建设者，其中的一个常见问题是委托代理问题-您将事物外包给某人的想法，该人可能与您共享相同的价值函数，意思是，我们可能不想按照您的方式生成区块。因此，这既是好事，因为你得到了更多，但也不好，因为你作为提议者的偏好可能不会被建造者分享。人们必须在为网络提供审查阻力和获得最佳价值区块之间做出权衡。</p>
</li>
<li>
<p><strong><em>Let’s talk rollups! Where is there value in using rollups?</em></strong> When you could get savings in rollups, this motivates the end users to transact and use the solutions more. In terms of value inflow, one must understand how rollups derive economic value before they use it in their operations. Roll up operators need to pay for their full nodes, <em>or</em> they need to pay for when they have to make proofs. Basically, there are many ways value can get distributed through the chain pipeline.<br>
<strong><em>让我们谈谈汇总！使用汇总有什么价值？</em></strong> 当您可以在使用汇总时获得储蓄，这会激励最终用户进行交易并更多地使用解决方案。在价值流入方面，必须了解，汇总如何在将其用于运营之前获得经济价值。 R汇总运营商需要为他们的完整节点付费，或者他们需要在必须制作证明时付费。基本上，价值可以通过多种方式通过链式管道进行分配。</p>
</li>
<li>
<p><strong>Where are L2 scaling solutions at right now?</strong> According to <a href="https://barnabemonnot.com/">Barnabé</a>, we’re not exactly where we thought we would be maybe a year ago. There’s definitely been a lot more adoption for rollups than previously. Perhaps we had higher expectations of where the market would be. For instance, during the development cycles that went into making the merge happen, which is like a very complicated update. In reality it takes a lot longer to get things into production, especially elements that involve a huge piece of engineering. This is clear for instance when you see Bedrock for Optimism, Nitro for Arbitrum, which differentiate from each other and address different parts of the market and not just the EVM. But it will come to fruition eventually, even if a little later than expected.<br>
<strong>目前 L2 扩展解决方案在哪里？</strong> 根据 <a href="https://barnabemonnot.com/">Barnabé</a> 的说法，我们可能并不与一年前的预期完全一致。与以前相比，汇总的采用肯定要多得多。也许我们对市场的位置有更高的期望。例如，在进行合并的开发周期中，这就像一个非常复杂的更新。实际上，将产品投入生产需要更长的时间，尤其是涉及大量工程的元素。例如，当您看到 Optimism 的 Bedrock 和 Arbitrum 的 Nitro 时，这一点就很清楚，它们相互区分并针对市场的不同部分，而不仅仅是 EVM。但它最终会实现，即使比预期晚一点。</p>
</li>
<li>
<p><a href="https://barnabemonnot.com/"><strong>Barnabé</strong></a><strong>’s Advice to Listeners:</strong> He says imposter syndrome is real and never goes away. Don’t let that keep you from building and innovating and learning in this space! Don’t feel scared and try to find something that speaks to you. There’s a lot of things that nobody really understands, or even knows about. So. So generally, people are just kind of happy to talk about it. So ask questions, and to try and make sense of it. Together.<br>
<a href="https://barnabemonnot.com/"><strong>Barnabé</strong></a> <strong>对听众的忠告：</strong> 他说冒充者综合征(译者注：冒充者综合症Impostor syndrome，又称自我能力否定倾向，是指个体按照客观标准评价为已经获得了成功或取得成就，但是其本人却认为这是不可能的，他们没有能力取得成功，感觉是在欺骗他人，并且害怕被他人发现此欺骗行为的一种现象-解释来自网络)是真实存在的，并且永远不会消失。不要让这阻止您在这个空间中构建、创新和学习！不要感到害怕，试着找到对你说话的东西。有很多事情没有人真正了解，甚至不知道。所以。所以一般来说，人们只是乐于谈论它。所以提出问题，并尝试理解它。让我一路同行！</p>
</li>
</ul>
<p>Thanks Barnabe for being such a fantastic guest. As mentioned above, please follow our Youtube channel to watch all upcoming episodes (we’ve got some great guests lined up!)</p>
<p>感谢 Barnabe 成为如此出色的客人。如上所述，请关注我们的 Youtube 频道观看所有即将播出的剧集（我们有一些很棒的嘉宾排队！）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模块化执行的案例(第二部分) The Case for Modular Execution (Part 2)]]></title>
        <id>https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-er-bu-fen-the-case-for-modular-execution-part-2/</id>
        <link href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-er-bu-fen-the-case-for-modular-execution-part-2/">
        </link>
        <updated>2022-10-27T05:32:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/10/BlogPost3-V1.png" alt="The Case for Modular Execution (Part 2)" loading="lazy"></figure>
<p>How modular execution layers can achieve scalability by optimizing for efficient computation.<br>
模块化执行层如何通过优化高效计算，来实现可扩展性。</p>
<hr>
<h2 id="模块化执行的案例-the-case-for-modular-execution">模块化执行的案例 (The Case for Modular Execution)</h2>
<p>Modular architecture will enable blockchains to <a href="https://fuel-labs.ghost.io/beyond-monolithic-the-modular-blockchain-paradigm/">scale by orders of magnitude</a>. As a core part of the modular stack, execution layers are in a stage of rapid innovation.</p>
<p>模块化架构将使区块链能够<a href="https://fuel-labs.ghost.io/beyond-monolithic-the-modular-blockchain-paradigm/">按数量级扩展</a>。作为模块化技术栈的核心部分，执行层正处于快速创新的阶段。</p>
<p><strong>Fuel is building the fastest execution layer for the modular blockchain stack.</strong> In <a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/">Part 1</a> we explored how modular execution layers enable scalability by decoupling computation from verification.</p>
<p><strong>Fuel 正在为模块化区块链技术栈构建最快的执行层。</strong> 在 <a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">第一部分</a>我们探索了模块化执行层如何通过将计算与验证解耦来实现可扩展性。</p>
<p><a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">模块化执行的案例(第一部分) The Case for Modular Execution (Part 1)</a></p>
<figure data-type="image" tabindex="2"><img src="https://fuel-labs.ghost.io/content/images/2022/10/the-case-for-modular-execution-part-1.png" alt="" loading="lazy"></figure>
<p>We also touched on a second core benefit which enables modular execution layers to scale by orders of magnitude more than their monolithic counterparts:</p>
<p>我们还谈到了第二个核心优势，它使模块化执行层能够比其单片执行层扩展几个数量级：</p>
<blockquote>
<p><em><strong>Monolithic chains are locked into inefficient technologies when it comes to the speed and variety of computation they can support. On the other hand, modular execution layers can be specifically designed to optimize for efficient computation.</strong></em></p>
<p><em><strong>单片链在它们可以支持的计算速度和多样性方面被锁定在低效的技术中。另一方面，模块化执行层可以专门设计用于优化高效计算。</strong></em></p>
</blockquote>
<p>This post explores this second core benefit, with a specific focus on how Fuel is revolutionizing the way blockchains handle computation.</p>
<p>这篇文章探讨了第二个核心优势，特别关注 Fuel 如何彻底改变区块链处理计算的方式。</p>
<hr>
<h2 id="单片链layer1迭代的挑战-monolithic-chains-the-challenge-of-iterating-on-layer-1s">单片链：Layer1迭代的挑战 (Monolithic Chains: The Challenge of Iterating on Layer-1s)</h2>
<p><em>Monolithic chains are locked into inefficient technologies when it comes to the speed and variety of computation they can support.</em></p>
<p><em>单片链在其可以支持的计算速度和多样性方面，被锁定在低效的技术中。</em></p>
<p>When blockchains were first conceived of, there was a single use case in mind: digital cash. The Bitcoin blockchain was designed to optimize for this one narrow use case.</p>
<p>首次构想区块链时，脑海中只有一个用例：数字现金。比特币区块链旨在优化这一狭窄用例。</p>
<p>Soon after the launch of Bitcoin, people started to realize the potential of blockchains for use cases far beyond money. The narrative quickly shifted from “distributed ledger” to “distributed computer”. The Bitcoin community attempted to support this use case through <a href="https://en.wikipedia.org/wiki/Colored_Coins">colored coins</a>, but it was clear that it was not versatile enough to truly support trustless distributed computing; it was locked into its original use case. A new architecture was required.</p>
<p>比特币推出后不久，人们开始意识到区块链远超金钱用例的潜力。叙事迅速从“分布式账本”转变为“分布式计算机”。比特币社区试图通过 <a href="https://en.wikipedia.org/wiki/Colored_Coins">色彩币</a> 来支持这个用例，但很明显它的通用性不足以真正支持去信任分布式计算；它被锁定在其原始用例中。(我们)需要一种新的架构。</p>
<p>Recognizing this problem, the creators of Ethereum set out to build a blockchain which could support a distributed Turing-complete virtual machine: the Ethereum Virtual Machine (EVM). With the launch of Ethereum in 2015, blockchains had evolved to support arbitrary computation in a trustless environment. Now, anyone could build and launch a computer program (smart contract) and have it run on a distributed computer.</p>
<p>认识到这个问题，以太坊的创建者着手构建一个可以支持分布式图灵完备虚拟机的区块链：以太坊虚拟机(EVM)。随着 2015 年以太坊的推出，区块链已经发展到支持去信任环境中的任意计算。现在，任何人都可以构建和启动一个计算机程序(智能合约)并让它在分布式计算机上运行。</p>
<p>Ethereum was conceived of less than half a decade after the concept of blockchains came into existence. In the 7 years since Ethereum launched, new concepts have been invented which represent an even greater leap forward than the progress Ethereum made over Bitcoin. But like Bitcoin, the Ethereum blockchain is mostly locked into the core architecture it launched with.</p>
<p>以太坊是在区块链概念出现后不到五年的时间构思出来的。自以太坊推出以来的 7 年里，人们发明了新概念，这代表了以太坊相对比特币所取得进步的更大飞跃。但就像比特币一样，以太坊区块链大多被锁定在它推出的核心架构中。</p>
<p><em><strong>For every improvement that has been made to the Ethereum blockchain and the EVM over the years, there are many more potential innovations that cannot be implemented due to the need to maintain backward compatibility.</strong></em></p>
<p><em><strong>对于多年来对以太坊区块链和 EVM 所做的每一项改进，由于需要保持向后兼容性，还有许多潜在的创新无法实施。</strong></em></p>
<p>As a result, the blockchain community has continued funding, building, and launching new blockchains every time a new innovation is hatched. Countless new layer-1 blockchains have launched on the promise of iterating on the concept of trustless distributed computing, but they all run into the same challenge: it’s hard (and often impossible) to upgrade blockchains to support new functionalities and improvements.</p>
<p>因此，每次孵化出新创新时，区块链社区都会继续资助、构建和推出新的区块链。无数新的Layer1区块链已经推出，承诺迭代去信任分布式计算的概念，但它们都遇到了同样的挑战：升级区块链来支持新功能和改进是困难的(而且通常是不可能的)。</p>
<p>And so the cycle continues, where we continue to see new blockchains launching with piecemeal improvements over their predecessors. In the process, we are left with an ecosystem of mostly incompatible blockchains, with ever-increasing fragmentation of liquidity, funding, user experience, and developer-mindshare. Meanwhile, the energy that could be spent on true innovation is instead directed toward getting attention from investors, developers, and end-users.</p>
<p>所以这个循环还在继续，我们也继续看到新区块链推出，对它们的前辈进行零碎的改进。在这个过程中，我们留下了一个由大部分不兼容的区块链组成的生态系统，流动性、资金、用户体验和开发者的思想份额越来越分散。与此同时，可以花在真正创新上的精力反而被用于吸引投资者、开发商和最终用户的关注。</p>
<p>Competition is healthy and necessary for a thriving ecosystem. But this competition is happening at the wrong level.</p>
<p>竞争对于繁荣的生态系统是健康的和必要的。但这场竞争发生在错误的层面。</p>
<p><strong>The modular blockchain paradigm promises to solve this problem.</strong> Because each layer in the modular stack is independent of the others, innovation can happen on one layer without a complete overhaul of the entire stack. Execution layers can compete on execution. Data availability layers can compete on data availability. Every layer can optimize for its intended purpose without breaking backward compatibility.</p>
<p><strong>模块化区块链范式有望解决这个问题。</strong> 由于模块化技术栈中的每一层都独立于其他层，因此创新可以发生在一个单独层上，而无需对整个技术栈进行彻底检修。执行层可以竞争执行。数据可用性层可以在数据可用性上竞争。每一层都可以针对其预期目的进行优化，而不会破坏向后兼容性。</p>
<p>Shared settlement layers enable liquidity to be pooled in one place, so new execution layers can be built without fragmenting liquidity or adding friction to the end-user experience. Natively enabled trust-minimized bridging means the community can reduce the resources spent on interoperability efforts and instead focus them on exploring meaningful innovations.</p>
<p>共享结算层可以将流动性集中在一个地方，因此可以构建新的执行层，而不会分散流动性或增加最终用户体验的摩擦。原生支持的信任最小化桥接意味着社区可以减少在交互性工作上花费的资源，而是将它们集中在探索有意义的创新上。</p>
<p>With the advent of the modular stack, we can move away from a disparate ecosystem of L1s competing on vanity metrics, and toward a more cohesive, interoperable, upgradeable stack.</p>
<p>随着模块化技术栈的出现，我们可以摆脱在虚荣指标上竞争的不同的 L1 生态系统，而转向更具凝聚力、可交互、可升级的技术栈。</p>
<hr>
<h2 id="模块化执行超越-evm-modular-execution-moving-beyond-the-evm">模块化执行：超越 EVM (Modular Execution: Moving Beyond the EVM)</h2>
<p>Despite the plethora of layer-1 blockchains promising improvements over the EVM's original design, its first-mover advantage enabled the EVM to gain a foothold as the &quot;default&quot; runtime environment in the blockchain ecosystem. Smart contract development became synonymous with Solidity (the EVM's programming language), which has captured the majority of would-be blockchain developers. Because of this, most execution layers currently under development are EVM-based rollups.</p>
<p>尽管有过多的Layer1区块链有望对 EVM 的原始设计进行改进，但其先发优势使 EVM 作为区块链生态系统中的“默认”运行时环境获得了立足点。智能合约开发成为 Solidity(EVM 的编程语言)的代名词，它吸引了大多数潜在的区块链开发人员。因此，目前正在开发的大多数执行层都是基于 EVM 的汇总。</p>
<p>There is a good reason for this: using the EVM enables rollups to tap into a market of existing applications written in Solidity, as well as a large cohort of end-users who are already familiar with those applications. The EVM is a great tool for seeding a new ecosystem, as it already has such a large share of the developer market.</p>
<p>这有一个很好的理由：使用 EVM 使汇总能够进入使用 Solidity 编写的现有应用程序的市场，以及已经熟悉这些应用程序的大量最终用户。 EVM 是播种新生态系统的绝佳工具，因为它已经在开发者市场占有如此大的份额。</p>
<p>However, as we already explored, the need to maintain backward compatibility means that the EVM has been unable to adopt many innovations. In addition, the core design of the EVM is optimized for a monolithic chain, not a modular stack.</p>
<p>然而，正如我们已经探讨过的，保持向后兼容性的需要意味着 EVM 无法采用许多创新。此外，EVM 的核心设计针对单片链而非模块化技术栈进行了优化。</p>
<p><strong>Just some limitations of the EVM include:</strong><br>
<strong>EVM 的一些限制包括：</strong></p>
<ul>
<li>
<p><strong>Sequential Execution</strong> - The EVM does not support parallel transaction execution, making it much less computationally efficient than other VM designs.<br>
<strong>顺序执行</strong> - EVM 不支持并行交易执行，使其计算效率低于其他 VM 设计。</p>
</li>
<li>
<p><strong>Fraud Proofs</strong> - Ethereum’s account-based model means generating and executing fraud proofs on EVM chains is extremely costly and inefficient, making it sub-optimal for modular execution layers.<br>
<strong>欺诈证明</strong> - 以太坊基于账户的模型意味着在 EVM 链上生成和执行欺诈证明的成本极高且效率低下，因此对于模块化执行层来说并非最优。</p>
</li>
<li>
<p><strong>Solidity</strong> - The most popular programming language for the EVM, Solidity, is notorious for providing a poor developer experience, and is designed in a way that makes it difficult to write secure smart contracts.<br>
<strong>Solidity</strong> - EVM 最流行的编程语言 Solidity 因提供糟糕的开发者体验而声名狼藉，并且其设计方式使得编写安全的智能合约变得困难.</p>
</li>
</ul>
<hr>
<h2 id="fuel优化的模块化执行-fuel-optimized-for-modular-execution">Fuel：优化的模块化执行 (Fuel: Optimized for Modular Execution)</h2>
<p>The advent of modularism means that execution layers can leverage Ethereum’s liquidity and security without being restricted by the limitations of the EVM.</p>
<p>模块化的出现意味着执行层可以利用以太坊的流动性和安全性，而不受 EVM 的限制。</p>
<figure data-type="image" tabindex="3"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-23.png" alt="" loading="lazy"></figure>
<p>By adopting new and improved VM design principles, modular execution layers can specifically optimize for efficient &amp; scalable computation, superior developer experience, and maximum security.</p>
<p>通过采用全新和改进的 VM 设计原则，模块化执行层可以专门针对高效和可扩展计算、卓越的开发者体验和最大的安全性进行优化。</p>
<p>Fuel is taking advantage of this new design space to build <a href="https://www.fuel.network/">the fastest modular execution layer</a>.</p>
<p>Fuel 正在利用这个新的设计空间来构建 <a href="https://www.fuel.network/">最快的模块化执行层</a>。</p>
<h3 id="fuel虚拟机-fuelvm">Fuel虚拟机 (FuelVM)</h3>
<p>One of the core innovations of Fuel is a <strong>completely new virtual machine, the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a></strong>. The advent of execution layers built on Ethereum presents a new opportunity to improve on past VM designs, unconstrained by the need to be backward compatible.</p>
<p>Fuel 的核心创新之一是<strong>全新的虚拟机，<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a></strong>。基于以太坊构建的执行层的出现，为改进过去的 VM 设计提供了新的机会，不受向后兼容需求的限制。</p>
<p>While the EVM’s slow transaction execution may have been sufficient in a pre-modular world where bandwidth was the core bottleneck, improvements made within the new modular stack (including on L1 Ethereum) mean that computational throughput is becoming the primary constraint when it comes to scaling.</p>
<p>虽然在带宽是核心瓶颈的前模块化世界中，EVM 的缓慢交易执行可能已经足够，但在新的模块化技术栈(包括 L1 以太坊)中所做的改进意味着计算吞吐量正在成为扩展时的主要限制.</p>
<p>In anticipation of this new paradigm, <strong>the FuelVM is designed to optimize for fast transaction execution</strong>. Taking learnings from the EVM, Solana, WASM, Bitcoin, and Cosmos, the FuelVM is designed to reduce wasteful processing of traditional blockchain virtual machine architectures, while vastly increasing the potential design space for developers.</p>
<p>出于对这种新范式的预期，<strong>FuelVM 旨在优化快速交易执行</strong>。 FuelVM 借鉴了 EVM、Solana、WASM、比特币和 Cosmos，旨在减少传统区块链虚拟机架构的浪费处理，同时极大地增加开发人员的潜在设计空间。</p>
<p>The FuelVM adopts many innovations that have been suggested and supported by the EVM community, but couldn't be implemented due to the need to maintain backward compatibility. Just a few examples are highlighted below (<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html#eips-implemented-in-fuel">see here for the full list</a>).</p>
<p>FuelVM 采用了许多 EVM 社区已经建议和支持的创新，但由于需要保持向后兼容性而无法实施。下面仅突出显示了几个示例(<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html#eips-implemented-in-fuel">完整列表请参见此处</a>)。</p>
<figure data-type="image" tabindex="4"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-24.png" alt="" loading="lazy"></figure>
<p><em>These are just a few examples of EIPs which were ultimately rejected for the EVM due to backward compatibility issues, but have been implemented in Fuel (source:</em> <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html#eips-implemented-in-fuel"><em>Fuel</em></a><em>)</em><br>
<em>这些只是 EIP 的几个示例，由于向后兼容性问题最终被 EVM 拒绝，但已在 Fuel 中实现(来源：</em> [<em>Fuel</em>](https://fuellabs.github.io/fuel-docs/master /vs-evm.html#eips-implemented-in-fuel)<em>)</em></p>
<h3 id="用sway和force实现的高级devex-superior-devex-with-sway-and-forc">用Sway和Force实现的高级DevEx (Superior DevEx with Sway and Forc)</h3>
<p>The Fuel protocol was designed with developer experience at the forefront. <strong>The FuelVM has been built alongside its companion language, <a href="https://fuellabs.github.io/fuel-docs/master/sway-language.html">Sway</a></strong>: a Rust-based domain-specific language designed specifically to leverage a blockchain VM. Unlike Solidity, which was developed after the creation of the EVM, Sway has been created from the ground up to have convenient and efficient ops built-in. By basing Sway on Rust, Fuel makes smart contract development safer and more performant through the use of strong static analysis and compiler feedback.</p>
<p>Fuel 协议的设计凝结最前沿的开发人员经验。 <strong>FuelVM 是与它的配套语言 <a href="https://fuellabs.github.io/fuel-docs/master/sway-language.html">Sway</a> 一起构建的</strong>：一种基于 Rust 设计的特定领域语言，专门来使用区块链虚拟机。与在创建 EVM 之后开发的 Solidity 不同，Sway 是从头开始创建的，内置了方便高效的操作。通过基于 Rust 的 Sway，Fuel 通过使用强大的静态分析和编译器反馈使智能合约开发更安全、更高效。</p>
<p>From a tooling perspective, <strong>Fuel improves on the EVM ecosystem with the <a href="https://fuellabs.github.io/fuel-docs/master/fuel-toolchain.html">Forc toolchain</a></strong>. With Forc, developers can get everything they need to start creating Sway applications for the Fuel VM with a single toolchain. Fuel takes a curated, &quot;batteries-included&quot;-yet-modular approach to providing tooling, with a comprehensive, standardized, canonical set of tools that covers not only the lower levels of the stack (like protocol and VM implementations), but also the higher levels (such as package management, editor support, common-use plugins, and much more).</p>
<p>从工具的角度来看，<strong>Fuel 通过 <a href="https://fuellabs.github.io/fuel-docs/master/fuel-toolchain.html">Forc 工具链</a></strong> 改进了 EVM 生态系统。借助 Forc，开发人员可以使用单个工具链获得开始为 Fuel VM 创建 Sway 应用所需的一切。 Fuel 采用精心策划的“包含电池”但模块化的方法来提供工具，具有全面、标准化、规范的工具集，不仅涵盖技术栈的较低级别(如协议和 VM 实现)，也包括更高级别(例如包管理、编辑器支持、常用插件等等)。</p>
<p>Fuel’s developer environment retains the benefits of smart contract languages like Solidity while adopting the paradigms introduced in the Rust tooling ecosystem, making the learning curve for Sway easily manageable for all levels of developer experience.</p>
<p>Fuel 的开发人员环境保留了 Solidity 等智能合约语言的优势，同时采用了 Rust 工具生态系统中引入的范式，使 Sway 的学习曲线易于管理，适合所有级别的开发人员体验。</p>
<h3 id="并行交易执行-parallel-transaction-execution">并行交易执行 (Parallel Transaction Execution)</h3>
<p>The ability to execute transactions in parallel is a highly desirable property, especially as modern processors become increasingly multi-threaded. As such, it was a core consideration when designing the Fuel protocol.</p>
<p>并行执行交易的能力是一个非常理想的属性，尤其是在现代处理器变得越来越多线程的情况下。因此，这是设计 Fuel 协议时的核心考虑因素。</p>
<p>Parallel transaction execution requires the ability to determine and handle <a href="https://en.wikipedia.org/wiki/Parallel_computing#Dependencies">dependencies</a> between transactions. In order to avoid overlap when processing the transactions on separate cores, the shared state that may be touched by each transaction needs to be identified upfront (via “access lists”), so transactions can be partitioned into sets which don’t have any possible interactions with one another.</p>
<p>并行交易执行需要能够确定和处理交易之间的<a href="https://en.wikipedia.org/wiki/Parallel_computing#Dependencies">依赖项</a>。为了避免在不同核上处理交易时发生重叠，需要预先识别每个交易可能涉及的共享状态(通过“访问列表”)，因此可以将交易划分为没有任何可能彼此互动的集合。</p>
<p>Because of the constraints of its account-based design, Ethereum is not able to support these access lists, so is forced to process transactions sequentially (i.e. one after the other). <a href="https://github.com/ethereum/EIPs/issues/648">EIP-648</a> proposed the addition of access lists to Ethereum, but this has never been implemented due to other inefficiencies it would introduce.</p>
<p>因为其基于帐户的设计的限制，以太坊无法支持这些访问列表，因此被迫按顺序处理交易(即一个接一个)。 <a href="https://github.com/ethereum/EIPs/issues/648">EIP-648</a> 提议向以太坊添加访问列表，但由于它会引入其他类型的低效率，所以这从未实施过。</p>
<p>Learning from this limitation, Fuel has implemented <a href="https://fuellabs.github.io/fuel-docs/master/technology/parallel_tx_execution.html#state-access-lists-and-utxos">strict state access lists</a> in the form of a UTXO model, giving it the ability to use multiple CPU threads and cores that are typically idle in single-threaded blockchains. As a result, <strong>Fuel can execute transactions in parallel</strong>, delivering far more compute, state accesses, and transactional throughput than its single-threaded counterparts.</p>
<p>从这个限制中吸取教训，Fuel 实施了形同UTXO 模型的 <a href="https://fuellabs.github.io/fuel-docs/master/technology/parallel_tx_execution.html#state-access-lists-and-utxos">严格的状态访问列表</a> ，使其能够使用通常在单线程区块链中空闲的多个 CPU 线程和内核。因此，**Fuel 可以并行执行交易，提供比单线程更多的计算、状态访问和交易吞吐量。</p>
<figure data-type="image" tabindex="5"><img src="https://lh5.googleusercontent.com/3XJEoCTGhPZl6T44ob4P2bAYrHi-TqggBsNYVCpegu5WSh5upC6kxrAZR6r-ErgSk69TwYmH6ex4hysI4-EoHZGZ1lSdB6-rcdRJpsbbYVipnjNHQPIyZqcvvOwrOfHVaa8pWd-9pHi0pKOwH1lDpDYsrt1K0kFInV7tq51t6ZfpZiBAd7mJC7IOgg" alt="" loading="lazy"></figure>
<p><em>Fuel’s support for parallel transaction execution means validators can maximize efficiency by using all of their hardware (source:</em> <a href="https://fuellabs.github.io/fuel-docs/master/why-fuel.html#parallel-execution"><em>Fuel</em></a><em>)</em><br>
<em>Fuel 对并行交易执行的支持意味着验证者可以通过使用其所有的硬件来最大化效率(来源：</em> <a href="https://fuellabs.github.io/fuel-docs/master/why-fuel.html#parallel-execution"><em>Fuel</em></a><em>)</em></p>
<p>As well as providing efficiency optimizations, <strong>the ability to process multiple transactions in parallel allows for security improvements</strong>, as it enables transaction throughput to scale without a comparable increase in the resource requirements to verify those transactions. This reduces the barrier for running a full node, leading to a more decentralized network of verifiers.</p>
<p>除了提供效率优化外，<strong>并行处理多个交易的能力还可以提高安全性</strong>，因为它可以扩展交易吞吐量，而不会增加用于验证这些交易的资源需求。这降低了运行完整节点的障碍，从而导致验证者网络更加分散。</p>
<h3 id="为欺诈证明而优化-optimized-for-fraud-proofs">为欺诈证明而优化 (Optimized for Fraud Proofs)</h3>
<p>Fraud proofs are a core technology in the modular blockchain stack. In <a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/">Part 1</a>, we explored how modular execution layers can leverage fraud proofs to enable trust-minimized light clients, allowing for security under the assumption that only a single honest full node is available.</p>
<p>欺诈证明是模块化区块链技术栈中的核心技术。在 <a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">第一部分</a> 中，我们探讨了模块化执行层如何利用欺诈证明来启用信任最小化的轻客户端，在只有一个诚实的全节点可用的假设下确保安全性。</p>
<figure data-type="image" tabindex="6"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-25.png" alt="" loading="lazy"></figure>
<p><em>Fraud proofs enable trust-minimized light clients which rely on a single honest minority, giving them much greater security guarantees than monolithic light clients (source:</em> <a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/"><em>Fuel</em></a><em>)</em><br>
<em>欺诈证明使信任最小化的轻客户端依赖于一个诚实的少数，为他们提供比单体轻客户端更大的安全保证(来源：</em> [<em>Fuel</em>](https://fuel-labs.ghost.io/the-case- for-modular-execution-part-1/)<em>)</em></p>
<p>With trust-minimized light clients and shared settlement &amp; data availability layers, it is possible to build trust-minimized bridges between modular execution layers, something which is impossible to achieve between L1s. This allows for the experimentation with and deployment of new blockchain designs without fragmenting security or liquidity.</p>
<p>通过信任最小化的轻客户端和共享结算和数据可用性层，可以在模块化执行层之间建立信任最小化的桥接，这是 L1 之间无法实现的。这允许在不破坏安全性或流动性的情况下试验和部署新的区块链设计。</p>
<p>Because of the benefits fraud proofs provide, <strong>Fuel was designed and built specifically to be fraud-provable</strong> in a low-cost, efficient manner.</p>
<p>由于欺诈证明提供的好处，<strong>Fuel 被设计和产出专门的低成本和高效的方式证明欺诈</strong>。</p>
<p>Whereas Ethereum’s account-based model means that the cost of constructing fraud proofs for it is unbound, Fuel optimizes for fraud proofs by using the UTXO model. <a href="https://fuellabs.github.io/fuel-docs/master/technology/fraud_proofs.html">UTXO fraud proofs</a> achieve efficiency by simply requiring each spend of a UTXO to &quot;point&quot; to the creation of the UTXO, without having to refer to a global state tree. Proving that either a) the pointer is invalid, or b) whatever is being pointed to doesn't match whatever is being spent, is sufficient for exhaustively proving fraud.</p>
<p>以太坊基于账户的模型意味着为其构建欺诈证明的成本是无限的，而 Fuel 通过使用 UTXO 模型来优化欺诈证明。 <a href="https://fuellabs.github.io/fuel-docs/master/technology/fraud_proofs.html">UTXO 欺诈证明</a> 通过简单地要求 UTXO 的每笔支出“指向”UTXO 的创建来实现效率，无需强制参考全局状态树。证明 a) 指针无效，或 b) 所指向的内容与所花费的内容不匹配，足以彻底证明欺诈。</p>
<p>As an added benefit, the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/instruction_set.md">FuelVM instruction set</a> is designed to be fraud-provable within the EVM. This means Fuel can use Ethereum as a settlement layer, leveraging its deep liquidity and large user base while remaining unconstrained by the limitations of the EVM.</p>
<p>还有一个额外的好处，<a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/instruction_set.md">FuelVM 指令集</a> 被设计在 EVM 中进行欺诈证明。这意味着 Fuel 可以使用以太坊作为结算层，利用其深厚的流动性和庞大的用户群，同时不受 EVM 的限制。</p>
<h3 id="其他益处-other-benefits">其他益处 (Other Benefits)</h3>
<p>On top of the above points, Fuel has implemented a number of other improvements, including:<br>
除了上述几点之外，Fuel 还实施了许多其他改进，包括：</p>
<ul>
<li>Support for multiple native assets  支持多种原生资产</li>
<li>Native account abstraction &amp; predicates  原生支持帐户抽象和谓词</li>
<li>Multi-dimensional resource pricing  本机帐户抽象和谓词</li>
<li>Sequencer decentralization  序列器去中心化</li>
</ul>
<p>An explanation of these improvements is out of scope for this article, but Blockchain Capital provides an excellent <a href="https://medium.com/blockchain-capital-blog/exploring-the-fuelvm-86cf9ccdc159">deep dive into these additional benefits</a>.</p>
<p>对这些改进的解释超出了本文的范围，但 Blockchain Capital 提供了出色报告，告诉大家 <a href="https://chainguys.github.io/post/tan-suo-fuel-xu-ni-ji-fuelvm-exploring-the-fuelvm/">深入了解这些额外好处</a> .</p>
<hr>
<h2 id="结论-summary">结论 (Summary)</h2>
<ul>
<li>
<p>The monolithic paradigm leads to an ecosystem of incompatible L1s competing on vanity metrics, fragmenting liquidity, funding, and developer-mindshare. Fuel adopts the premise that <strong>innovation does not require launching a new L1, but can happen at the execution layer</strong>.<br>
单片范式导致不兼容的 L1 生态系统在虚荣的指标上竞争、分散流动性、资金和开发者的思想份额。 Fuel 采用的前提是<strong>创新不需要启动新的 L1，但可以发生在执行层</strong></p>
</li>
<li>
<p>Modular architecture enables MELs such as Fuel to focus on efficient computation without worrying about backward compatibility. Faster computation not only leads to higher throughput, but also makes running validators more efficient, improving decentralization. This enables Fuel to contribute to Ethereum’s scalability without being held back by the inefficiencies of the EVM.<br>
模块化架构使诸如 Fuel 之类的 MEL 能够专注于高效计算，而无需担心向后兼容性。更快的计算不仅可以带来更高的吞吐量，还可以让运行验证器的效率更高，从而增强去中心化。这使 Fuel 能够为以太坊的扩容做出贡献，而不会因 EVM 的低效而受阻。</p>
</li>
<li>
<p>Execution layers that use the EVM can capitalize on the existing ecosystem of Solidity applications and developers, but fail to make the most of the design space offered by the modular stack. Fuel is leveraging this new design space with the FuelVM, designed from the ground up to be fraud-provable and to provide the best developer experience.<br>
使用 EVM 的执行层可以利用现有的 Solidity 应用和开发人员生态系统，但无法充分利用模块化技术栈提供的设计空间。 Fuel 正在通过 FuelVM 充分利用这一新的设计空间，该设计从一开始就设计为可防欺诈并提供最佳的开发者体验。</p>
</li>
<li>
<p>Fuel introduces innovations that optimize for the rapidly approaching modular future, enabling a new generation of blockchains that go #BeyondMonolithic..<br>
Fuel 引入了针对快速接近的模块化未来进行优化的创新，使新一代区块链成为可能 #超越单片链..</p>
</li>
</ul>
<hr>
<h2 id="敬请关注-follow-us"><strong>敬请关注 (Follow Us)</strong></h2>
<ul>
<li><a href="https://twitter.com/fuellabs_"><strong>Twitter</strong></a></li>
<li><a href="http://discord.com/invite/xfpK4Pe"><strong>Discord</strong></a></li>
<li><a href="https://www.linkedin.com/company/fuel-labs/"><strong>LinkedIn</strong></a></li>
<li><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong>YouTube</strong></a></li>
</ul>
<h2 id="关于我们-about-us"><strong>关于我们 (About Us)</strong></h2>
<p><a href="https://www.fuel.network/">Fuel</a> is the <strong>fastest execution layer</strong> for the modular blockchain stack. Powerful and sleek, the technology enables parallel transaction execution, empowering developers with the <strong>highest flexible throughput</strong> and <strong>maximum security</strong> required to scale. Developers choose the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> for its <strong>superior developer experience</strong> and the ability to go <strong>beyond the limitations of the EVM</strong>.</p>
<p><a href="https://www.fuel.network/">Fuel</a> 是模块化区块链技术栈的<strong>最快执行层</strong>。该技术功能强大且时尚，支持并行交易执行，为开发人员提供了扩展所需的<strong>最高灵活吞吐量</strong>和<strong>最大安全性</strong>。开发人员选择 <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> 是因为它<strong>卓越的开发人员体验和运行能力</strong> ，突破了 EVM 的限制**。</p>
<h2 id="成为贡献者-become-a-contributor"><strong>成为贡献者 (Become a Contributor)</strong></h2>
<ul>
<li>
<p><a href="https://jobs.lever.co/fuellabs">Explore our current job openings</a><br>
<a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></p>
</li>
<li>
<p><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">Apply for a grant</a><br>
<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请资助</a></p>
</li>
<li>
<p><a href="https://fuellabs.github.io/sway/v0.24.5/">Learn Sway</a><br>
<a href="https://fuellabs.github.io/sway/v0.24.5/">学习Sway</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[@fuellabs_长推20221027(@fuellabs_threads20221027)]]></title>
        <id>https://chainguys.github.io/post/fuellabs-chang-tui-20221027fuellabs_threads20221027/</id>
        <link href="https://chainguys.github.io/post/fuellabs-chang-tui-20221027fuellabs_threads20221027/">
        </link>
        <updated>2022-10-27T03:20:40.000Z</updated>
        <content type="html"><![CDATA[<p>原文地址：<a href="https://twitter.com/fuellabs_/status/1585658150396387328">https://twitter.com/fuellabs_/status/1585658150396387328</a></p>
<p>What makes modular execution layers truly groundbreaking? In this series, we cover everything there is to know about modular execution. Including some of the innovative properties that will enable it to scale Ethereum, without compromise.</p>
<p>让模块化执行层真正具有开创性的到底是什么？在本系列中，我们将介绍有关模块化执行的所有知识。包括一些能够毫不妥协地扩容以太坊的创新属性。<br>
（全文见下面链接）</p>
<p><a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-2/">Article P2 here </a><br>
<a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">中文翻译版在此</a></p>
<p>Today, we cover:<br>
今天，我们介绍：</p>
<p>The challenge of iterating on L1s !<br>
在 L1 上迭代的挑战！<br>
Possibilities beyond the EVM !<br>
超越 EVM 的可能性！<br>
Optimizing for modular execution!<br>
优化模块化执行！<br>
Conclusions<br>
结论<br>
Let's go !<br>
我们开始吧</p>
<p>Part one, in case you missed it:<br>
第一部分，以防你错过了：</p>
<p><a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/">Article P1 here</a><br>
<a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-er-bu-fen-the-case-for-modular-execution-part-2/">中文翻译版在此</a></p>
<p>The EVM is a great tool for seeding new ecosystems.<br>
EVM 是播种新生态系统的绝佳工具。</p>
<p>However:<br>
然而：</p>
<ul>
<li>The need to maintain backward compatibility means that the EVM has been unable to adopt many innovations.<br>
保持向后兼容性的需要意味着 EVM 无法采用许多创新。</li>
<li>The core design of the EVM is optimized for a monolithic chain, not a modular stack.<br>
EVM 的核心设计是针对单片链而非模块化技术栈进行优化。</li>
</ul>
<p>This has left us stuck in a loop of incremental monolithic innovation<br>
这让我们陷入了增量式单体创新的循环中</p>
<figure data-type="image" tabindex="1"><a href="https://twitter.com/musalbas/status/1582396496229507072"><img src="https://pbs.twimg.com/media/FfXNOg9VEAEMe1e?format=png&amp;name=small" alt="alt text" loading="lazy"></a></figure>
<p>With the advent of the modular stack, we can move away from a disparate ecosystem of L1s competing on vanity metrics, and toward a more cohesive, interoperable, upgradeable stack.</p>
<p>随着模块化技术栈的出现，我们可以摆脱不同 L1 生态系统在虚荣指标上的竞争，转向更具凝聚力、可交互和可升级的技术栈。</p>
<p><a href="https://twitter.com/fuellabs_/status/1569753111983722496">https://twitter.com/fuellabs_/status/1569753111983722496</a></p>
<p>EVM 之外的可能性 (Possibilities beyond the EVM)</p>
<p>The advent of modularism means that execution layers can leverage Ethereum’s liquidity and security without being restricted by the limitations of the EVM.</p>
<p>模块化的出现意味着执行层可以利用以太坊的流动性和安全性，而不受 EVM 的限制。</p>
<figure data-type="image" tabindex="2"><img src="https://pbs.twimg.com/media/FgFjs21UYAYcAap?format=png&amp;name=medium" alt="" loading="lazy"></figure>
<p>These are just a few examples of EIPs which were ultimately rejected for the EVM due to backward compatibility issues, but have been implemented in Fuel. See the complete list:</p>
<p>这些只是 EIP 的几个示例，由于向后兼容性问题最终被 EVM 拒绝，但已在 Fuel 中实现。查看完整列表：</p>
<p><a href="https://t.co/fwZkuFJrnA">https://fuellabs.github.io/fuel-docs/master/vs-evm.html#eips-implemented-in-fuel…</a></p>
<figure data-type="image" tabindex="3"><img src="https://pbs.twimg.com/media/FgFjtSvUUAEvw-K?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>Fuel is optimized for modular execution<br>
Fuel针对模块化执行进行了优化</p>
<ul>
<li>
<p>Superior DevEx with<a href="https://twitter.com/SwayLang">@SwayLang</a>and Forc<br>
具有 <a href="https://twitter.com/SwayLang">@SwayLang</a> 和 Forc 的高级 DevEx</p>
</li>
<li>
<p>Parallel Transaction Execution<br>
并行事务执行</p>
</li>
<li>
<p>Designed for fraud proofs and light clients<br>
专为防欺诈和轻客户端而设计</p>
</li>
</ul>
<p><a href="https://twitter.com/camiinthisthang/status/1577738478699171845">https://twitter.com/camiinthisthang/status/1577738478699171845</a></p>
<p>Additional benefits of the FuelVM by<a href="https://twitter.com/sproule_">@sproule_</a>of<a href="https://twitter.com/blockchaincap">@blockchaincap</a></p>
<p>FuelVM 的其他好处，可查看 <a href="https://twitter.com/blockchaincap">@blockchaincap</a> 的<a href="https://twitter.com/sproule_">@sproule_</a> 撰写的<a href="https://chainguys.github.io/post/tan-suo-fuel-xu-ni-ji-fuelvm-exploring-the-fuelvm/">报告</a></p>
<p>Conclusions<br>
结论</p>
<ul>
<li>
<p>Innovation does not require launching a new L1, but can happen at the execution layer.<br>
创新不需要启动新的 L1，可以只发生在执行层。</p>
</li>
<li>
<p>EVM-compatible execution layers can capitalize on the existing Solidity ecosystem, but fail to make the most of the design space offered by the modular stack.<br>
EVM 兼容的执行层可以利用现有的 Solidity 生态系统，但无法充分利用模块化技术栈提供的设计空间。</p>
</li>
</ul>
<p>Cont.<br>
序</p>
<ul>
<li>Focusing on efficient computation without worrying about backward compatibility enable MELs to contribute to Ethereum's scalability without being held back by the inefficiencies of the EVM.<br>
专注于高效计算而不担心向后兼容性，使 MEL 能够为以太坊的扩容做出贡献，而不会因 EVM 的低效率而受阻。</li>
</ul>
<p>Learn more about how Fuel, the fastest modular execution layer, unlocks the future of scalability:</p>
<p>详细了解最快的模块化执行层 Fuel 如何开启可扩展性的未来：</p>
<p><a href="https://www.fuel.network/">https://www.fuel.network/</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zpoken 成功在 Neon EVM 上部署 Compound 协议(Zpoken Successfully Deploys the Compound Protocol on Neon EVM)]]></title>
        <id>https://chainguys.github.io/post/zpoken-cheng-gong-zai-neon-evm-shang-bu-shu-compound-xie-yi-zpoken-successfully-deploys-the-compound-protocol-on-neon-evm/</id>
        <link href="https://chainguys.github.io/post/zpoken-cheng-gong-zai-neon-evm-shang-bu-shu-compound-xie-yi-zpoken-successfully-deploys-the-compound-protocol-on-neon-evm/">
        </link>
        <updated>2022-10-21T03:40:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/1*gmc_nXaOC8Reo4m24EF0WA.png" alt="" loading="lazy"></figure>
<hr>
<p>Over the last few months, Neon Labs has partnered with several organizations to test and deploy various protocols and projects on Neon EVM. Neon Labs’ most recent partnership with <a href="https://zpoken.io/">Zpoken</a> has resulted in the successful deployment of the <a href="https://compound.finance/">Compound protocol</a> on Neon EVM. The deployment of Compound on Neon EVM serves to further test the readiness of Neon EVM for production and the onboarding of complex dApps to its ecosystem.</p>
<p>在过去几个月中，Neon Labs 与多家组织合作，在 Neon EVM 上测试和部署各种协议和项目。 Neon Labs 与 Zpoken 的最新合作，就是在 Neon EVM 上成功部署 Compound 协议。在 Neon EVM 上部署 Compound 有助于进一步测试 Neon EVM 的生产准备情况以及复杂 dApp 加入其生态系统的情况。</p>
<p>Compound is a DeFi dApp that first launched in September, 2018 on Ethereum. The protocol allows users to lend and borrow cryptocurrencies without an intermediary</p>
<p>Compound 是一个 DeFi dApp，于 2018 年 9 月在以太坊上首次推出。该协议允许用户在没有中介的情况下借出和借入加密货币。</p>
<h1 id="zpoken是谁-who-is-zpoken">Zpoken是谁? (Who is Zpoken?)</h1>
<p>Zpoken is a full-stack Web3 development firm. The company has shipped more than 50 projects and has 30 active builders across 10+ blockchain networks. Zpoken’s specializations include high-end web3 development, cryptography, capital markets, token design, and liquidity.</p>
<p>Zpoken是一家全栈 Web3 开发公司。该公司已经交付了 50 多个项目，并在 10 多个区块链网络中拥有 30 名活跃的建设者。 Zpoken 的专长包括高端 web3 开发、密码学、资本市场、代币设计和流动性。</p>
<h1 id="我们的目标-our-objective">我们的目标 (Our Objective)</h1>
<p>The main objective of the exercise with Zpoken was to test Neon EVM’s performance and functionality during the deployment of the Compound protocol contracts to <a href="https://proxy.devnet.neonlabs.org/solana">Neon Devnet</a>.</p>
<p>Zpoken练习的主要目的，是在将 Compound 协议合约部署到 Neon Devnet 期间测试 Neon EVM 的性能和功能。</p>
<p>Following the successful deployment, Zpoken conducted unit tests on the protocol. The goal was to ensure the appropriate performance and workflow of the protocol contracts as well as the correctness of the contract calculations and logic.</p>
<p>成功部署后，Zpoken 对该协议进行了单元测试。目标是确保协议合约的适当性能，工作流程以及合约计算和逻辑的正确性。</p>
<h1 id="测试方法-testing-methodology">测试方法 (Testing Methodology)</h1>
<p>Zpoken tested the following smart contract functions to verify the performance of Compound on Neon EVM:</p>
<p>Zpoken测试了以下智能合约函数来验证 Compound 在 Neon EVM 上的性能：</p>
<ul>
<li>
<p>Deploy compound contracts to Neon Devnet network;<br>
将compound合约部署到 Neon Devnet 网络；</p>
</li>
<li>
<p>Test cToken contract functions 测试cToken合约函数:<br>
(constructor, mint, mintFresh, redeem, redeemFreshTokens, redeemFreshAmount, liquidateBorrow, liquidateBorrowFresh, seize, _setComptroller, transfer, balanceOfUnderlying, borrow, borrowRatePerBlock, supplyRatePerBlock, borrowBalanceCurrent, borrowBalanceStored, exchangeRateStored, getCash, borrowFresh, repayBorrowFresh, repayBorrow, repayBorrowBehalf, accrueInterest, _setInterestRateModel, _setInterestRateModelFresh, _setReserveFactor, _setReserveFactorFresh, _reduceReserves, _reduceReservesFresh, admin, pendingAdmin, _setPendingAdmin, _acceptAdmin);</p>
</li>
<li>
<p>Test CEther contract functions   测试 CEther 合约函数:<br>
(getCashPrior, doTransferIn, doTransferOut, mintExplicit, mintFallback, redeemCTokens, redeemUnderlying, borrow, borrowFresh, repayBorrow, repayBorrowFresh, repayBorrowBehalf, addReserves);</p>
</li>
<li>
<p>Test Comptroller contract functions 测试Comptroller合约函数:<br>
(constructor, _setLiquidationIncentive, _setPriceOracle, _setCloseFactor, _setCollateralFactor, _supportMarket, liquidateBorrowAllowed, redeemVerify, liquidateCalculateAmountSeize, _setPauseGuardian, setting paused, liquidity, getAccountLiquidity, getHypotheticalAccountLiquidity, admin, pendingAdmin, _setPendingAdmin, _acceptAdmin);</p>
</li>
<li>
<p>Test CompoundLens contract functions 测试 CompoundLens 合约函数:<br>
(cTokenMetadata, cTokenMetadataAll, cTokenBalances, cTokenBalancesAll, cTokenUnderlyingPrice, cTokenUnderlyingPriceAll, getAccountLimits, governance, comp);</p>
</li>
<li>
<p>Test PriceOracleProxy contract functions 测试 PriceOracleProxy 合约函数:<br>
(constructor, getUnderlyingPrice);</p>
</li>
<li>
<p>Test Timelock contract functions 测试Timelock合约函数:<br>
(constructor, setDelay, setPendingAdmin, acceptAdmin, queueTransaction, cancelTransaction, executeTransaction, executeTransaction, queue and cancel empty);</p>
</li>
<li>
<p>Test InterestRateModel contract functions 测试 InterestRateModel 合约函数:<br>
(baseP025-slopeP20, jump rate tests, baseP05-slopeP45, isInterestRateModel, calculates correct borrow value, jump-rate);</p>
</li>
<li>
<p>Test CCompLikeDelegate contract functions  测试 CCompLikeDelegate 合约函数:<br>
(_delegateCompLikeTo);</p>
</li>
<li>
<p>Test Maximillion contract functions 测试Maximillion合约函数:<br>
(constructor, repayBehalf);</p>
</li>
<li>
<p>Test DAIInterestRateModelV3 contract functions 测试 DAIInterestRateModelV3 合约函数:<br>
(constructor, getBorrowRate, getSupplyRate);</p>
</li>
<li>
<p>Test Flywheel contract functions 测试飞轮合约函数:<br>
(_grantComp, getCompMarkets, _setCompSpeeds, updateCompBorrowIndex, updateCompSupplyIndex, distributeBorrowerComp, distributeSupplierComp, transferComp, claimComp, claimComp batch, harnessRefreshCompSpeeds, harnessSetCompSpeeds, harnessAddCompMarkets, updateContributorRewards, _setContributorCompSpeed).</p>
</li>
</ul>
<h1 id="测试范围-testing-scope">测试范围 (Testing Scope)</h1>
<p>The scope of testing focused on the following deployed contracts:<br>
测试范围集中在以下已部署的合约上：</p>
<figure data-type="image" tabindex="2"><img src="https://miro.medium.com/max/1286/1*NAz_LBdDsp1BTirY_JAwbQ.png" alt="" loading="lazy"></figure>
<h1 id="测试执行-testing-execution">测试执行 (Testing Execution)</h1>
<p>Prior to deployment and testing, Zpoken made two primary changes to the Compound protocol smart contracts:<br>
在部署和测试之前，Zpoken 对 Compound 协议智能合约进行了两项主要更改：</p>
<ul>
<li>
<p>The first change was made to the GRACE_PERIOD and MINIMUM_DELAY constants in <a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Timelock.sol">Timelock.sol</a>. The constants influence time limits for function execution in contracts. The changes were required as the Zpoken team conducted tests on live Neon network nodes and were not able to manipulate time and block numbers.<br>
对 <a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Timelock.sol">Timelock.sol</a> 中的 GRACE_PERIOD 和 MINIMUM_DELAY 常量进行了第一次更改。常量影响合约中函数执行的时间限制。由于 Zpoken 团队在实时 Neon 网络节点上进行了测试，并且无法操纵时间和块数，因此需要进行这些更改。</p>
</li>
<li>
<p>The second change adjusted the address of the external Comp contract in the <a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Comptroller.sol">Comptroller.sol</a> contract (via the function getCompAddress()).<br>
第二个改动调整了<a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Comptroller.sol">Comptroller.sol</a>中外部Comp合约的地址合约(通过函数 getCompAddress())。</p>
</li>
</ul>
<p>Once the contract adjustments were made, the Zpoken team deployed to Neon Devnet from the repository <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a> using the <strong><em>yarn deploy -n neon</em></strong> command.</p>
<p>合约调整完成后，Zpoken 团队从存储库 <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a> 部署到 Neon Devnet ) 使用 <strong><em>yarn deploy -n neon</em></strong> 命令。</p>
<p>Following the deployment, tests were run from the repository <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a>. To run the tests, the local Neon environment first needed to be configured and the private keys added to ~/.neon/neon. The command to run the tests was <strong><em>. start.sh</em></strong></p>
<p>部署之后，从存储库 <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a> 运行测试。要运行测试，首先需要配置本地 Neon 环境并将私钥添加到 ~/.neon/neon。运行测试的命令是 <strong><em>。开始.sh</em></strong></p>
<p>Tests were also run in the local Neon environment via Docker in the repository <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a>. The steps to conduct the test are as follows:</p>
<p>测试还通过存储库中的 Docker 在本地 Neon 环境中运行 <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a>。进行测试的步骤如下：</p>
<ol>
<li>
<p>Run a local Neon node using <a href="https://github.com/neonlabsorg/proxy-model.py">proxy-model.py</a><br>
使用 <a href="https://github.com/neonlabsorg/proxy-model.py">proxy-model.py</a> 运行本地 Neon 节点</p>
</li>
<li>
<p>Build the docker image using <strong><em>sudo docker build -t compound-protocol</em></strong><br>
使用 <strong><em>sudo docker build -t Compound-protocol</em></strong> 构建 docker 镜像</p>
</li>
<li>
<p>Run the container using <strong><em>sudo docker run -it — net=host compound-protocol</em></strong><br>
使用 <strong><em>sudo docker run -it --net=host Compound-protocol</em></strong> 运行容器</p>
</li>
</ol>
<p>Project deliverables include deployment and test scripts, as well as integration and unit tests. Deployment and test scripts can be accessed via the <a href="https://github.com/neon-smart-contract-dev/compound-finance">repository</a>. The integration and unit tests performed are available in a <a href="https://github.com/neon-smart-contract-dev/compound-finance/tree/neon_test/tests">GitHub repository</a> and can be run in a <a href="https://github.com/neon-smart-contract-dev/compound-finance/blob/neon_test/Dockerfile">Docker container</a> to re-play the testing scenarios.</p>
<p>项目可交付成果包括部署和测试脚本，以及集成和单元测试。可以点击 <a href="https://github.com/neon-smart-contract-dev/compound-finance">repository</a> 访问部署和测试脚本。执行的集成和单元测试可在 <a href="https://github.com/neon-smart-contract-dev/compound-finance/tree/neon_test/tests">GitHub 存储库</a> 中获得，并且可以在 <a href="https://github.com/neon-smart-contract-dev/compound-finance/blob/neon_test/Dockerfile">Docker 容器中运行</a>重现测试场景。</p>
<h1 id="发现-findings">发现 (Findings)</h1>
<p>Zpoken successfully deployed and tested the Compound protocol base contracts as well as swap pool. The deployment and associated tests indicated that Neon EVM is running correctly and is fully compatible with Ethereum with regards to running complex dApps like Compound. All integration and unit tests were passed. The contract deployment, logic, math, and functionality are working as expected by the Compound developer team. The only thing that could not be tested was the Compound Web Application due to the lack of the Compound API in public GitHub repositories.</p>
<p>Zpoken 成功部署并测试了 Compound 协议基础合约以及交换池。部署和相关测试表明，Neon EVM 运行正常，并且在运行 Compound 等复杂 dApp 方面与以太坊完全兼容。所有的集成和单元测试都通过了。合约部署、逻辑、数学和功能都按照 Compound 开发团队的预期工作。由于公共 GitHub 存储库中缺少 Compound API，唯一无法测试的是 Compound Web 应用。</p>
<p>Zpoken also identified two issues with the Neon platform:</p>
<p>Zpoken 还发现了 Neon 平台的两个问题：</p>
<ol>
<li>
<p>Deploying and testing the Compound contracts required support for RPC eth_accounts. The method has been implemented but there are errors that Neon Labs is currently addressing.<br>
部署和测试 Compound 合约需要支持 RPC eth_accounts。该方法已实施，但 Neon Labs 目前正在解决一些错误。</p>
</li>
<li>
<p>The multi-threaded execution of test scripts implemented in the original Compound tests is not supported by the Neon network. The tests were created for <a href="https://trufflesuite.com/ganache/">Ganache</a>, a personal Ethereum blockchain simulator, rather than a live node. Attempting to use multiple threads results in “nonce too low” errors. To avoid the error, each script should be run from a different deployer address. However, in tests that use multiple threads within a single test, the error cannot be avoided. The tests could not be run in these scenarios and were skipped.<br>
Neon 网络不支持多线程执行原 Compound 测试中实现的测试脚本。这些测试是为个人以太坊区块链模拟器 <a href="https://trufflesuite.com/ganache/">Ganache</a> 而不是实时节点创建的。尝试使用多个线程会导致“nonce too low”错误。为避免该错误，应从不同部署者地址运行每个脚本。但是，在单个测试中使用多个线程的测试中，错误是无法避免的。测试无法在这些场景中运行并被跳过。</p>
</li>
</ol>
<h1 id="结论-conclusion">结论 (Conclusion)</h1>
<p>It’s time for <strong>YOU</strong> to deploy your own smart contracts to Neon EVM. Make sure to share your Neon EVM feedback with us throughout the process. If you have any issues or need additional guidance, check out our <a href="https://docs.neon-labs.org/">Neon Docs</a> or reach out to a team member on <a href="https://discord.com/invite/9jVYEDVwn8">Discord</a>. We know that you’ll create something great!</p>
<p>现在是 <strong>您</strong> 将您自己的智能合约部署到 Neon EVM 的时候了。确保在整个过程中与我们分享您对 Neon EVM 的反馈。如果您有任何问题或需要额外指导，请查看我们的 <a href="https://docs.neon-labs.org/">Neon Docs</a> 或通过 <a href="https://discord.com">Discord</a> 联系团队。我们知道你会创造出伟大的东西！</p>
]]></content>
    </entry>
</feed>