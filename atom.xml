<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chainguys.github.io</id>
    <title>Chainguys&apos;Blog</title>
    <updated>2022-10-28T05:40:18.782Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chainguys.github.io"/>
    <link rel="self" href="https://chainguys.github.io/atom.xml"/>
    <subtitle>A blockchain guy who likes making memes and translating tech articles &lt;/br&gt;All Information NOT Financial Adivice&lt;/br&gt; 一个区块链的老韭菜 &lt;/br&gt;兴趣是做meme和翻译技术文章 &lt;/br&gt;一切均非投资建议</subtitle>
    <logo>https://chainguys.github.io/images/avatar.png</logo>
    <icon>https://chainguys.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Chainguys&apos;Blog</rights>
    <entry>
        <title type="html"><![CDATA[模块化执行的案例(第二部分) The Case for Modular Execution (Part 2)]]></title>
        <id>https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-er-bu-fen-the-case-for-modular-execution-part-2/</id>
        <link href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-er-bu-fen-the-case-for-modular-execution-part-2/">
        </link>
        <updated>2022-10-27T05:32:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/10/BlogPost3-V1.png" alt="The Case for Modular Execution (Part 2)" loading="lazy"></figure>
<p>How modular execution layers can achieve scalability by optimizing for efficient computation.<br>
模块化执行层如何通过优化高效计算，来实现可扩展性。</p>
<hr>
<h2 id="模块化执行的案例-the-case-for-modular-execution">模块化执行的案例 (The Case for Modular Execution)</h2>
<p>Modular architecture will enable blockchains to <a href="https://fuel-labs.ghost.io/beyond-monolithic-the-modular-blockchain-paradigm/">scale by orders of magnitude</a>. As a core part of the modular stack, execution layers are in a stage of rapid innovation.</p>
<p>模块化架构将使区块链能够<a href="https://fuel-labs.ghost.io/beyond-monolithic-the-modular-blockchain-paradigm/">按数量级扩展</a>。作为模块化技术栈的核心部分，执行层正处于快速创新的阶段。</p>
<p><strong>Fuel is building the fastest execution layer for the modular blockchain stack.</strong> In <a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/">Part 1</a> we explored how modular execution layers enable scalability by decoupling computation from verification.</p>
<p><strong>Fuel 正在为模块化区块链技术栈构建最快的执行层。</strong> 在 <a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">第一部分</a>我们探索了模块化执行层如何通过将计算与验证解耦来实现可扩展性。</p>
<p><a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">模块化执行的案例(第一部分) The Case for Modular Execution (Part 1)</a></p>
<figure data-type="image" tabindex="2"><img src="https://fuel-labs.ghost.io/content/images/2022/10/the-case-for-modular-execution-part-1.png" alt="" loading="lazy"></figure>
<p>We also touched on a second core benefit which enables modular execution layers to scale by orders of magnitude more than their monolithic counterparts:</p>
<p>我们还谈到了第二个核心优势，它使模块化执行层能够比其单片执行层扩展几个数量级：</p>
<blockquote>
<p><em><strong>Monolithic chains are locked into inefficient technologies when it comes to the speed and variety of computation they can support. On the other hand, modular execution layers can be specifically designed to optimize for efficient computation.</strong></em></p>
<p><em><strong>单片链在它们可以支持的计算速度和多样性方面被锁定在低效的技术中。另一方面，模块化执行层可以专门设计用于优化高效计算。</strong></em></p>
</blockquote>
<p>This post explores this second core benefit, with a specific focus on how Fuel is revolutionizing the way blockchains handle computation.</p>
<p>这篇文章探讨了第二个核心优势，特别关注 Fuel 如何彻底改变区块链处理计算的方式。</p>
<hr>
<h2 id="单片链layer1迭代的挑战-monolithic-chains-the-challenge-of-iterating-on-layer-1s">单片链：Layer1迭代的挑战 (Monolithic Chains: The Challenge of Iterating on Layer-1s)</h2>
<p><em>Monolithic chains are locked into inefficient technologies when it comes to the speed and variety of computation they can support.</em></p>
<p><em>单片链在其可以支持的计算速度和多样性方面，被锁定在低效的技术中。</em></p>
<p>When blockchains were first conceived of, there was a single use case in mind: digital cash. The Bitcoin blockchain was designed to optimize for this one narrow use case.</p>
<p>首次构想区块链时，脑海中只有一个用例：数字现金。比特币区块链旨在优化这一狭窄用例。</p>
<p>Soon after the launch of Bitcoin, people started to realize the potential of blockchains for use cases far beyond money. The narrative quickly shifted from “distributed ledger” to “distributed computer”. The Bitcoin community attempted to support this use case through <a href="https://en.wikipedia.org/wiki/Colored_Coins">colored coins</a>, but it was clear that it was not versatile enough to truly support trustless distributed computing; it was locked into its original use case. A new architecture was required.</p>
<p>比特币推出后不久，人们开始意识到区块链远超金钱用例的潜力。叙事迅速从“分布式账本”转变为“分布式计算机”。比特币社区试图通过 <a href="https://en.wikipedia.org/wiki/Colored_Coins">色彩币</a> 来支持这个用例，但很明显它的通用性不足以真正支持去信任分布式计算；它被锁定在其原始用例中。(我们)需要一种新的架构。</p>
<p>Recognizing this problem, the creators of Ethereum set out to build a blockchain which could support a distributed Turing-complete virtual machine: the Ethereum Virtual Machine (EVM). With the launch of Ethereum in 2015, blockchains had evolved to support arbitrary computation in a trustless environment. Now, anyone could build and launch a computer program (smart contract) and have it run on a distributed computer.</p>
<p>认识到这个问题，以太坊的创建者着手构建一个可以支持分布式图灵完备虚拟机的区块链：以太坊虚拟机(EVM)。随着 2015 年以太坊的推出，区块链已经发展到支持去信任环境中的任意计算。现在，任何人都可以构建和启动一个计算机程序(智能合约)并让它在分布式计算机上运行。</p>
<p>Ethereum was conceived of less than half a decade after the concept of blockchains came into existence. In the 7 years since Ethereum launched, new concepts have been invented which represent an even greater leap forward than the progress Ethereum made over Bitcoin. But like Bitcoin, the Ethereum blockchain is mostly locked into the core architecture it launched with.</p>
<p>以太坊是在区块链概念出现后不到五年的时间构思出来的。自以太坊推出以来的 7 年里，人们发明了新概念，这代表了以太坊相对比特币所取得进步的更大飞跃。但就像比特币一样，以太坊区块链大多被锁定在它推出的核心架构中。</p>
<p><em><strong>For every improvement that has been made to the Ethereum blockchain and the EVM over the years, there are many more potential innovations that cannot be implemented due to the need to maintain backward compatibility.</strong></em></p>
<p><em><strong>对于多年来对以太坊区块链和 EVM 所做的每一项改进，由于需要保持向后兼容性，还有许多潜在的创新无法实施。</strong></em></p>
<p>As a result, the blockchain community has continued funding, building, and launching new blockchains every time a new innovation is hatched. Countless new layer-1 blockchains have launched on the promise of iterating on the concept of trustless distributed computing, but they all run into the same challenge: it’s hard (and often impossible) to upgrade blockchains to support new functionalities and improvements.</p>
<p>因此，每次孵化出新创新时，区块链社区都会继续资助、构建和推出新的区块链。无数新的Layer1区块链已经推出，承诺迭代去信任分布式计算的概念，但它们都遇到了同样的挑战：升级区块链来支持新功能和改进是困难的(而且通常是不可能的)。</p>
<p>And so the cycle continues, where we continue to see new blockchains launching with piecemeal improvements over their predecessors. In the process, we are left with an ecosystem of mostly incompatible blockchains, with ever-increasing fragmentation of liquidity, funding, user experience, and developer-mindshare. Meanwhile, the energy that could be spent on true innovation is instead directed toward getting attention from investors, developers, and end-users.</p>
<p>所以这个循环还在继续，我们也继续看到新区块链推出，对它们的前辈进行零碎的改进。在这个过程中，我们留下了一个由大部分不兼容的区块链组成的生态系统，流动性、资金、用户体验和开发者的思想份额越来越分散。与此同时，可以花在真正创新上的精力反而被用于吸引投资者、开发商和最终用户的关注。</p>
<p>Competition is healthy and necessary for a thriving ecosystem. But this competition is happening at the wrong level.</p>
<p>竞争对于繁荣的生态系统是健康的和必要的。但这场竞争发生在错误的层面。</p>
<p><strong>The modular blockchain paradigm promises to solve this problem.</strong> Because each layer in the modular stack is independent of the others, innovation can happen on one layer without a complete overhaul of the entire stack. Execution layers can compete on execution. Data availability layers can compete on data availability. Every layer can optimize for its intended purpose without breaking backward compatibility.</p>
<p><strong>模块化区块链范式有望解决这个问题。</strong> 由于模块化技术栈中的每一层都独立于其他层，因此创新可以发生在一个单独层上，而无需对整个技术栈进行彻底检修。执行层可以竞争执行。数据可用性层可以在数据可用性上竞争。每一层都可以针对其预期目的进行优化，而不会破坏向后兼容性。</p>
<p>Shared settlement layers enable liquidity to be pooled in one place, so new execution layers can be built without fragmenting liquidity or adding friction to the end-user experience. Natively enabled trust-minimized bridging means the community can reduce the resources spent on interoperability efforts and instead focus them on exploring meaningful innovations.</p>
<p>共享结算层可以将流动性集中在一个地方，因此可以构建新的执行层，而不会分散流动性或增加最终用户体验的摩擦。原生支持的信任最小化桥接意味着社区可以减少在交互性工作上花费的资源，而是将它们集中在探索有意义的创新上。</p>
<p>With the advent of the modular stack, we can move away from a disparate ecosystem of L1s competing on vanity metrics, and toward a more cohesive, interoperable, upgradeable stack.</p>
<p>随着模块化技术栈的出现，我们可以摆脱在虚荣指标上竞争的不同的 L1 生态系统，而转向更具凝聚力、可交互、可升级的技术栈。</p>
<hr>
<h2 id="模块化执行超越-evm-modular-execution-moving-beyond-the-evm">模块化执行：超越 EVM (Modular Execution: Moving Beyond the EVM)</h2>
<p>Despite the plethora of layer-1 blockchains promising improvements over the EVM's original design, its first-mover advantage enabled the EVM to gain a foothold as the &quot;default&quot; runtime environment in the blockchain ecosystem. Smart contract development became synonymous with Solidity (the EVM's programming language), which has captured the majority of would-be blockchain developers. Because of this, most execution layers currently under development are EVM-based rollups.</p>
<p>尽管有过多的Layer1区块链有望对 EVM 的原始设计进行改进，但其先发优势使 EVM 作为区块链生态系统中的“默认”运行时环境获得了立足点。智能合约开发成为 Solidity(EVM 的编程语言)的代名词，它吸引了大多数潜在的区块链开发人员。因此，目前正在开发的大多数执行层都是基于 EVM 的汇总。</p>
<p>There is a good reason for this: using the EVM enables rollups to tap into a market of existing applications written in Solidity, as well as a large cohort of end-users who are already familiar with those applications. The EVM is a great tool for seeding a new ecosystem, as it already has such a large share of the developer market.</p>
<p>这有一个很好的理由：使用 EVM 使汇总能够进入使用 Solidity 编写的现有应用程序的市场，以及已经熟悉这些应用程序的大量最终用户。 EVM 是播种新生态系统的绝佳工具，因为它已经在开发者市场占有如此大的份额。</p>
<p>However, as we already explored, the need to maintain backward compatibility means that the EVM has been unable to adopt many innovations. In addition, the core design of the EVM is optimized for a monolithic chain, not a modular stack.</p>
<p>然而，正如我们已经探讨过的，保持向后兼容性的需要意味着 EVM 无法采用许多创新。此外，EVM 的核心设计针对单片链而非模块化技术栈进行了优化。</p>
<p><strong>Just some limitations of the EVM include:</strong><br>
<strong>EVM 的一些限制包括：</strong></p>
<ul>
<li>
<p><strong>Sequential Execution</strong> - The EVM does not support parallel transaction execution, making it much less computationally efficient than other VM designs.<br>
<strong>顺序执行</strong> - EVM 不支持并行交易执行，使其计算效率低于其他 VM 设计。</p>
</li>
<li>
<p><strong>Fraud Proofs</strong> - Ethereum’s account-based model means generating and executing fraud proofs on EVM chains is extremely costly and inefficient, making it sub-optimal for modular execution layers.<br>
<strong>欺诈证明</strong> - 以太坊基于账户的模型意味着在 EVM 链上生成和执行欺诈证明的成本极高且效率低下，因此对于模块化执行层来说并非最优。</p>
</li>
<li>
<p><strong>Solidity</strong> - The most popular programming language for the EVM, Solidity, is notorious for providing a poor developer experience, and is designed in a way that makes it difficult to write secure smart contracts.<br>
<strong>Solidity</strong> - EVM 最流行的编程语言 Solidity 因提供糟糕的开发者体验而声名狼藉，并且其设计方式使得编写安全的智能合约变得困难.</p>
</li>
</ul>
<hr>
<h2 id="fuel优化的模块化执行-fuel-optimized-for-modular-execution">Fuel：优化的模块化执行 (Fuel: Optimized for Modular Execution)</h2>
<p>The advent of modularism means that execution layers can leverage Ethereum’s liquidity and security without being restricted by the limitations of the EVM.</p>
<p>模块化的出现意味着执行层可以利用以太坊的流动性和安全性，而不受 EVM 的限制。</p>
<figure data-type="image" tabindex="3"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-23.png" alt="" loading="lazy"></figure>
<p>By adopting new and improved VM design principles, modular execution layers can specifically optimize for efficient &amp; scalable computation, superior developer experience, and maximum security.</p>
<p>通过采用全新和改进的 VM 设计原则，模块化执行层可以专门针对高效和可扩展计算、卓越的开发者体验和最大的安全性进行优化。</p>
<p>Fuel is taking advantage of this new design space to build <a href="https://www.fuel.network/">the fastest modular execution layer</a>.</p>
<p>Fuel 正在利用这个新的设计空间来构建 <a href="https://www.fuel.network/">最快的模块化执行层</a>。</p>
<h3 id="fuel虚拟机-fuelvm">Fuel虚拟机 (FuelVM)</h3>
<p>One of the core innovations of Fuel is a <strong>completely new virtual machine, the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a></strong>. The advent of execution layers built on Ethereum presents a new opportunity to improve on past VM designs, unconstrained by the need to be backward compatible.</p>
<p>Fuel 的核心创新之一是<strong>全新的虚拟机，<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a></strong>。基于以太坊构建的执行层的出现，为改进过去的 VM 设计提供了新的机会，不受向后兼容需求的限制。</p>
<p>While the EVM’s slow transaction execution may have been sufficient in a pre-modular world where bandwidth was the core bottleneck, improvements made within the new modular stack (including on L1 Ethereum) mean that computational throughput is becoming the primary constraint when it comes to scaling.</p>
<p>虽然在带宽是核心瓶颈的前模块化世界中，EVM 的缓慢交易执行可能已经足够，但在新的模块化技术栈(包括 L1 以太坊)中所做的改进意味着计算吞吐量正在成为扩展时的主要限制.</p>
<p>In anticipation of this new paradigm, <strong>the FuelVM is designed to optimize for fast transaction execution</strong>. Taking learnings from the EVM, Solana, WASM, Bitcoin, and Cosmos, the FuelVM is designed to reduce wasteful processing of traditional blockchain virtual machine architectures, while vastly increasing the potential design space for developers.</p>
<p>出于对这种新范式的预期，<strong>FuelVM 旨在优化快速交易执行</strong>。 FuelVM 借鉴了 EVM、Solana、WASM、比特币和 Cosmos，旨在减少传统区块链虚拟机架构的浪费处理，同时极大地增加开发人员的潜在设计空间。</p>
<p>The FuelVM adopts many innovations that have been suggested and supported by the EVM community, but couldn't be implemented due to the need to maintain backward compatibility. Just a few examples are highlighted below (<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html#eips-implemented-in-fuel">see here for the full list</a>).</p>
<p>FuelVM 采用了许多 EVM 社区已经建议和支持的创新，但由于需要保持向后兼容性而无法实施。下面仅突出显示了几个示例(<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html#eips-implemented-in-fuel">完整列表请参见此处</a>)。</p>
<figure data-type="image" tabindex="4"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-24.png" alt="" loading="lazy"></figure>
<p><em>These are just a few examples of EIPs which were ultimately rejected for the EVM due to backward compatibility issues, but have been implemented in Fuel (source:</em> <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html#eips-implemented-in-fuel"><em>Fuel</em></a><em>)</em><br>
<em>这些只是 EIP 的几个示例，由于向后兼容性问题最终被 EVM 拒绝，但已在 Fuel 中实现(来源：</em> [<em>Fuel</em>](https://fuellabs.github.io/fuel-docs/master /vs-evm.html#eips-implemented-in-fuel)<em>)</em></p>
<h3 id="用sway和force实现的高级devex-superior-devex-with-sway-and-forc">用Sway和Force实现的高级DevEx (Superior DevEx with Sway and Forc)</h3>
<p>The Fuel protocol was designed with developer experience at the forefront. <strong>The FuelVM has been built alongside its companion language, <a href="https://fuellabs.github.io/fuel-docs/master/sway-language.html">Sway</a></strong>: a Rust-based domain-specific language designed specifically to leverage a blockchain VM. Unlike Solidity, which was developed after the creation of the EVM, Sway has been created from the ground up to have convenient and efficient ops built-in. By basing Sway on Rust, Fuel makes smart contract development safer and more performant through the use of strong static analysis and compiler feedback.</p>
<p>Fuel 协议的设计凝结最前沿的开发人员经验。 <strong>FuelVM 是与它的配套语言 <a href="https://fuellabs.github.io/fuel-docs/master/sway-language.html">Sway</a> 一起构建的</strong>：一种基于 Rust 设计的特定领域语言，专门来使用区块链虚拟机。与在创建 EVM 之后开发的 Solidity 不同，Sway 是从头开始创建的，内置了方便高效的操作。通过基于 Rust 的 Sway，Fuel 通过使用强大的静态分析和编译器反馈使智能合约开发更安全、更高效。</p>
<p>From a tooling perspective, <strong>Fuel improves on the EVM ecosystem with the <a href="https://fuellabs.github.io/fuel-docs/master/fuel-toolchain.html">Forc toolchain</a></strong>. With Forc, developers can get everything they need to start creating Sway applications for the Fuel VM with a single toolchain. Fuel takes a curated, &quot;batteries-included&quot;-yet-modular approach to providing tooling, with a comprehensive, standardized, canonical set of tools that covers not only the lower levels of the stack (like protocol and VM implementations), but also the higher levels (such as package management, editor support, common-use plugins, and much more).</p>
<p>从工具的角度来看，<strong>Fuel 通过 <a href="https://fuellabs.github.io/fuel-docs/master/fuel-toolchain.html">Forc 工具链</a></strong> 改进了 EVM 生态系统。借助 Forc，开发人员可以使用单个工具链获得开始为 Fuel VM 创建 Sway 应用所需的一切。 Fuel 采用精心策划的“包含电池”但模块化的方法来提供工具，具有全面、标准化、规范的工具集，不仅涵盖技术栈的较低级别(如协议和 VM 实现)，也包括更高级别(例如包管理、编辑器支持、常用插件等等)。</p>
<p>Fuel’s developer environment retains the benefits of smart contract languages like Solidity while adopting the paradigms introduced in the Rust tooling ecosystem, making the learning curve for Sway easily manageable for all levels of developer experience.</p>
<p>Fuel 的开发人员环境保留了 Solidity 等智能合约语言的优势，同时采用了 Rust 工具生态系统中引入的范式，使 Sway 的学习曲线易于管理，适合所有级别的开发人员体验。</p>
<h3 id="并行交易执行-parallel-transaction-execution">并行交易执行 (Parallel Transaction Execution)</h3>
<p>The ability to execute transactions in parallel is a highly desirable property, especially as modern processors become increasingly multi-threaded. As such, it was a core consideration when designing the Fuel protocol.</p>
<p>并行执行交易的能力是一个非常理想的属性，尤其是在现代处理器变得越来越多线程的情况下。因此，这是设计 Fuel 协议时的核心考虑因素。</p>
<p>Parallel transaction execution requires the ability to determine and handle <a href="https://en.wikipedia.org/wiki/Parallel_computing#Dependencies">dependencies</a> between transactions. In order to avoid overlap when processing the transactions on separate cores, the shared state that may be touched by each transaction needs to be identified upfront (via “access lists”), so transactions can be partitioned into sets which don’t have any possible interactions with one another.</p>
<p>并行交易执行需要能够确定和处理交易之间的<a href="https://en.wikipedia.org/wiki/Parallel_computing#Dependencies">依赖项</a>。为了避免在不同核上处理交易时发生重叠，需要预先识别每个交易可能涉及的共享状态(通过“访问列表”)，因此可以将交易划分为没有任何可能彼此互动的集合。</p>
<p>Because of the constraints of its account-based design, Ethereum is not able to support these access lists, so is forced to process transactions sequentially (i.e. one after the other). <a href="https://github.com/ethereum/EIPs/issues/648">EIP-648</a> proposed the addition of access lists to Ethereum, but this has never been implemented due to other inefficiencies it would introduce.</p>
<p>因为其基于帐户的设计的限制，以太坊无法支持这些访问列表，因此被迫按顺序处理交易(即一个接一个)。 <a href="https://github.com/ethereum/EIPs/issues/648">EIP-648</a> 提议向以太坊添加访问列表，但由于它会引入其他类型的低效率，所以这从未实施过。</p>
<p>Learning from this limitation, Fuel has implemented <a href="https://fuellabs.github.io/fuel-docs/master/technology/parallel_tx_execution.html#state-access-lists-and-utxos">strict state access lists</a> in the form of a UTXO model, giving it the ability to use multiple CPU threads and cores that are typically idle in single-threaded blockchains. As a result, <strong>Fuel can execute transactions in parallel</strong>, delivering far more compute, state accesses, and transactional throughput than its single-threaded counterparts.</p>
<p>从这个限制中吸取教训，Fuel 实施了形同UTXO 模型的 <a href="https://fuellabs.github.io/fuel-docs/master/technology/parallel_tx_execution.html#state-access-lists-and-utxos">严格的状态访问列表</a> ，使其能够使用通常在单线程区块链中空闲的多个 CPU 线程和内核。因此，**Fuel 可以并行执行交易，提供比单线程更多的计算、状态访问和交易吞吐量。</p>
<figure data-type="image" tabindex="5"><img src="https://lh5.googleusercontent.com/3XJEoCTGhPZl6T44ob4P2bAYrHi-TqggBsNYVCpegu5WSh5upC6kxrAZR6r-ErgSk69TwYmH6ex4hysI4-EoHZGZ1lSdB6-rcdRJpsbbYVipnjNHQPIyZqcvvOwrOfHVaa8pWd-9pHi0pKOwH1lDpDYsrt1K0kFInV7tq51t6ZfpZiBAd7mJC7IOgg" alt="" loading="lazy"></figure>
<p><em>Fuel’s support for parallel transaction execution means validators can maximize efficiency by using all of their hardware (source:</em> <a href="https://fuellabs.github.io/fuel-docs/master/why-fuel.html#parallel-execution"><em>Fuel</em></a><em>)</em><br>
<em>Fuel 对并行交易执行的支持意味着验证者可以通过使用其所有的硬件来最大化效率(来源：</em> <a href="https://fuellabs.github.io/fuel-docs/master/why-fuel.html#parallel-execution"><em>Fuel</em></a><em>)</em></p>
<p>As well as providing efficiency optimizations, <strong>the ability to process multiple transactions in parallel allows for security improvements</strong>, as it enables transaction throughput to scale without a comparable increase in the resource requirements to verify those transactions. This reduces the barrier for running a full node, leading to a more decentralized network of verifiers.</p>
<p>除了提供效率优化外，<strong>并行处理多个交易的能力还可以提高安全性</strong>，因为它可以扩展交易吞吐量，而不会增加用于验证这些交易的资源需求。这降低了运行完整节点的障碍，从而导致验证者网络更加分散。</p>
<h3 id="为欺诈证明而优化-optimized-for-fraud-proofs">为欺诈证明而优化 (Optimized for Fraud Proofs)</h3>
<p>Fraud proofs are a core technology in the modular blockchain stack. In <a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/">Part 1</a>, we explored how modular execution layers can leverage fraud proofs to enable trust-minimized light clients, allowing for security under the assumption that only a single honest full node is available.</p>
<p>欺诈证明是模块化区块链技术栈中的核心技术。在 <a href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">第一部分</a> 中，我们探讨了模块化执行层如何利用欺诈证明来启用信任最小化的轻客户端，在只有一个诚实的全节点可用的假设下确保安全性。</p>
<figure data-type="image" tabindex="6"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-25.png" alt="" loading="lazy"></figure>
<p><em>Fraud proofs enable trust-minimized light clients which rely on a single honest minority, giving them much greater security guarantees than monolithic light clients (source:</em> <a href="https://fuel-labs.ghost.io/the-case-for-modular-execution-part-1/"><em>Fuel</em></a><em>)</em><br>
<em>欺诈证明使信任最小化的轻客户端依赖于一个诚实的少数，为他们提供比单体轻客户端更大的安全保证(来源：</em> [<em>Fuel</em>](https://fuel-labs.ghost.io/the-case- for-modular-execution-part-1/)<em>)</em></p>
<p>With trust-minimized light clients and shared settlement &amp; data availability layers, it is possible to build trust-minimized bridges between modular execution layers, something which is impossible to achieve between L1s. This allows for the experimentation with and deployment of new blockchain designs without fragmenting security or liquidity.</p>
<p>通过信任最小化的轻客户端和共享结算和数据可用性层，可以在模块化执行层之间建立信任最小化的桥接，这是 L1 之间无法实现的。这允许在不破坏安全性或流动性的情况下试验和部署新的区块链设计。</p>
<p>Because of the benefits fraud proofs provide, <strong>Fuel was designed and built specifically to be fraud-provable</strong> in a low-cost, efficient manner.</p>
<p>由于欺诈证明提供的好处，<strong>Fuel 被设计和产出专门的低成本和高效的方式证明欺诈</strong>。</p>
<p>Whereas Ethereum’s account-based model means that the cost of constructing fraud proofs for it is unbound, Fuel optimizes for fraud proofs by using the UTXO model. <a href="https://fuellabs.github.io/fuel-docs/master/technology/fraud_proofs.html">UTXO fraud proofs</a> achieve efficiency by simply requiring each spend of a UTXO to &quot;point&quot; to the creation of the UTXO, without having to refer to a global state tree. Proving that either a) the pointer is invalid, or b) whatever is being pointed to doesn't match whatever is being spent, is sufficient for exhaustively proving fraud.</p>
<p>以太坊基于账户的模型意味着为其构建欺诈证明的成本是无限的，而 Fuel 通过使用 UTXO 模型来优化欺诈证明。 <a href="https://fuellabs.github.io/fuel-docs/master/technology/fraud_proofs.html">UTXO 欺诈证明</a> 通过简单地要求 UTXO 的每笔支出“指向”UTXO 的创建来实现效率，无需强制参考全局状态树。证明 a) 指针无效，或 b) 所指向的内容与所花费的内容不匹配，足以彻底证明欺诈。</p>
<p>As an added benefit, the <a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/instruction_set.md">FuelVM instruction set</a> is designed to be fraud-provable within the EVM. This means Fuel can use Ethereum as a settlement layer, leveraging its deep liquidity and large user base while remaining unconstrained by the limitations of the EVM.</p>
<p>还有一个额外的好处，<a href="https://github.com/FuelLabs/fuel-specs/blob/master/specs/vm/instruction_set.md">FuelVM 指令集</a> 被设计在 EVM 中进行欺诈证明。这意味着 Fuel 可以使用以太坊作为结算层，利用其深厚的流动性和庞大的用户群，同时不受 EVM 的限制。</p>
<h3 id="其他益处-other-benefits">其他益处 (Other Benefits)</h3>
<p>On top of the above points, Fuel has implemented a number of other improvements, including:<br>
除了上述几点之外，Fuel 还实施了许多其他改进，包括：</p>
<ul>
<li>Support for multiple native assets  支持多种原生资产</li>
<li>Native account abstraction &amp; predicates  原生支持帐户抽象和谓词</li>
<li>Multi-dimensional resource pricing  本机帐户抽象和谓词</li>
<li>Sequencer decentralization  序列器去中心化</li>
</ul>
<p>An explanation of these improvements is out of scope for this article, but Blockchain Capital provides an excellent <a href="https://medium.com/blockchain-capital-blog/exploring-the-fuelvm-86cf9ccdc159">deep dive into these additional benefits</a>.</p>
<p>对这些改进的解释超出了本文的范围，但 Blockchain Capital 提供了出色报告，告诉大家 <a href="https://chainguys.github.io/post/tan-suo-fuel-xu-ni-ji-fuelvm-exploring-the-fuelvm/">深入了解这些额外好处</a> .</p>
<hr>
<h2 id="结论-summary">结论 (Summary)</h2>
<ul>
<li>
<p>The monolithic paradigm leads to an ecosystem of incompatible L1s competing on vanity metrics, fragmenting liquidity, funding, and developer-mindshare. Fuel adopts the premise that <strong>innovation does not require launching a new L1, but can happen at the execution layer</strong>.<br>
单片范式导致不兼容的 L1 生态系统在虚荣的指标上竞争、分散流动性、资金和开发者的思想份额。 Fuel 采用的前提是<strong>创新不需要启动新的 L1，但可以发生在执行层</strong></p>
</li>
<li>
<p>Modular architecture enables MELs such as Fuel to focus on efficient computation without worrying about backward compatibility. Faster computation not only leads to higher throughput, but also makes running validators more efficient, improving decentralization. This enables Fuel to contribute to Ethereum’s scalability without being held back by the inefficiencies of the EVM.<br>
模块化架构使诸如 Fuel 之类的 MEL 能够专注于高效计算，而无需担心向后兼容性。更快的计算不仅可以带来更高的吞吐量，还可以让运行验证器的效率更高，从而增强去中心化。这使 Fuel 能够为以太坊的扩容做出贡献，而不会因 EVM 的低效而受阻。</p>
</li>
<li>
<p>Execution layers that use the EVM can capitalize on the existing ecosystem of Solidity applications and developers, but fail to make the most of the design space offered by the modular stack. Fuel is leveraging this new design space with the FuelVM, designed from the ground up to be fraud-provable and to provide the best developer experience.<br>
使用 EVM 的执行层可以利用现有的 Solidity 应用和开发人员生态系统，但无法充分利用模块化技术栈提供的设计空间。 Fuel 正在通过 FuelVM 充分利用这一新的设计空间，该设计从一开始就设计为可防欺诈并提供最佳的开发者体验。</p>
</li>
<li>
<p>Fuel introduces innovations that optimize for the rapidly approaching modular future, enabling a new generation of blockchains that go #BeyondMonolithic..<br>
Fuel 引入了针对快速接近的模块化未来进行优化的创新，使新一代区块链成为可能 #超越单片链..</p>
</li>
</ul>
<hr>
<h2 id="敬请关注-follow-us"><strong>敬请关注 (Follow Us)</strong></h2>
<ul>
<li><a href="https://twitter.com/fuellabs_"><strong>Twitter</strong></a></li>
<li><a href="http://discord.com/invite/xfpK4Pe"><strong>Discord</strong></a></li>
<li><a href="https://www.linkedin.com/company/fuel-labs/"><strong>LinkedIn</strong></a></li>
<li><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong>YouTube</strong></a></li>
</ul>
<h2 id="关于我们-about-us"><strong>关于我们 (About Us)</strong></h2>
<p><a href="https://www.fuel.network/">Fuel</a> is the <strong>fastest execution layer</strong> for the modular blockchain stack. Powerful and sleek, the technology enables parallel transaction execution, empowering developers with the <strong>highest flexible throughput</strong> and <strong>maximum security</strong> required to scale. Developers choose the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> for its <strong>superior developer experience</strong> and the ability to go <strong>beyond the limitations of the EVM</strong>.</p>
<p><a href="https://www.fuel.network/">Fuel</a> 是模块化区块链技术栈的<strong>最快执行层</strong>。该技术功能强大且时尚，支持并行交易执行，为开发人员提供了扩展所需的<strong>最高灵活吞吐量</strong>和<strong>最大安全性</strong>。开发人员选择 <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> 是因为它<strong>卓越的开发人员体验和运行能力</strong> ，突破了 EVM 的限制**。</p>
<h2 id="成为贡献者-become-a-contributor"><strong>成为贡献者 (Become a Contributor)</strong></h2>
<ul>
<li>
<p><a href="https://jobs.lever.co/fuellabs">Explore our current job openings</a><br>
<a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></p>
</li>
<li>
<p><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">Apply for a grant</a><br>
<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请资助</a></p>
</li>
<li>
<p><a href="https://fuellabs.github.io/sway/v0.24.5/">Learn Sway</a><br>
<a href="https://fuellabs.github.io/sway/v0.24.5/">学习Sway</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zpoken 成功在 Neon EVM 上部署 Compound 协议(Zpoken Successfully Deploys the Compound Protocol on Neon EVM)]]></title>
        <id>https://chainguys.github.io/post/zpoken-cheng-gong-zai-neon-evm-shang-bu-shu-compound-xie-yi-zpoken-successfully-deploys-the-compound-protocol-on-neon-evm/</id>
        <link href="https://chainguys.github.io/post/zpoken-cheng-gong-zai-neon-evm-shang-bu-shu-compound-xie-yi-zpoken-successfully-deploys-the-compound-protocol-on-neon-evm/">
        </link>
        <updated>2022-10-21T03:40:35.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/1*gmc_nXaOC8Reo4m24EF0WA.png" alt="" loading="lazy"></figure>
<hr>
<p>Over the last few months, Neon Labs has partnered with several organizations to test and deploy various protocols and projects on Neon EVM. Neon Labs’ most recent partnership with <a href="https://zpoken.io/">Zpoken</a> has resulted in the successful deployment of the <a href="https://compound.finance/">Compound protocol</a> on Neon EVM. The deployment of Compound on Neon EVM serves to further test the readiness of Neon EVM for production and the onboarding of complex dApps to its ecosystem.</p>
<p>在过去几个月中，Neon Labs 与多家组织合作，在 Neon EVM 上测试和部署各种协议和项目。 Neon Labs 与 Zpoken 的最新合作，就是在 Neon EVM 上成功部署 Compound 协议。在 Neon EVM 上部署 Compound 有助于进一步测试 Neon EVM 的生产准备情况以及复杂 dApp 加入其生态系统的情况。</p>
<p>Compound is a DeFi dApp that first launched in September, 2018 on Ethereum. The protocol allows users to lend and borrow cryptocurrencies without an intermediary</p>
<p>Compound 是一个 DeFi dApp，于 2018 年 9 月在以太坊上首次推出。该协议允许用户在没有中介的情况下借出和借入加密货币。</p>
<h1 id="zpoken是谁-who-is-zpoken">Zpoken是谁? (Who is Zpoken?)</h1>
<p>Zpoken is a full-stack Web3 development firm. The company has shipped more than 50 projects and has 30 active builders across 10+ blockchain networks. Zpoken’s specializations include high-end web3 development, cryptography, capital markets, token design, and liquidity.</p>
<p>Zpoken是一家全栈 Web3 开发公司。该公司已经交付了 50 多个项目，并在 10 多个区块链网络中拥有 30 名活跃的建设者。 Zpoken 的专长包括高端 web3 开发、密码学、资本市场、代币设计和流动性。</p>
<h1 id="我们的目标-our-objective">我们的目标 (Our Objective)</h1>
<p>The main objective of the exercise with Zpoken was to test Neon EVM’s performance and functionality during the deployment of the Compound protocol contracts to <a href="https://proxy.devnet.neonlabs.org/solana">Neon Devnet</a>.</p>
<p>Zpoken练习的主要目的，是在将 Compound 协议合约部署到 Neon Devnet 期间测试 Neon EVM 的性能和功能。</p>
<p>Following the successful deployment, Zpoken conducted unit tests on the protocol. The goal was to ensure the appropriate performance and workflow of the protocol contracts as well as the correctness of the contract calculations and logic.</p>
<p>成功部署后，Zpoken 对该协议进行了单元测试。目标是确保协议合约的适当性能，工作流程以及合约计算和逻辑的正确性。</p>
<h1 id="测试方法-testing-methodology">测试方法 (Testing Methodology)</h1>
<p>Zpoken tested the following smart contract functions to verify the performance of Compound on Neon EVM:</p>
<p>Zpoken测试了以下智能合约函数来验证 Compound 在 Neon EVM 上的性能：</p>
<ul>
<li>
<p>Deploy compound contracts to Neon Devnet network;<br>
将compound合约部署到 Neon Devnet 网络；</p>
</li>
<li>
<p>Test cToken contract functions 测试cToken合约函数:<br>
(constructor, mint, mintFresh, redeem, redeemFreshTokens, redeemFreshAmount, liquidateBorrow, liquidateBorrowFresh, seize, _setComptroller, transfer, balanceOfUnderlying, borrow, borrowRatePerBlock, supplyRatePerBlock, borrowBalanceCurrent, borrowBalanceStored, exchangeRateStored, getCash, borrowFresh, repayBorrowFresh, repayBorrow, repayBorrowBehalf, accrueInterest, _setInterestRateModel, _setInterestRateModelFresh, _setReserveFactor, _setReserveFactorFresh, _reduceReserves, _reduceReservesFresh, admin, pendingAdmin, _setPendingAdmin, _acceptAdmin);</p>
</li>
<li>
<p>Test CEther contract functions   测试 CEther 合约函数:<br>
(getCashPrior, doTransferIn, doTransferOut, mintExplicit, mintFallback, redeemCTokens, redeemUnderlying, borrow, borrowFresh, repayBorrow, repayBorrowFresh, repayBorrowBehalf, addReserves);</p>
</li>
<li>
<p>Test Comptroller contract functions 测试Comptroller合约函数:<br>
(constructor, _setLiquidationIncentive, _setPriceOracle, _setCloseFactor, _setCollateralFactor, _supportMarket, liquidateBorrowAllowed, redeemVerify, liquidateCalculateAmountSeize, _setPauseGuardian, setting paused, liquidity, getAccountLiquidity, getHypotheticalAccountLiquidity, admin, pendingAdmin, _setPendingAdmin, _acceptAdmin);</p>
</li>
<li>
<p>Test CompoundLens contract functions 测试 CompoundLens 合约函数:<br>
(cTokenMetadata, cTokenMetadataAll, cTokenBalances, cTokenBalancesAll, cTokenUnderlyingPrice, cTokenUnderlyingPriceAll, getAccountLimits, governance, comp);</p>
</li>
<li>
<p>Test PriceOracleProxy contract functions 测试 PriceOracleProxy 合约函数:<br>
(constructor, getUnderlyingPrice);</p>
</li>
<li>
<p>Test Timelock contract functions 测试Timelock合约函数:<br>
(constructor, setDelay, setPendingAdmin, acceptAdmin, queueTransaction, cancelTransaction, executeTransaction, executeTransaction, queue and cancel empty);</p>
</li>
<li>
<p>Test InterestRateModel contract functions 测试 InterestRateModel 合约函数:<br>
(baseP025-slopeP20, jump rate tests, baseP05-slopeP45, isInterestRateModel, calculates correct borrow value, jump-rate);</p>
</li>
<li>
<p>Test CCompLikeDelegate contract functions  测试 CCompLikeDelegate 合约函数:<br>
(_delegateCompLikeTo);</p>
</li>
<li>
<p>Test Maximillion contract functions 测试Maximillion合约函数:<br>
(constructor, repayBehalf);</p>
</li>
<li>
<p>Test DAIInterestRateModelV3 contract functions 测试 DAIInterestRateModelV3 合约函数:<br>
(constructor, getBorrowRate, getSupplyRate);</p>
</li>
<li>
<p>Test Flywheel contract functions 测试飞轮合约函数:<br>
(_grantComp, getCompMarkets, _setCompSpeeds, updateCompBorrowIndex, updateCompSupplyIndex, distributeBorrowerComp, distributeSupplierComp, transferComp, claimComp, claimComp batch, harnessRefreshCompSpeeds, harnessSetCompSpeeds, harnessAddCompMarkets, updateContributorRewards, _setContributorCompSpeed).</p>
</li>
</ul>
<h1 id="测试范围-testing-scope">测试范围 (Testing Scope)</h1>
<p>The scope of testing focused on the following deployed contracts:<br>
测试范围集中在以下已部署的合约上：</p>
<figure data-type="image" tabindex="2"><img src="https://miro.medium.com/max/1286/1*NAz_LBdDsp1BTirY_JAwbQ.png" alt="" loading="lazy"></figure>
<h1 id="测试执行-testing-execution">测试执行 (Testing Execution)</h1>
<p>Prior to deployment and testing, Zpoken made two primary changes to the Compound protocol smart contracts:<br>
在部署和测试之前，Zpoken 对 Compound 协议智能合约进行了两项主要更改：</p>
<ul>
<li>
<p>The first change was made to the GRACE_PERIOD and MINIMUM_DELAY constants in <a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Timelock.sol">Timelock.sol</a>. The constants influence time limits for function execution in contracts. The changes were required as the Zpoken team conducted tests on live Neon network nodes and were not able to manipulate time and block numbers.<br>
对 <a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Timelock.sol">Timelock.sol</a> 中的 GRACE_PERIOD 和 MINIMUM_DELAY 常量进行了第一次更改。常量影响合约中函数执行的时间限制。由于 Zpoken 团队在实时 Neon 网络节点上进行了测试，并且无法操纵时间和块数，因此需要进行这些更改。</p>
</li>
<li>
<p>The second change adjusted the address of the external Comp contract in the <a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Comptroller.sol">Comptroller.sol</a> contract (via the function getCompAddress()).<br>
第二个改动调整了<a href="https://raw.githubusercontent.com/neon-smart-contract-dev/compound-finance/neon_test/contracts/Comptroller.sol">Comptroller.sol</a>中外部Comp合约的地址合约(通过函数 getCompAddress())。</p>
</li>
</ul>
<p>Once the contract adjustments were made, the Zpoken team deployed to Neon Devnet from the repository <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a> using the <strong><em>yarn deploy -n neon</em></strong> command.</p>
<p>合约调整完成后，Zpoken 团队从存储库 <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a> 部署到 Neon Devnet ) 使用 <strong><em>yarn deploy -n neon</em></strong> 命令。</p>
<p>Following the deployment, tests were run from the repository <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a>. To run the tests, the local Neon environment first needed to be configured and the private keys added to ~/.neon/neon. The command to run the tests was <strong><em>. start.sh</em></strong></p>
<p>部署之后，从存储库 <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a> 运行测试。要运行测试，首先需要配置本地 Neon 环境并将私钥添加到 ~/.neon/neon。运行测试的命令是 <strong><em>。开始.sh</em></strong></p>
<p>Tests were also run in the local Neon environment via Docker in the repository <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a>. The steps to conduct the test are as follows:</p>
<p>测试还通过存储库中的 Docker 在本地 Neon 环境中运行 <a href="https://github.com/neon-smart-contract-dev/compound-finance">neon-smart-contract-dev/compound-finance</a>。进行测试的步骤如下：</p>
<ol>
<li>
<p>Run a local Neon node using <a href="https://github.com/neonlabsorg/proxy-model.py">proxy-model.py</a><br>
使用 <a href="https://github.com/neonlabsorg/proxy-model.py">proxy-model.py</a> 运行本地 Neon 节点</p>
</li>
<li>
<p>Build the docker image using <strong><em>sudo docker build -t compound-protocol</em></strong><br>
使用 <strong><em>sudo docker build -t Compound-protocol</em></strong> 构建 docker 镜像</p>
</li>
<li>
<p>Run the container using <strong><em>sudo docker run -it — net=host compound-protocol</em></strong><br>
使用 <strong><em>sudo docker run -it --net=host Compound-protocol</em></strong> 运行容器</p>
</li>
</ol>
<p>Project deliverables include deployment and test scripts, as well as integration and unit tests. Deployment and test scripts can be accessed via the <a href="https://github.com/neon-smart-contract-dev/compound-finance">repository</a>. The integration and unit tests performed are available in a <a href="https://github.com/neon-smart-contract-dev/compound-finance/tree/neon_test/tests">GitHub repository</a> and can be run in a <a href="https://github.com/neon-smart-contract-dev/compound-finance/blob/neon_test/Dockerfile">Docker container</a> to re-play the testing scenarios.</p>
<p>项目可交付成果包括部署和测试脚本，以及集成和单元测试。可以点击 <a href="https://github.com/neon-smart-contract-dev/compound-finance">repository</a> 访问部署和测试脚本。执行的集成和单元测试可在 <a href="https://github.com/neon-smart-contract-dev/compound-finance/tree/neon_test/tests">GitHub 存储库</a> 中获得，并且可以在 <a href="https://github.com/neon-smart-contract-dev/compound-finance/blob/neon_test/Dockerfile">Docker 容器中运行</a>重现测试场景。</p>
<h1 id="发现-findings">发现 (Findings)</h1>
<p>Zpoken successfully deployed and tested the Compound protocol base contracts as well as swap pool. The deployment and associated tests indicated that Neon EVM is running correctly and is fully compatible with Ethereum with regards to running complex dApps like Compound. All integration and unit tests were passed. The contract deployment, logic, math, and functionality are working as expected by the Compound developer team. The only thing that could not be tested was the Compound Web Application due to the lack of the Compound API in public GitHub repositories.</p>
<p>Zpoken 成功部署并测试了 Compound 协议基础合约以及交换池。部署和相关测试表明，Neon EVM 运行正常，并且在运行 Compound 等复杂 dApp 方面与以太坊完全兼容。所有的集成和单元测试都通过了。合约部署、逻辑、数学和功能都按照 Compound 开发团队的预期工作。由于公共 GitHub 存储库中缺少 Compound API，唯一无法测试的是 Compound Web 应用。</p>
<p>Zpoken also identified two issues with the Neon platform:</p>
<p>Zpoken 还发现了 Neon 平台的两个问题：</p>
<ol>
<li>
<p>Deploying and testing the Compound contracts required support for RPC eth_accounts. The method has been implemented but there are errors that Neon Labs is currently addressing.<br>
部署和测试 Compound 合约需要支持 RPC eth_accounts。该方法已实施，但 Neon Labs 目前正在解决一些错误。</p>
</li>
<li>
<p>The multi-threaded execution of test scripts implemented in the original Compound tests is not supported by the Neon network. The tests were created for <a href="https://trufflesuite.com/ganache/">Ganache</a>, a personal Ethereum blockchain simulator, rather than a live node. Attempting to use multiple threads results in “nonce too low” errors. To avoid the error, each script should be run from a different deployer address. However, in tests that use multiple threads within a single test, the error cannot be avoided. The tests could not be run in these scenarios and were skipped.<br>
Neon 网络不支持多线程执行原 Compound 测试中实现的测试脚本。这些测试是为个人以太坊区块链模拟器 <a href="https://trufflesuite.com/ganache/">Ganache</a> 而不是实时节点创建的。尝试使用多个线程会导致“nonce too low”错误。为避免该错误，应从不同部署者地址运行每个脚本。但是，在单个测试中使用多个线程的测试中，错误是无法避免的。测试无法在这些场景中运行并被跳过。</p>
</li>
</ol>
<h1 id="结论-conclusion">结论 (Conclusion)</h1>
<p>It’s time for <strong>YOU</strong> to deploy your own smart contracts to Neon EVM. Make sure to share your Neon EVM feedback with us throughout the process. If you have any issues or need additional guidance, check out our <a href="https://docs.neon-labs.org/">Neon Docs</a> or reach out to a team member on <a href="https://discord.com/invite/9jVYEDVwn8">Discord</a>. We know that you’ll create something great!</p>
<p>现在是 <strong>您</strong> 将您自己的智能合约部署到 Neon EVM 的时候了。确保在整个过程中与我们分享您对 Neon EVM 的反馈。如果您有任何问题或需要额外指导，请查看我们的 <a href="https://docs.neon-labs.org/">Neon Docs</a> 或通过 <a href="https://discord.com">Discord</a> 联系团队。我们知道你会创造出伟大的东西！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[探索Fuel虚拟机(FuelVM)-Exploring the FuelVM]]></title>
        <id>https://chainguys.github.io/post/tan-suo-fuel-xu-ni-ji-fuelvm-exploring-the-fuelvm/</id>
        <link href="https://chainguys.github.io/post/tan-suo-fuel-xu-ni-ji-fuelvm-exploring-the-fuelvm/">
        </link>
        <updated>2022-10-20T01:40:18.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/0*Wp6jt8fQD2RkhhB0.png" alt="" loading="lazy"></figure>
<hr>
<h1 id="版权提示-copyright-notice">版权提示 (Copyright Notice)</h1>
<p>Thanks to the great article <a href="https://medium.com/blockchain-capital-blog/exploring-the-fuelvm-86cf9ccdc159">Exploring the FuelVM</a> by <a href="https://twitter.com/sproule_">Ryan Sproule</a> ,we could deeply explore the Fuel Project in an easy way.</p>
<p>感谢这篇杰出的文章： <a href="https://medium.com/blockchain-capital-blog/exploring-the-fuelvm-86cf9ccdc159">探索Fuel虚拟机(FuelVM)-Exploring the FuelVM</a>(作者为 <a href="https://twitter.com/sproule_">Ryan Sproule</a>)让我们能深入浅出地了解 <a href="https://twitter.com/fuellabs_">Fuel</a>项目。</p>
<p><em>This translation is a personal work</em> by <a href="https://twitter.com/fuellabs_">Fuel</a> enthusiast <a href="https://twitter.com/Chainguys">@Chainguys</a> , with permission from the author. <strong>The author reserves the right of final explanation</strong>. <strong>This translation should NEVER EVER be regarded as any types or forms of Financial Advice</strong></p>
<p><em>本翻译为 <a href="https://twitter.com/fuellabs_">Fuel</a>爱好者<a href="https://twitter.com/Chainguys">@Chainguys</a>的个人作品，已经过作者本人授权。<strong>作者享有最终解释权</strong></em>。<strong>本作品不应被视为任何形式的财务投资建议</strong></p>
<hr>
<h1 id="sway-和-fuelvm初探-introducing-sway-and-the-fuelvm">Sway 和 FuelVM初探 (Introducing Sway and the FuelVM)</h1>
<p>Fuel Labs is building a novel execution layer for scaling the next generation of blockchain applications. The FuelVM is designed to be modular — it can plug in as the execution engine for any blockchain. Primarily, the FuelVM will be deployed as a Layer 2 rollup on Ethereum, but in theory, it can be deployed anywhere as an L2 or even as another L1. The FuelVM is designed to scale Ethereum without increasing the node requirements but rather by getting <em>more</em> out of the existing hardware.</p>
<p>Fuel Labs 正在构建一个全新的执行层，用于扩展下一代区块链应用。 FuelVM 被设计成模块化的——它可以作为任何区块链的执行引擎插入。首先，FuelVM 将作为layer2汇总，部署在以太坊上，但理论上，它可以作为 L2 甚至作为另一个 L1 部署在任何地方。 FuelVM 旨在在不增加节点要求的情况下扩展以太坊，即从现有硬件中获得更多。</p>
<p>Fuel Labs is also building a novel DSL for writing contracts for the FuelVM called Sway. Sway is inspired by both Rust and Solidity to create the ideal smart contract programming language.</p>
<p>Fuel Labs 还在构建一种全新的 DSL，用于为 FuelVM 编写合约，称为 Sway。 Sway 受到 Rust 和 Solidity 的启发，创建了理想的智能合约编程语言。</p>
<h1 id="什么是-fuelvmwhat-is-the-fuelvm">什么是 FuelVM？(What is the FuelVM?)</h1>
<p>The FuelVM is a fully purpose-built, custom virtual machine for executing smart contracts. Designed from the start to be easily fraud-provable, the Fuel VM can be used as the transaction execution layer for an optimistic rollup.</p>
<p>FuelVM 是一个完全专用的定制虚拟机，用于执行智能合约。 Fuel VM 从一开始就设计为易于欺诈证明的，可用作乐观汇总的交易执行层。</p>
<p>The FuelVM is optimized to better utilize hardware to increase the throughput of transaction execution. Concretely, it is UTXO based and forces every transaction to explicitly define the UTXOs that it will touch. Since the execution engine can identify exactly what state every transaction touches, it is able to trivially find the transactions that are not contentious and parallelize them.</p>
<p>FuelVM 经过优化，可以更好地利用硬件来提高交易执行的吞吐量。具体来说，它是基于 UTXO 的，并强制每笔交易明确定义它将触及的 UTXO。由于执行引擎可以准确识别每个交易涉及的状态，因此它能够轻松找到没有争议的交易并将它们并行(执行)。</p>
<p>You can read the full FuelVM spec <a href="https://github.com/FuelLabs/fuel-specs">here</a> or watch John Adler’s video run-through <a href="https://youtu.be/GKNuaFcPaXc">here</a>.</p>
<p>您可以阅读完整的 FuelVM 规范 <a href="https://github.com/FuelLabs/fuel-specs">此处</a> 或观看 John Adler 的视频演示 <a href="https://youtu.be/GKNuaFcPaXc">此处</a>。</p>
<h1 id="为什么虚拟机如期重要why-does-the-vm-matter">为什么虚拟机如期重要？Why does the VM matter?</h1>
<p>In a smart contract blockchain system, the VM is the system that can understand smart contract code and execute state transitions based on the rules defined in this code. <em>The VM is the operating system for the smart contract blockchain.</em></p>
<p>在智能合约区块链系统中，虚拟机(VM)是能够理解智能合约代码并根据该代码中定义的规则执行状态转换的系统。 <em>VM是智能合约区块链的操作系统。</em></p>
<p>As of today, smart contract VMs have not iterated much beyond the initial versions presented in Ethereum. All widely used smart contract chains (bar Solana) today are using the same VM as Ethereum: the EVM.</p>
<p>截至今天，智能合约虚拟机的迭代并没有超出以太坊中提供的初始版本。今天所有广泛使用的智能合约链(除了Solana)都使用与以太坊相同的VM：EVM。</p>
<p>In today’s world, the EVM is “good enough” because the main bottleneck of scaling is not the rate at which transactions are executed, but rather the bandwidth that the consensus engine can support (blockspace). With the progression of layer 2 scaling solutions and DA solutions like Celestia, EIP-4844, Danksharding, and EigenDA, the cost of posting rollup transaction data to L1 will no longer be the primary constraint.</p>
<p>在当今世界，EVM 已经“足够好”，因为扩展的主要瓶颈不是交易执行的速度，而是共识引擎可以支持的带宽(区块空间)。随着layer2扩展解决方案和 DA 解决方案(如 Celestia、EIP-4844、Danksharding 和 EigenDA)的发展，将汇总交易数据发布到 L1 的成本将不再是主要限制因素。</p>
<p>In this imminent environment where bandwidth is cheap, the next bottleneck will be computational throughput: how fast a system can execute transactions while keeping the underlying hardware requirements <em>low enough</em> for sufficient decentralization. The FuelVM has the advantage of being designed with these considerations for the future in mind and can optimize accordingly.</p>
<p>在这个带宽便宜的迫在眉睫的环境中，下一个瓶颈将是计算吞吐量：系统可以多快执行交易，同时保持底层硬件要求 <em>足够低</em> ，进而实现足够的去中心化。 FuelVM 的优点是在设计时考虑到了这些考虑因素，并且可以相应地进行优化。</p>
<h1 id="fuelvm-的优势-fuelvms-differentiators">FuelVM 的优势 (FuelVM’s Differentiators)</h1>
<h2 id="执行-验证并行化-execution-validation-parallelization">执行 + 验证并行化 (Execution + Validation Parallelization)</h2>
<p>The secret behind the FuelVM’s parallelizable virtual machine is its <em>strict access lists —</em> which require users (in reality, clients or wallets) to indicate which contract(s) their transaction will touch. It is helpful to inspect what exactly makes up a transaction in the FuelVM.</p>
<p>FuelVM 可并行化虚拟机背后的秘密在于它的 <em>严格访问列表——</em> 要求用户(实际上是客户端或钱包)指明他们的交易将触及哪些合约。检查 FuelVM 中事务的确切组成是很有帮助的。</p>
<ul>
<li>
<p><strong>Inputs</strong>: list of all contract UTXOs that the transaction will touch + data to unlock the UTXO or predicate script.<br>
<strong>输入</strong>：交易将触及的所有合约 UTXO 的列表 + 用于解锁 UTXO 或谓词脚本的数据。</p>
</li>
<li>
<p><strong>Outputs</strong>: define the UTXOs that will be created<br>
<strong>输出</strong>：定义将被创建的 UTXO</p>
</li>
<li>
<p><strong>Gas Information</strong>: gas price + gas limits<br>
<strong>Gas 信息</strong>：Gas 价格 + Gas 限制</p>
</li>
<li>
<p><strong>Witnesses</strong>: metadata + digital signature for authorization<br>
<strong>见证人</strong>：元数据+授权数字签名</p>
</li>
</ul>
<p>The critical point here is the explicit “inputs” list, which lists all the UTXOs that will be consumed. This includes “special” contract UTXOs. If, before executing any code, the VM is able to tell which contracts a transaction will touch, it can safely execute all other non-contentious state-accessing transactions in parallel.</p>
<p>这里的关键点是明确的“输入”列表，它列出了所有将被消耗的 UTXO。这包括“特殊”合约 UTXO。如果在执行任何代码之前，VM 能够判断交易将触及哪些合约，它就可以安全地并行执行所有其他无争议的状态访问交易。</p>
<figure data-type="image" tabindex="2"><img src="https://miro.medium.com/max/4000/1*1avkHndlTD9RhwMMYBaL7w.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://miro.medium.com/max/4000/1*nIXbEQkuMQ2p2g5GF-R9IQ.png" alt="" loading="lazy"></figure>
<p>Both transaction execution and validation can take advantage of parallelism (validation can to an even greater extent).</p>
<p>交易执行和验证都可以利用并行性(验证可以在更大程度上利用)。</p>
<p>Notice that since transaction outputs are explicitly included for validation, in the process of asserting that a block that another node proposed was correct, there is no need to execute the overlapping transactions sequentially. This means that validation can happen fully in parallel regardless of state contention. In practice, this means that when nodes are syncing the network, they can achieve even greater parallelization and can catch up faster.</p>
<p>请注意，由于交易输出被明确包含用于验证，因此在判别另一个节点提出的块是否正确的过程中，不需要顺序执行重叠的交易。这意味着无论状态争用如何，验证都可以完全并行进行。在实践中，这意味着当节点同步网络时，它们可以实现更大的并行化，并且可以更快地赶上。</p>
<h2 id="原生资产系统-native-asset-system">原生资产系统 (Native Asset System)</h2>
<p>In the EVM, there is one native asset: ETH. All other assets are implemented via a smart contract that handles accounting for balances (ERC20). In Fuel, developers are free to implement assets in smart contracts, BUT, there is an option to allow the VM to handle this natively.</p>
<p>在 EVM 中，有一种原生资产：ETH。所有其他资产都是通过处理余额会计的智能合约 (ERC20) 实现的。在 Fuel 中，开发人员可以自由地在智能合约中实现资产，但是，有一个选项允许 VM 进行本地处理。</p>
<p>There are a few considerable advantages to native assets over an ERC20-style smart contract for balance management. First, native asset manipulation is cheaper (in terms of gas) than manipulating state in a smart contract. This can be attributed to its running at lower-level primitives (UTXO system is used instead of manipulating storage). Second, native assets have better UX, similar to how sending ETH is much simpler than sending ERC20s (no need for setting approvals).</p>
<p>与 ERC20 风格的智能合约相比，原生资产在余额管理方面有一些相当大的优势。首先，原生资产操作(就gas而言)比在智能合约中操纵状态更便宜。这可以归因于它在较低级别的语言上运行(使用 UTXO 系统而不是操纵存储)。其次，原生资产具有更好的用户体验，类似于发送 ETH 比发送 ERC20 简单得多(无需设置批准)。</p>
<h2 id="本地帐户抽象-谓词-native-account-abstraction-predicates">本地帐户抽象 + 谓词 (Native Account Abstraction + Predicates)</h2>
<p>Account abstraction has been a hot topic of research and several attempts have been made at EIPs (<a href="https://eips.ethereum.org/EIPS/eip-86">EIP-86</a>, <a href="https://eips.ethereum.org/EIPS/eip-2938">EIP-2938</a>, <a href="https://eips.ethereum.org/EIPS/eip-3074">EIP-3074</a>, <a href="https://eips.ethereum.org/EIPS/eip-4337">EIP-4337</a>, <a href="https://eips.ethereum.org/EIPS/eip-5003">EIP-5003</a>) over the years in the Ethereum community. It is difficult to implement and upgrade Ethereum to support account abstraction primarily because of the engineering bandwidth of core teams/technical debt plus the associated complexity, and a long list of higher priority items. Many rollups have the opportunity to implement account abstraction from the start on their novel execution environments. Among these is the FuelVM, which, in addition to native account abstraction, will also include an interesting new primitive: predicates.</p>
<p>帐户抽象一直是研究的热门话题，并且EIP (<a href="https://eips.ethereum.org/EIPS/eip-86">EIP-86</a>、<a href="https://eips.ethereum.org/EIPS/eip-2938">EIP-2938</a>、<a href="https://eips.ethereum.org/EIPS/eip-3074">EIP-3074</a>、<a href="https://eips.ethereum.org/EIPS/eip-4337">EIP-4337</a>, <a href="https://eips.ethereum.org/EIPS/eip-5003">EIP-5003</a>) 多年来在以太坊社区中有所应用。但很难实施和升级以太坊来支持帐户抽象，主要是因为核心团队的工程带宽/技术债务加上相关的复杂性，以及一长串更高优先级项目。许多汇总有机会从一开始就在全新的执行环境中实现帐户抽象。其中包括 FuelVM，除了原生帐户抽象之外，它还将包括一个有趣的新原语：谓词。</p>
<figure data-type="image" tabindex="4"><img src="https://miro.medium.com/max/1360/1*_AYV990rgjSyaGYa-VpkQw.png" alt="" loading="lazy"></figure>
<p>meme原始地址 (meme credit): <a href="https://twitter.com/fueldrinker69/status/1582439702069551109?s=20&amp;t=HJJ_ZwWw8x8f83NLxeo5uw">https://twitter.com/fueldrinker69/status/1582439702069551109?s=20&amp;t=HJJ_ZwWw8x8f83NLxeo5uw</a></p>
<p>A predicate is a pure (does not access state) contract script that simply returns a boolean (true or false). UTXOs can be locked behind a predicate so they can only be spent whenever the conditions defined in the predicate are met. This leads to an interesting UX opportunity where users can set a transaction to execute only under certain conditions, and then once the predicate is met, their transaction can automatically execute. Also, predicates can be pruned when they are destroyed, so they do not contribute to state bloat.</p>
<p>谓词是一个纯粹的(不访问状态)合约脚本，它只返回一个布尔值(真或假)。 UTXO 可以锁定在谓词后面，因此只有在满足谓词中定义的条件时才能使用它们。这带来了一个有趣的 UX 机会，用户可以将交易设置为仅在特定条件下执行，然后一旦满足谓词，他们的交易就可以自动执行。此外，谓词在销毁时可以被修剪，因此它们不会导致状态膨胀。</p>
<blockquote>
<p><em>Trivial demonstrative example: User sets a transaction to buy X tokens whenever the price meets the threshold defined in the predicate. Voila, the pièce de résistance, fully on chain trustless limit orders that won’t bloat the state!</em></p>
<p><em>小示范示例：只要价格达到谓词中定义的阈值，用户就会设置交易来购买 X 个代币。瞧，一点抵抗力量，完全在链上，不会使状态膨胀的去信任化限价订单！</em></p>
</blockquote>
<h2 id="多维资源定价-multi-dimensional-resource-pricing">多维资源定价 (Multi-dimensional Resource Pricing)</h2>
<p>Resource pricing is one of the most critical components of a smart contract blockchain. Decentralization is maintained by keeping the resource requirements of the chain at reasonable, affordable levels. Resource pricing allows the system to charge users for consuming “work” from the nodes in the network.</p>
<p>资源定价是智能合约区块链最关键的组成部分之一。通过将链的资源需求保持在合理、可负担的水平来维持去中心化。资源定价允许系统向用户收取从网络节点消耗“工作”的费用。</p>
<p>In the EVM, one of the most common reasons for the introduction of EIPs has been for opcode re-pricing. This is inherent to the fact that opcodes have hardcoded gas prices, and <strong>the underlying price of resources do not scale proportionally to each other (historically, CPUs improve more rapidly than SSDs)</strong>. Ideally, these systems would be able to price each resource completely independently, so that the entire fee system can dynamically adjust for the underlying hardware system changes.</p>
<p>在 EVM 中，引入 EIP 的最常见原因之一是操作码重新定价。这是操作码硬编码gas价格所固有的，并且<strong>资源的基础价格彼此之间不成比例(从历史上看，CPU 的改进速度比 SSD 快)</strong>。理想情况下，这些系统将能够完全独立地对每个资源进行定价，以便整个收费系统可以针对底层硬件系统的变化进行动态调整。</p>
<p>The FuelVM will be able to implement dynamic multi-resource pricing that can incentivize node runners to optimize their underlying hardware better while still optimizing for the maximum “utility per block.”</p>
<p>FuelVM 将能够实现动态多资源定价，可以激励节点运行者更好地优化其底层硬件，同时仍然优化最大“每块效用”。</p>
<figure data-type="image" tabindex="5"><img src="https://miro.medium.com/max/1400/1*bLvTVR8HlGdSYIgoZvd8AQ.png" alt="" loading="lazy"></figure>
<p>This drawing demonstrates a situation where one smart contract has significantly higher demand than others. With localized resource pricing, other contracts are not impacted to the same extent. An NFT drop is a good example of this. This is not <em>exactly</em> how it works with resource pricing vs contract pricing (proposed Solana style), but the effect is very similar. A smart contract with a specific resource profile will be priced differently than another contract. For the NFT drop example, the hot contract might have a resource profile that is very storage intensive but very computationally cheap. Smart contracts that have high compute requirements relative to storage would not be as impacted by the noisy NFT drop.</p>
<p>该图展示了一种智能合约的需求明显高于其他智能合约的情况。通过本地化资源定价，其他合约不会受到同样程度的影响。 NFT投放/落地就是一个很好的例子。这与资源定价与合约定价(提议的 Solana 风格)不完全一样，但效果非常相似。具有特定资源配置文件的智能合约的定价将与另一个合约不同。对于 NFT 投放示例，有热度的合约可能具有非常存储密集但计算成本非常低的资源配置文件。相对于存储具有高计算要求的智能合约不会受到嘈杂的 NFT投放/落地的影响。</p>
<p>The Solana strategy of breaking the fee markets on accounts or contracts adds a layer of abstraction between the actual underlying resources and the demand for them. This means that there can still be situations where fees are very low, but the strain on the nodes is very high. For example, there can be an extremely high storage load on the system because of an event where, for example, many different NFTs are being minted simultaneously, but the fees are very low because not all this traffic is happening on a single account. The per-account fee model does solve the hot partition problem for accounts but leaves scenarios where the system is not correctly pricing underlying resources, so it can still lead to failures.</p>
<p>Solana 打破账户或合约费用市场的策略，在实际基础资源和对它们的需求之间增加了一层抽象。这意味着仍然可能存在费用非常低，但节点压力非常大的情况。例如，系统上的存储负载可能非常高，例如同时铸造了许多不同的 NFT，但费用却非常低，因为并非所有这些流量都发生在一个帐户上。每账户费用模型确实解决了账户的热分区问题，但留下了系统没有正确定价底层资源的情况，因此仍然可能导致失败。</p>
<p>It is simply cleaner and more accurate to price the system based on the underlying hardware resources instead of trying to add a network-specific abstraction layer like accounts to base the multi-market resource pricing on.</p>
<p>根据底层硬件资源为系统定价更简洁、更准确，而不是尝试添加一个特定于网络的抽象层(如帐户)来作为多市场资源定价的基础。</p>
<h2 id="状态膨胀注意事项-state-bloat-considerations">状态膨胀注意事项 (State-bloat Considerations)</h2>
<p>As mentioned multiple times by the geth team, the current bottleneck in geth is with I/O for state read and write access. Initially, the idea was that 100% of the state Merkle-Patricia-trie (MPT) would fit on the RAM of a standard device. This is not the case anymore as the state has grown to over 900 GB and is expected to grow approx 50–100 GB per year, which is unreasonably large for anyone to fit in RAM, so most nodes have turned to SSDs to store state. Historically, SSDs do not improve as quickly as the state size is growing, so this cost will continue to impact the decentralization of the network. This is a critical problem that <a href="https://hackmd.io/@vbuterin/state_size_management">Ethereum researchers have been discussing for some time.</a></p>
<p>正如 geth 团队多次提到的，当前 geth 的瓶颈在于状态读写访问的 I/O。最初的想法是标准设备的 RAM去与 100% 的状态 Merkle-Patricia-trie (MPT) 适配。现在情况已不再如此，因为状态已增长到超过 900 GB，并且预计每年将增长约 50-100 GB，这对于任何人来说都无法期容纳在 RAM 中，因此大多数节点都转向 SSD 来存储状态。从历史上看，SSD 的改进速度不会随着状态规模的增长而迅速提高，因此这种成本将继续影响网络的去中心化。这是 <a href="https://hackmd.io/@vbuterin/state_size_management">以太坊研究人员已经讨论了一段时间的关键问题。</a></p>
<p>The FuelVM is instead being constructed with this problem front of mind. There have been a couple of talks by Fuel Labs’ co-founder, John Adler, about the role resource pricing plays in the way that state or other resources are consumed by smart contracts. By a combination of appropriate resource pricing and a more clear data model for state pruning with the UTXO system, the FuelVM will be able to keep the state under control, reducing the cost of running a node, which is equivalent to increasing the decentralization of the network.</p>
<p>FuelVM 是在考虑这个问题的前提下构建的。 Fuel Labs 的联合创始人 John Adler 就资源定价在智能合约消耗状态或其他资源的方式中所起的作用，进行了几次会谈。通过适当的资源定价和更清晰的状态剪枝数据模型与 UTXO 系统相结合，FuelVM 将能够控制状态，降低运行节点的成本，这相当于增加了节点的去中心化程度。</p>
<h2 id="序列器的去中心化-decentralization-of-the-sequencer">“序列器”的去中心化 (Decentralization of the “sequencer”)</h2>
<p>Although Layer 2s allow us to offload computation effort from the main chain, they still need to provide a mechanism to order transactions. Many layer 2 solutions are launching with what has been referred to as the “sequencer”. The sequencer is a privileged node that is responsible for ordering transactions, executing state transitions, and then submitting the state root update along with compressed transaction information to Layer 1 Ethereum. It is obvious, but notable, that a single super-computer responsible for sequencing can execute more transactions per epoch than a multitude of smaller computers redundantly executing the same sequence of transactions.</p>
<p>尽管layer2允许我们从主链上卸去计算工作，但它们仍然需要提供一种机制来对交易进行排序。许多layer2解决方案都使用所谓的“序列器”启动。序列器是一个特权节点，负责对交易进行排序、执行状态转换，然后将状态根更新连同压缩的交易信息一起提交到layer1以太坊。很明显，但值得注意的是，一台负责排序的超级计算机每个时期可以执行更多的交易，而不是多个小型计算机冗余地执行相同交易序列。</p>
<p><strong>There are several key problems with this centralized sequence role that needs to be getting more attention!</strong></p>
<p><strong>这个中心化的排序角色有几个关键问题需要引起更多关注！</strong></p>
<ol>
<li>
<p>Controlling the ordering of transactions is very profitable. We have observed in Ethereum and other blockchains that MEV is one of the main sources of income for those who order blocks. A single party controlling ordering and MEV capture eventually leads to worse execution for users as we see in traditional finance today.<br>
控制交易的顺序是非常有利可图的。我们在以太坊和其他区块链中观察到，MEV 是订购区块的人的主要收入来源之一。正如我们今天在传统金融中看到的那样，单方控制订购和 MEV 捕获最终会导致用户执行更差。</p>
</li>
<li>
<p>A centralized sequencer can be a single point of failure both from an availability and regulatory perspective. If a single or a small number of organizations are running sequencers they can go down or be taken down. This is a liveness risk to the network.<br>
从可用性和监管角度来看，中心化序列器可能是单点故障。如果单个或少数组织正在运行序列器，它们可能会关闭或被劫持。这对网络来说是一个活跃的风险。</p>
</li>
<li>
<p>A centralized sequencer may censor transactions on the Layer 2. The sequencer gets to choose whatever transactions and place them in any order during the construction of a block, this leads to the ability to censor. In fairness, many L2s handle this case by providing “forced transaction” mechanisms, which allow users to bypass the sequencer and directly get transactions included by leveraging the L1.<br>
中心化序列器可以审查layer2上的交易。序列器可以选择任何交易并在构建块期间以任何顺序放置，这导致了审查的能力。公平地说，许多 L2 通过提供“强制交易”机制来处理这种情况，该机制允许用户绕过序列器并通过利用 L1 直接获取包含的交易。</p>
</li>
<li>
<p>Sequencers can make inconsistent promises about the state of the chain to users of the rollup. This is often referred to as equivocation, which basically means that the sequencer can make a misleading promise about some state of the L2. This comes from the fact that fast finality on the rollup is a trusted step, a sequencer can abuse this trust that leads users to do things they do not intend.<br>
序列器可以对汇总的用户做出链状态不一致承诺，通常被称为模棱两可，这基本上意味着序列器可以对 L2 的某些状态做出误导性的承诺。这源于这样一个事实，即汇总的快速确定性是一个值得信赖的步骤，序列器可以滥用这种信任，导致用户做他们不想做的事情。</p>
</li>
</ol>
<h2 id="fuel如何解决这些问题-how-does-fuel-solve-these-problems">Fuel如何解决这些问题？ (How does Fuel solve these problems?)</h2>
<p>First of all, Fuel is not just a rollup or an L1 blockchain, rather, it is a system that simply applies state transitions that <em>can</em> be posted to an L1 if configured as a rollup or operate in a network to achieve consensus as an L1. The key difference is that the Fuel execution engine does not care about consensus or transaction ordering. Fuel is only responsible for applying the transactions as quickly as possible. <strong>But</strong>, since Fuel can run on such light hardware and verification is so cheap, it is plausible that Fuel can bootstrap a diverse and decentralized consensus network that does do consensus for much cheaper than an equivalent system running a less performant execution engine like the EVM.</p>
<p>首先，Fuel 不仅仅是一个汇总或 L1 区块链，相反，它是一个简单地应用状态转换的系统，如果配置为 汇总或在网络中运行来实现 L1 的共识，就可以将其发布到 L1。关键区别在于 Fuel 执行引擎不关心共识或交易顺序。 Fuel只负责尽快应用交易。 <strong>但是</strong>，由于 Fuel 可以在如此轻量级的硬件上运行并且验证非常便宜，因此以下内容就变得合理起来： Fuel 可以引导一个多样化和去中心化的共识网络，该网络实现共识确实以比运行性能较低执行引擎的同等系统(如EVM)要便宜得多。</p>
<p>Additionally, the Fuel team is thinking about layer 2 tokenomics with decentralization, MEV, and these other considerations in mind. Fuel co-founder, John Adler, wrote a post on <a href="https://fuel-labs.ghost.io/token-model-layer-2-block-production/">a token model for layer-2 blockchains</a> in January that lays out a design for a token that helps decentralize block production by allowing rollups <strong>to tokenize block space scarcity through the right to collect fees as a block producer.</strong> Fee collection is only one portion of the income for block producers, as we have seen in other chains, MEV is another large portion of the income. Similarly to block space scarcity, MEV income will <em>also</em> be tokenized via the right to produce blocks.</p>
<p>此外，Fuel 团队正在考虑去中心化、MEV 和其他因素的layer2代币经济学。 Fuel 联合创始人 John Adler 在 1 月份写了一篇关于 <a href="https://fuel-labs.ghost.io/token-model-layer-2-block-production/">layer2区块链的代币模型</a> 的帖子,它设计了一种代币(模型)，该代币通过允许汇总**作为区块生产者收取费用的权利，来标记区块空间的稀缺性，进而帮助分散区块生产。**收费只是区块生产者收入的一部分，因为我们在其他链中看到，MEV 是收入的另一大部分。与区块空间的稀缺性类似，MEV 收入也将通过生产区块的权利进行代币化。</p>
<h2 id="状态模型utxo-vs-基于账户-the-state-model-utxo-vs-account-based">状态模型：UTXO vs 基于账户 (The State Model: UTXO vs Account Based)</h2>
<p>The best way to conceptualize the difference between the UTXO data model and the account model is as follows: UTXOs can be likened to cash bills, whereas the account model is more similar to a bank ledger. Account systems naturally lead to hot pieces of state because every transaction is trying to access the same account, while the UTXO, if designed correctly, is less contentious. This characteristic enables better parallelization and also can prevent state bloat by simplifying the process of state pruning.</p>
<p>概念化 UTXO 数据模型和账户模型之间差异的最佳方法如下：UTXO 可以比作现金票据，而账户模型更类似于银行账本。账户系统自然会导致热点状态，因为每笔交易都试图访问同一个账户，而 UTXO，如果设计得当，争议较小。这个特性可以实现更好的并行化，也可以通过简化状态修剪的过程来防止状态膨胀。</p>
<figure data-type="image" tabindex="6"><img src="https://miro.medium.com/max/4000/1*sjfvqbqpQT_MLCe_HsPhNg.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://miro.medium.com/max/4000/1*daR6MsOjX5wPl5BRyypIpA.png" alt="" loading="lazy"></figure>
<p>Sticking with the cash vs. bank ledger metaphor, it becomes clear why parallelization can tend to be much easier with UTXO. 2 cash transactions can happen at the same time and they don’t need to have any knowledge of each other, while if there were to be 2 account updates on a ledger, both transactions would have to update the same shared ledger.</p>
<p>坚持现金与银行分类账的比喻，很明显为什么使用 UTXO 可以更容易地实现并行化。 2 笔现金交易可以同时发生，它们不需要相互了解，而如果分类账上有 2 个账户更新，则两个交易都必须更新同一个共享分类账。</p>
<h1 id="虚拟机大战-the-vm-wars">虚拟机大战 (The VM Wars)</h1>
<p>Other teams, beyond Fuel, are working on next-generation virtual machines for smart contract blockchains such as Mysten Labs and Aptos, who are working with the MoveVM that was originally designed by engineers at Facebook as part of the Libra project. This further bolsters the thesis that there is demand for novel execution environments in order to support the next generation of blockchain applications. All of these projects have interesting approaches and make different trade-offs.</p>
<p>除了 Fuel 之外，其他团队正在开发用于智能合约区块链的下一代虚拟机，例如 Mysten Labs 和 Aptos，他们正在使用最初由 Facebook 工程师设计的 MoveVM(最初作为 Libra 项目的一部分)。这进一步支持了需要新型执行环境来支撑下一代区块链应用的论点。所有这些项目都有有趣的方法并做出不同的权衡。</p>
<p>In the years that the MoveVM sat stagnant when Libra was busy fighting legal battles, a lot changed in the crypto world. Fuel was able to adapt to those changes and stay agile in an extremely fast-paced industry, while Move fell slightly behind. That being said, since Move has spun out of Facebook and new large financing rounds have been completed, they are certainly getting ready to go to war!</p>
<p>在 Libra 忙于打官司，MoveVM 停滞不前的几年里，加密世界发生了很大变化。 Fuel 能够适应这些变化并在这个快节奏的行业中保持敏捷，而 Move 则略微落后。话虽如此，既然 Move 已经从 Facebook 分拆出来，并且新一轮的大额融资已经完成，他们肯定已经做好了开战的准备！</p>
<figure data-type="image" tabindex="8"><img src="https://miro.medium.com/max/400/0*jeQ293mTqR91ylk3" alt="" loading="lazy"></figure>
<h1 id="结论-conclusion">结论 (Conclusion)</h1>
<ul>
<li>
<p>Unlike other L2s, Fuel has plans to decentralize the sequencer role from the start by designing the VM so that expensive hardware is not required to increase scale.<br>
与其他 L2 不同，Fuel 计划从一开始就通过设计虚拟机来分散序列器的角色，这样就不需要昂贵的硬件来扩大规模。</p>
</li>
<li>
<p>Fuel is flexible. It can be deployed in many environments, but the priority is to be Ethereum aligned as an Optimistic Rollup.<br>
Gas是灵活的。它可以部署在许多环境中，但优先级是作为乐观汇总与以太坊对齐。</p>
</li>
<li>
<p>Fuel’s UX will be much better than the EVM’s because of native and novel ways of interacting with the chain, such as account abstraction, scripts, and predicates.<br>
由于与链交互的原生和新颖的方式，例如帐户抽象、脚本和谓词，Fuel 的用户体验将比 EVM 好得多。</p>
</li>
<li>
<p>The UTXO data model is naturally less contentious than the account data model and will lead to more parallelism AND less state bloat.<br>
UTXO 数据模型自然比账户数据模型更少争议，并且会导致更多并行(处理)和更少的状态膨胀。</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[@camiinthisthang长推-20221019(@camiinthisthang twitter threads-20221019)]]></title>
        <id>https://chainguys.github.io/post/camiinthisthang-chang-tui-20221019camiinthisthang-twitter-threads-20221019/</id>
        <link href="https://chainguys.github.io/post/camiinthisthang-chang-tui-20221019camiinthisthang-twitter-threads-20221019/">
        </link>
        <updated>2022-10-20T01:30:32.000Z</updated>
        <content type="html"><![CDATA[<p>原文地址:<a href="https://twitter.com/camiinthisthang/status/1582408630443180035">https://twitter.com/camiinthisthang/status/1582408630443180035</a></p>
<p>Machismo, Inflation, Remittance: Scaling Ethereum to Widespread Adoption in LATAM</p>
<p>大男子主义、通货膨胀、汇款：扩展以太坊以在拉丁美洲得到广泛采用重新创新第 2 层，但更擅长 <a href="https://twitter.com/fuellabs_">@fuellabs_</a></p>
<p>My most recent talk from<a href="https://twitter.com/EFDevcon">@EFDevcon</a>as a thread</p>
<p>我最近来自 <a href="https://twitter.com/EFDevcon">@EFDevcon</a> 的谈话作为一个长推</p>
<p>A pragmatic perspective on the social and technical pieces missing and how we're innovating a layer 2 but better at<a href="https://twitter.com/fuellabs_">@fuellabs_</a></p>
<p>关于缺少的社交和技术部分以及我们如何创新layer2但更 <a href="https://twitter.com/fuellabs_">@fuellabs_</a> 的务实观点却更好</p>
<p>First, a look at the current state of the industry. When building a product, you want to solve a big problem for many people. Right now, crypto sits in the quadrant of solving a small problem for a few people.</p>
<p>首先，看一下行业的现状。在构建产品时，您想为许多人解决一个大问题。目前，加密货币处于为少数人解决小问题的象限。</p>
<figure data-type="image" tabindex="1"><img src="https://pbs.twimg.com/media/FfXYRJoVUAATSxM?format=jpg&amp;name=medium" alt="" loading="lazy"></figure>
<p>As an industry, we're all working towards identifying killer use cases for crypto that unlock functionality and coordination not previously available. I deeply respect everyone working in this industry, and this is not a knock on our work, but this is just today's reality.</p>
<p>作为一个行业，我们都在努力确定加密的杀手级用例，进而解锁以前不可用的功能和协作。我非常尊重在这个行业工作的每一个人，这不是对我们工作的打击，但这只是今天的现实。</p>
<figure data-type="image" tabindex="2"><img src="https://pbs.twimg.com/media/FfXYRuSUcAAo-N0?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://twitter.com/camiinthisthang/status/1582408652727517187/photo/1" alt="" loading="lazy"></figure>
<p>We want to solve a big problem for a lot of people. How do we get there? Not from a theoretical pov, but what are the tactical steps we need to execute to get here?</p>
<p>我们想为很多人解决一个大问题。我们怎么实现？不是从理论上的观点出发，而是我们需要执行哪些战术步骤才能到达这里？</p>
<figure data-type="image" tabindex="4"><img src="https://pbs.twimg.com/media/FfXYSbeUAAcCw3j?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>In this talk, I point out the three most pressing issues we can address NOW. These are probably obvious, but <em>how</em> exactly do we address these issues to empower both developers and end users to build and use novel applications?</p>
<p>在这次演讲中，我指出了我们现在可以解决的三个最紧迫的问题。这些可能是显而易见的，但<em>我们如何</em>解决这些问题，进而使开发人员和最终用户能够构建和使用新颖的应用？</p>
<figure data-type="image" tabindex="5"><img src="https://pbs.twimg.com/media/FfXYS-HUoAARpNu?format=jpg&amp;name=medium" alt="image" loading="lazy"></figure>
<p>1.Solve real problems The bull case for LATAM and a case study on how solving hyperlocal problems (a big problem for many people) drives 100x+ growth, and what crypto can learn from these orgs</p>
<p>解决实际问题 拉美的牛市案例和关于解决超本地问题（对许多人来说是个大问题）如何推动 100 倍以上增长的案例研究，以及加密可以从这些组织中学到什么</p>
<figure data-type="image" tabindex="6"><img src="https://pbs.twimg.com/media/FfXYTnLVIAAHxMH?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>Latin America seems to be one of the best places to explore crypto because they already exhibit behaviors that make them ripe for crypto adoption</p>
<p>拉丁美洲似乎是探索加密货币的最佳地点之一，因为它们已经表现出成熟采用加密货币的行为</p>
<figure data-type="image" tabindex="7"><img src="https://pbs.twimg.com/media/FfXYUORUAAExN5b?format=jpg&amp;name=medium" alt="" loading="lazy"></figure>
<p>Some stats highlight that Latinos are already operating and transacting outside of the rails of traditional finance Despite half of the population being unbanked, most consumers access neobank and nonbank financial services.</p>
<p>一些统计数据表明，拉丁美洲人已经在传统金融的轨道之外开展业务和交易，尽管有一半的人口没有银行账户，但大多数消费者都可以使用新银行和非银行金融服务。</p>
<figure data-type="image" tabindex="8"><img src="https://pbs.twimg.com/media/FfXYUzWUAAkgIAQ?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>Remittance in 2021 represented almost 25% of total GDP in Honduras and El Salvador and ~15% of GDP in Guatemala. Do you know how insane that is</p>
<p>2021 年的汇款占洪都拉斯和萨尔瓦多 GDP 总额的近 25%，占危地马拉 GDP 的约 15%。你知道那有多疯狂吗！</p>
<figure data-type="image" tabindex="9"><img src="https://pbs.twimg.com/media/FfXYVWnUAAYTBhc?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>Data by Gemini indicates that women in LATAM are transacting and holding crypto at higher rates than women in Europe. Crypto offers a new way for women to exercise financial freedom while operating within the bounds of what is culturally acceptable.</p>
<p>Gemini 的数据表明，拉丁美洲的女性交易和持有加密货币的比率高于欧洲女性。加密货币为女性提供了一种行使财务自由的新方式，同时在文化可接受的范围内运作。</p>
<figure data-type="image" tabindex="10"><img src="https://pbs.twimg.com/media/FfXYV5uUYAAsQ5e?format=jpg&amp;name=medium" alt="" loading="lazy"></figure>
<p>In a culture of machismo, patriarchy with a little hot sauce on it, I can see how crypto offers a workaround for women to exercise the ability to hold and earn value without breaking social and cultural norms like opening a bank account without your husband, etc.</p>
<p>在大男子主义、带有少许辣酱的父权制文化中，我可以看到加密货币如何为女性提供一种解决方法，让她们能够在不违反社会和文化规范的情况下行使持有和赚取价值的能力，例如在没有丈夫的情况下开设银行账户等.</p>
<p>Mercado Pago and PicsPay in Colombia and Brazil are great case studies for what happens when you solve hyperlocal problems for consumers. Both are now financial giants in the space, and it all started from a relatively simple, not-so-novel payments platform.</p>
<p>哥伦比亚和巴西的 Mercado Pago 和 PicsPay 是很好的案例研究，说明当您为消费者解决超本地化问题时会发生什么。两者现在都是该领域的金融巨头，这一切都始于一个相对简单、不那么新颖的支付平台。</p>
<figure data-type="image" tabindex="11"><img src="https://pbs.twimg.com/media/FfXYWiuUAAYBCA7?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://pbs.twimg.com/media/FfXYW6sVUAA8Yza?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>We covered the social. What technical milestones do we still have to reach to make Ethereum and blockchains in general usable to the masses?</p>
<ul>
<li>
<p>Scalability</p>
</li>
<li>
<p>More secure applications</p>
<p>These next slides are also core to the reason why I joined Fuel.</p>
</li>
</ul>
<p>我们涵盖了社会面。我们还需要达到哪些技术里程碑才能使以太坊和区块链普遍适用于大众？</p>
<ul>
<li>可扩展性</li>
<li>更安全的应用程序</li>
</ul>
<p>这些下一张幻灯片也是我加入 Fuel 的核心原因。</p>
<figure data-type="image" tabindex="13"><img src="https://pbs.twimg.com/media/FfXYXhFUAAIlDVM?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>Scalability without sacrificing decentralization. There are 666M people in LATAM. We need systems that can handle the load without impacts to performance. Fuel's execution model allows for parallelized transaction execution, resulting in a significant net gain in TPS.</p>
<p>不牺牲去中心化的可扩展性。拉丁美洲有 6.66 亿人。我们需要能够在不影响性能的情况下处理负载的系统。 Fuel 的执行模型允许并行执行交易，从而导致 TPS 的显着净收益。</p>
<figure data-type="image" tabindex="14"><img src="https://pbs.twimg.com/media/FfXYYGkUAAIWcnC?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>In LATAM, you're dealing with a population that is more price-sensitive. The average monthly income is ~$500. We have to take steps to minimize the risk of hacks and losses. The<a href="https://twitter.com/SwayLang">@SwayLang</a>compiler will call out reentrancy bugs and won't let you deploy a vulnerable contractS</p>
<p>在拉丁美洲，您面对的是对价格更加敏感的人群。平均月收入约为 500 美元。我们必须采取措施将黑客入侵和损失的风险降至最低。 <a href="https://twitter.com/SwayLang">@SwayLang</a> 编译器将调用可重入性错误，并且不会让您部署易受攻击的合约</p>
<figure data-type="image" tabindex="15"><img src="https://pbs.twimg.com/media/FfXYYtjUAAM4Sro?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>The Sway compiler forces developers to handle all variant control flow paths. Check out this thread by compiler engineer<a href="https://twitter.com/emilyaherbert">@emilyaherbert</a>for more on Sway features</p>
<p>Sway 编译器强制开发人员处理所有变体控制流路径。查看编译器工程师 <a href="https://twitter.com/emilyaherbert">@emilyaherbert</a> 的此长推，了解有关 Sway 功能的更多信息</p>
<figure data-type="image" tabindex="16"><img src="https://pbs.twimg.com/media/FfXYZTuUAAA45vv?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<hr>
<figure data-type="image" tabindex="17"><img src="https://pbs.twimg.com/profile_images/1183078593078923264/M1WaFAKA_normal.jpg" alt="" loading="lazy"></figure>
<p><a href="https://twitter.com/emilyaherbert/status/1575906743254908928">https://twitter.com/emilyaherbert/status/1575906743254908928</a></p>
<hr>
<p>Write more secure smart contracts in Sway with our namespace storage access. Each function's storage access must be annotated, giving clarity to developers and users alike who will never accidentally access storage, causing unintended consequences.</p>
<p>使用我们命名的空间存储，访问在 Sway 中编写的更安全的智能合约。每个函数的存储访问都必须进行注释，让开发人员和用户清楚地知道他们永远不会意外访问存储，从而导致意想不到的后果。</p>
<figure data-type="image" tabindex="18"><img src="https://pbs.twimg.com/media/FfXYZ6OUAAUH0JG?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://pbs.twimg.com/media/FfXYaRnUAAkzoA5?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<p>Thank you to the whole Devcon team for organizing and allowing me to give this talk.</p>
<p>感谢整个 Devcon 团队组织并允许我进行这次演讲。</p>
<p>If you're interested in experiencing the top-tier developer experience we're crafting at<a href="https://twitter.com/fuellabs_">@fuellabs_</a>, check out our developer quickstart <a href="https://t.co/6QmJCUaOt7">https://fuellabs.github.io/fuel-docs/master/developer-quickstart.html…</a></p>
<p>如果您有兴趣体验我们在 <a href="https://twitter.com/fuellabs_">@fuellabs_</a> 打造的顶级开发人员体验，请查看我们的开发人员快速入门 <a href="https://t.co/6QmJCUaOt7">https://fuellabs.github.io/ Fuel-docs/master/developer-quickstart.html…</a></p>
<p>Expanded thoughts and sources cited from the numbers and stats referenced in this talk</p>
<p>从本次演讲中引用的数字和统计数据中引用的扩展思想和来源</p>
<p><a href="https://twitter.com/camiinthisthang/status/1577688321991417856">https://twitter.com/camiinthisthang/status/1577688321991417856</a></p>
<p>The link to my slides: <a href="https://t.co/RXQbhMAoxL">https://docs.google.com/presentation/d/12EpcqMBJtyJXvWlmIY00kttPv-Y_Mwlpnb8GnkOulnw/edit?usp=sharing…</a>. I'll share the recording of the talk as soon as it's ready. THANK YOU !</p>
<p>我的幻灯片的链接：<a href="https://t.co/RXQbhMAoxL">https://docs.google.com/presentation/d/12EpcqMBJtyJXvWlmIY00kttPv-Y_Mwlpnb8GnkOulnw/edit?usp=sharing...</a>。一旦准备好，我会分享谈话的录音。谢谢你 ！</p>
<figure data-type="image" tabindex="20"><img src="https://pbs.twimg.com/card_img/1582408809128939520/O8w6U0hF?format=jpg&amp;name=small" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Halborn 完成对 Neon 治理计划的审计 (Halborn Completes Audit of Neon’s Governance Programs)]]></title>
        <id>https://chainguys.github.io/post/halborn-wan-cheng-dui-neon-zhi-li-ji-hua-de-shen-ji-halborn-completes-audit-of-neons-governance-programs/</id>
        <link href="https://chainguys.github.io/post/halborn-wan-cheng-dui-neon-zhi-li-ji-hua-de-shen-ji-halborn-completes-audit-of-neons-governance-programs/">
        </link>
        <updated>2022-10-18T05:43:07.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/1*1s1lfMuwBrmMBw_tymxr-Q.png" alt="" loading="lazy"></figure>
<hr>
<p><a href="https://halborn.com/about/who-we-are/">Halborn</a>, a security engineering team, has completed a security audit of Neon’s Governance Programs. The audit began on April 27, 2022 and ended on May 8, 2022. This security audit was conducted in addition to <a href="https://medium.com/neon-labs/ackee-blockchain-completes-neons-governance-audit-ff04d69a002c">Ackee Blockchain’s audit</a>, which was completed on July 22, 2022.</p>
<p>安全工程团队 <a href="https://halborn.com/about/who-we-are/">Halborn</a> 已完成对 Neon 治理计划的安全审计。审计于 2022 年 4 月 27 日开始，于 2022 年 5 月 8 日结束。本次安全审计是 <a href="https://chainguys.github.io/post/ackee-qu-kuai-lian-wan-cheng-neon-de-zhi-li-shen-ji-ackee-blockchain-completes-neons-governance-audit/">Ackee Blockchain 审计</a> 的附属，于 2022 年 7 月 22 日完成。</p>
<p>A final <a href="https://github.com/neonlabsorg/neon-spl-governance/blob/main/audit/NEON_Labs_Governance_Solana_Program_Security_Audit_Report_Halborn_Final.pdf">report</a> was delivered to the Neon Labs team at the end of the audit process. In this article, we’ll go over the scope, goals, process, and significant findings of the Halborn security audit as documented in the final audit report.</p>
<p>最终的<a href="https://github.com/neonlabsorg/neon-spl-governance/blob/main/audit/NEON_Labs_Governance_Solana_Program_Security_Audit_Report_Halborn_Final.pdf">报告</a> 已在审核流程结束时交付给 Neon Labs 团队。在本文中，我们将介绍最终审计报告中记录的 Halborn 安全审计的范围、目标、流程和重要发现。</p>
<h1 id="安全审计的范围-scope-of-the-security-audit">安全审计的范围 (Scope of the Security Audit)</h1>
<p>The security assessment was scoped to two Solana programs: the <strong><em>spl-governance-addin-fixed-weights contract</em></strong> and the <strong><em>spl-governance-addin-vesting contract</em></strong>. The specific commit audited was <a href="https://github.com/neonlabsorg/neon-spl-governance/commit/c0c3732cf0aa0b90527f54a0068367d8d03af748">c0c3732cf0aa0b90527f54a0068367d8d03af748</a> of the <a href="https://github.com/neonlabsorg/neon-spl-governance">nonlabsorg/neon-spl-governance</a> repository. These programs are related to Neon project governance and rely on SPL-Governance and various other Solana libraries to deliver a custom governance process for participants in the Neon ecosystem.</p>
<p>安全评估的范围是两个 Solana 计划：<strong><em>spl-governance-addin-fixed-weights contract</em></strong> 和 <strong><em>spl-governance-addin-vesting contract</em></strong>。审核的具体提交是 <a href="https://github.com/neonlabsorg/neon-spl-governance/commit/c0c3732cf0aa0b90527f54a0068367d8d03af748">c0c3732cf0aa0b90527f54a0068367d8d03af748</a> 的 <a href="https://github.com/neonlaborg">nonlabsorg/neon-splon-governance</a> 存储库。这些程序与 Neon 项目治理相关，并依靠 SPL-Governance 和各种其他 Solana 库为 Neon 生态系统的参与者提供自定义治理流程。</p>
<p>External libraries and finance-related attacks were out-of-scope for the Halborn audit.</p>
<p>外部库和与财务相关的攻击超出了 Halborn 审计的范围。</p>
<h1 id="安全审计的目的和目标-purpose-and-goals-of-the-security-audit">安全审计的目的和目标 (Purpose and Goals of the Security Audit)</h1>
<p>Neon Labs continuously emphasizes the importance of high security standards. This is why the team decided to work with Halborn, as well as Ackee Blockchain, to review Neon’s Governance contracts. The security audits were conducted to ensure that the in-scope Solana programs were functioning properly and identify potential security vulnerabilities.</p>
<p>Neon Labs 不断强调高安全标准的重要性。这就是团队决定与 Halborn 以及 Ackee Blockchain 合作审查 Neon治理合约的原因。进行安全审计来确保范围内的 Solana 程序正常运行并识别潜在的安全漏洞。</p>
<h1 id="安全审计过程-the-security-audit-process">安全审计过程 (The Security Audit Process)</h1>
<p>Halborn used a combination of manual code review and automated security testing to deliver an accurate auditing service while keeping efficiency, timeliness and practicality in mind. Manual testing is primarily used to uncover flaws in logic, process, and implementation. To supplement manual testing, automated testing techniques help to improve program coverage and quickly identify items that do not adhere to security best practices.</p>
<p>Halborn 结合使用手动代码审查和自动安全测试来提供准确的审计服务，同时j坚持效率、及时性和实用性。手动测试主要用于发现逻辑、流程和实施中的缺陷。为了补充手动测试，自动化测试技术有助于提高程序覆盖率并快速识别不符合最佳安全实践的项目。</p>
<p>The audit procedure and associated tools are as follows:<br>
审计程序和相关工具如下：</p>
<ol>
<li>
<p>Research the architecture, purpose, and use of the Neon platform.<br>
研究Neon平台的架构、目的和用途。</p>
</li>
<li>
<p>Review and walkthrough the Solana program manual code review to identify logic issues.<br>
审查和演练 Solana 程序手动代码审查来确定逻辑问题。</p>
</li>
<li>
<p>Thoroughly assess the safety and usage of critical in-scope Rust variables and functions that could lead to arithmetic vulnerabilities.<br>
彻底评估可能导致算术漏洞的关键范围 Rust 变量和函数的安全性和使用情况。</p>
</li>
<li>
<p>Find unsafe Rust code usage with the <strong><em>cargo-geiger</em></strong> security tool, which lists statistics related to the use of unsafe Rust code present in a Rust codebase and its dependencies.<br>
使用 <strong><em>cargo-geiger</em></strong> 安全工具查找不安全的 Rust 代码使用情况，该工具列出了与使用 Rust 代码库中存在不安全的 Rust 代码及其依赖项相关的统计信息。</p>
</li>
<li>
<p>Scan dependencies for known vulnerabilities with the <strong><em>cargo audit</em></strong> tool, which scans for vulnerabilities reported to the RustSec Advisory Database. The RustSec Advisory Database stores all vulnerabilities published in <a href="https://crates.io./">https://crates.io.</a><br>
使用 <strong><em>cargo audit</em></strong> 工具扫描依赖关系中的已知漏洞，该工具会扫描报告给 RustSec 咨询数据库的漏洞。 RustSec 咨询数据库在 <a href="https://crates.io./">https://crates.io.</a> 中存储发布的所有漏洞</p>
</li>
<li>
<p>Deploy the local cluster (<strong><em>solana-test-validator</em></strong>).<br>
部署本地集群（<strong><em>solana-test-validator</em></strong>）。</p>
</li>
<li>
<p>Scan for common Solana vulnerabilities using <strong><em>soteria</em></strong>, a security analysis service for Solana programs that assists with the detection of well-known security issues.<br>
使用 <strong><em>soteria</em></strong> 扫描常见的 Solana 漏洞，这是一种针对 Solana 程序的安全分析服务，可帮助检测众所周知的安全问题。</p>
</li>
</ol>
<h1 id="neon-evm-安全审计的结果-outcome-of-the-neon-evm-security-audit">Neon EVM 安全审计的结果 (Outcome of the Neon EVM Security Audit)</h1>
<p>Halborn ranks vulnerabilities or issues by calculating the <strong><em>likelihood</em></strong> of a security incident and the <strong><em>impact</em></strong> if an incident occurs. The likelihood and impact ratings are then ingested into a scoring framework to determine a risk’s severity level (informational, low, medium, high, and critical). The framework is useful for communicating the characteristics and consequences of technological vulnerabilities. The quantitative model ensures consistent and accurate measurement while also allowing users to see the underlying vulnerability characteristics considered when prioritizing risks.</p>
<p>Halborn 通过计算安全事件的 <strong><em>likelihood</em></strong> 和事件发生时的 <strong><em>impact</em></strong> 来对漏洞或问题进行排名。然后将可能性和影响评级纳入评分框架，以确定风险的严重程度（信息、低、中、高和严重）。该框架对于传达技术漏洞的特征和后果很有用。定量模型确保了一致和准确的测量，同时还允许用户在判定风险时查看考虑的对应对应风险特征。</p>
<p>As an output to the security audit, Halborn identified two main risks: <strong><em>(HAL-01) Cargo Overflow Checks Missing</em></strong> and <strong><em>(HAL-02) Outdated Dependencies Version.</em></strong> Both risks have now been addressed by the Neon Labs team. Additional details can be found below.</p>
<p>作为安全审计的输出，Halborn 确定了两个主要风险：<strong><em>(HAL-01) Cargo Overflow Checks Missing</em></strong> 和 <strong><em>(HAL-02) Outdated Dependencies Version.</em></strong> 这两个风险现已由Neon Lab团队解决。可以在下面找到更多详细信息。</p>
<h1 id="cargo溢出检查缺失-hal-01-cargo-overflow-checks-missing-hal-01">Cargo溢出检查缺失 (HAL-01)-Cargo Overflow Checks Missing (HAL-01)</h1>
<p>It was observed that there is no overflow-checks=true in any Cargo.toml file. By default, overflow checks are disabled in optimized release builds. Therefore, if there is an overflow in the release build, it will pass silently, causing unexpected behavior of an application. Even when checked arithmetic is used (checked_*), it is still recommended to have those checks in Cargo.toml.</p>
<p>观察到在任何 Cargo.toml 文件中都没有 overflow-checks=true。默认情况下，溢出检查在优化的发布版本中被禁用。因此，如果发布构建中出现溢出，它将默默通过，从而导致应用程序出现意外行为。即使使用检查算法（checked_*），仍然建议在 Cargo.toml 中进行检查。</p>
<p>The finding was rated as low-risk and has since been addressed. The Neon Labs team fixed the issue by adding overflows-check=true in the workspace Cargo.toml file in commit <a href="https://github.com/neonlabsorg/neon-spl-governance/commit/5425078d1c45c62f92b5bb90492bbaeac751ec7b">5425078d1c45c62f92b5bb90492bbaeac751ec7b</a>.</p>
<p>该发现被评为低风险，并已得到解决。 Neon Labs 团队通过提交 <a href="https://github.com/neonlabsorg/neon-spl-governance/commit/5425078d1c45c62f92b5bb90492bbaeac751ec7b">5425078d1c45c62f92b5bb90492bbaeac751ec7b</a>  向工作区的Cargo.toml 文件中添加 overflows-check=true 解决了这个问题。</p>
<h1 id="过时的依赖版本-hal-02-outdated-dependencies-version-hal-02">过时的依赖版本 (HAL-02)-Outdated Dependencies Version (HAL-02)</h1>
<p>Software is continuously updated for various reasons. Drivers introduce updates including adding new features, removing old features, and patching bugs and vulnerabilities. The Halborn team detected that the versions of spl-governance-addin-vesting and spl-governance-addin-fixed-wights packages assessed referenced outdated versions of solana-program and spl-token, which could cause logic flows to malfunction.</p>
<p>由于各种原因，软件不断更新。驱动程序引入更新，包括添加新功能、删除旧功能以及修补错误和漏洞。 Halborn 团队检测到 spl-governance-addin-vesting 和 spl-governance-addin-fixed-wights 软件包的版本,评估了引用的 solana-program 和 spl-token 的过时版本，这可能导致逻辑流程出现故障。</p>
<p>The finding was rated as an informational risk and has since been addressed. The Neon Labs team fixed the issue by updating solana-program and spl-token to their latest versions in commit <a href="https://github.com/neonlabsorg/neon-spl-governance/commit/5425078d1c45c62f92b5bb90492bbaeac751ec7b">5425078d1c45c62f92b5bb90492bbaeac751ec7b</a>.</p>
<p>该发现被评为信息风险(知会级别)，并已得到解决。 Neon Labs 团队通过提交 <a href="https://github.com/neonlabsorg/neon-spl-governance/commit/5425078d1c45c62f92b5bb90492bbaeac751ec7b">5425078d1c45c62f92b5bb90492bbaeac751ec7b</a> 将 solana-program 和 spl-token 更新到最新版本来解决此问题。</p>
<h1 id="结论-conclusion">结论 (Conclusion)</h1>
<p>Thank you for taking the time to review the outcome of the Halborn security audit. If you have any questions about the security audit or the associated findings, don’t hesitate to reach out. You can contact the team via <a href="https://discord.com/invite/9jVYEDVwn8">Discord</a>. Lastly, stay connected with the team on <a href="https://twitter.com/neonlabsorg">Twitter</a>, <a href="https://github.com/neonlabsorg">GitHub</a>, <a href="https://www.youtube.com/channel/UCAL2uFkKkfBgz3mXFN3UDTQ">YouTube</a>, and <a href="https://neonlabsorg.medium.com/">Medium</a> for more development updates and announcements.</p>
<p>感谢您抽出宝贵时间查看 Halborn 安全审计的结果。如果您对安全审计或相关调查结果有任何疑问，请随时与我们联系。您可以通过 <a href="https://discord.com/invite/9jVYEDVwn8">Discord</a> 联系团队。最后，在 <a href="https://twitter.com/neonlabsorg">Twitter</a>、<a href="https://github.com/neonlabsorg">GitHub</a>、<a href="https://www.youtube">YouTube</a>  和 <a href="https://neonlabsorg.medium.com/">Medium</a>上与团队保持联系，了解更多开发更新和公告。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SeiNetwork长推-20221014 (SeiNetwork twitter threads-20221014)]]></title>
        <id>https://chainguys.github.io/post/seinetwork-chang-tui-20221014-seinetwork-twitter-threads-20221014/</id>
        <link href="https://chainguys.github.io/post/seinetwork-chang-tui-20221014-seinetwork-twitter-threads-20221014/">
        </link>
        <updated>2022-10-14T09:39:53.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://pbs.twimg.com/profile_images/1579219797392474118/_PpJrD9Z_x96.jpg" alt="" loading="lazy"></figure>
<p>原文地址:<a href="https://twitter.com/SeiNetwork/status/1580703985836515329">https://twitter.com/SeiNetwork/status/1580703985836515329</a></p>
<p>1/ Minimizing latency is crucial. A thread on what that means and how Sei is making strides to have extremely fast time to finality through collocating validators.</p>
<p>最小化延迟至关重要。这篇长推将解释这意味着什么，以及 Sei 如何通过并置验证者来以极快的速度完成最终确定。</p>
<p>2/ What is &quot;time to finality&quot;? &quot;Time to finality&quot; describes the time between when blocks are committed to the blockchain. Sei has a strong focus on minimizing our network latency to create the best environment for decentralized exchanges to deploy and scale.</p>
<p>什么是“完成时间”？ “完成时间”描述了将块提交到区块链之间的时间。 Sei 非常注重最大限度地减少的网络延迟，为去中心化交易所的部署和扩展创造最佳环境。</p>
<p>3/ For optimal performance, sei ran load tests with a smaller validator set that was colocated.</p>
<p>为了获得最佳性能，sei 使用托管的较小验证者集进行负载测试。</p>
<figure data-type="image" tabindex="2"><img src="https://pbs.twimg.com/media/Fe_J5_nUoAAdq_v?format=jpg&amp;name=medium" alt="Image" loading="lazy"></figure>
<hr>
<p>4/ Why colocation? Internationally scattered validators have higher latency when reaching consensus and producing blocks because it takes longer for messages to travel between them.</p>
<p>为什么要托管？国际上分散的验证者在达成共识和生成区块时具有更高的延迟，因为消息在它们之间传输需要更长的时间。</p>
<p>5/ After extensive research on colocation Sei found:<br>
Colocation reduces latency by ~46% vs. international dispersion<br>
50 validators is the limit before seeing increased latency by adding more validators Full research here</p>
<p>Sei 在对托管进行广泛研究后发现：<br>
与国际分散相比，托管可将延迟降低约 46%<br>
50 个验证器是通过添加更多验证器来增加延迟之前的限制，您可以查看以下研究</p>
<p><a href="https://twitter.com/jayendra_jog/status/1552830894091644929">https://twitter.com/jayendra_jog/status/1552830894091644929</a></p>
<p>6/ Although testing for the software and hardware designs is still ongoing, interested teams are actively considering expanding to Sei. A number of protocols are prepared to deploy on Sei at mainnet launch.</p>
<p>尽管软件和硬件设计的测试仍在进行中，但感兴趣的团队正在积极考虑扩展到 Sei。许多协议准备在主网启动时部署在 Sei 上。</p>
<p>7/ To learn more about how Sei creates an environment custom-built for <a href="https://twitter.com/hashtag/DEX?src=hashtag_click">#DEX</a> applications in-depth check out our GitBook: <a href="https://t.co/F4HHZRnu9Z">https://docs.seinetwork.io/introduction/overview…</a></p>
<p>要深入了解 Sei 如何为 <a href="https://twitter.com/hashtag/DEX?src=hashtag_click">#DEX</a> 应用创建定制环境的更多信息，请查看我们的 GitBook：<a href="https://t.co/F4HHZRnu9Z">https:// docs.seinetwork.io/introduction/overview…</a></p>
<p>8/ Shoutout to the<a href="https://twitter.com/Delphi_Digital">@Delphi_Digital</a> team for writing in-depth research about Sei! Read the full report here<br>
[Learn more in our new PRO report.]</p>
<p>向 <a href="https://twitter.com/Delphi_Digital">@Delphi_Digital</a> 团队致敬，感谢他们撰写有关 Sei 的深入研究！在此处阅读完整报告</p>
<p>[在新 PRO 报告中了解更多信息。]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ackee区块链完成 Neon 的治理审计 (Ackee Blockchain Completes Neon’s Governance Audit)]]></title>
        <id>https://chainguys.github.io/post/ackee-qu-kuai-lian-wan-cheng-neon-de-zhi-li-shen-ji-ackee-blockchain-completes-neons-governance-audit/</id>
        <link href="https://chainguys.github.io/post/ackee-qu-kuai-lian-wan-cheng-neon-de-zhi-li-shen-ji-ackee-blockchain-completes-neons-governance-audit/">
        </link>
        <updated>2022-10-13T10:00:17.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/1*s1rfUjRRm0Qki1m78ESBcA.png" alt="" loading="lazy"></figure>
<p>Between June 27 and July 22, 2022, <a href="https://ackeeblockchain.com/">Ackee Blockchain</a> conducted a security audit of Neon’s Governance contract. The Ackee Blockchain team is composed of auditors and white hat hackers who perform security audits and assessments including code review, testing, automated analysis, and local deployment/hacking.</p>
<p>在 2022 年 6 月 27 日至 7 月 22 日期间，<a href="https://ackeeblockchain.com/">Ackee区块链</a> 对 Neon 的治理合约进行了安全审计。 Ackee 区块链团队由审计员和白帽黑客组成，他们执行安全审计和评估，包括代码审查、测试、自动分析和本地部署/黑客攻击。</p>
<p>At the end of the 26-day audit process, a <em>Findings and Recommendations</em> report was delivered to the Neon Labs team. In this article, we’ll outline the scope, goals, and process of the Ackee security audit and summarize the notable findings.</p>
<p>在 26 天的审核过程结束时，一份 <em>调查结果和建议</em> 报告已提交给 Neon Labs 团队。在本文中，我们将概述 Ackee 安全审计的范围、目标和过程，并总结值得注意的发现。</p>
<h1 id="安全审计的范围-scope-of-the-security-audit">安全审计的范围 (Scope of the Security Audit)</h1>
<p>Ackee Blockchain focused the security audit on understanding and reviewing the Neon SPL Governance contract. In addition, the team reviewed the source code and security of the Neon maintenance program and custom add-ins. The specific commit audited was <em>f13d7e7c1507819306797688ce0bb1f6950a5038</em> of the <a href="https://github.com/neonlabsorg/neon-spl-governance">neonlabsorg/neon-spl-governance</a> repository.</p>
<p>Ackee区块链将安全审计的重点放在理解和审查 Neon SPL 治理合约上。此外，团队还审查了 Neon 维护程序和自定义插件的源代码和安全性。审核的具体提交是 <a href="https://github.com/neonlabsorg/neon-spl-governance">neonlabsorg/neon-spl-governance</a> 存储库的 <em>f13d7e7c1507819306797688ce0bb1f6950a5038</em>。</p>
<p>The programs covered include:<br>
涵盖的计划包括：</p>
<ul>
<li>maintanance/program 维护/程序</li>
<li>addin-fixed-weights/program 附加固定权重/程序</li>
<li>addin- vesting/program 附加注入/计划</li>
<li>governance-lib 治理库</li>
</ul>
<p>During the review, Ackee paid particular attention to:<br>
在审核过程中，Ackee 特别关注：</p>
<ul>
<li>
<p>whether the SPL-governance contract specifications are implemented correctly for the custom add-ins.<br>
是否为自定义加载项正确实施了 SPL 治理合约规范。</p>
</li>
<li>
<p>whether the programs correctly use dependencies or other supporting programs (e.g., SPL dependencies).<br>
程序是否正确使用依赖项或其他支持程序(例如，SPL 依赖项)。</p>
</li>
<li>
<p>whether the code is vulnerable to voting manipulation.<br>
代码是否容易受到投票操纵。</p>
</li>
</ul>
<h1 id="安全审计的目的目标-purposegoals-of-the-security-audit">安全审计的目的/目标 (Purpose/Goals of the Security Audit)</h1>
<p>Neon Labs always strives to reach the highest security standard for our services and platforms, including Neon Governance. The Ackee discovered findings from the audit that will be urgently addressed and will continue to challenge and motivate our product team.</p>
<p>Neon Labs 始终致力于为我们的服务和平台(包括 Neon Governance)达到最高安全标准。 Ackee 发现审计结果将被紧急处理，并将继续挑战和激励我们的产品团队。</p>
<p>The main goal of the security audit was to assess the security posture of the SPL governance contract and associated programs to identify potential vulnerabilities. Ackee Blockchain aimed to meet this goal through a review of the targeted source code and documentation, execution of a penetration test, and evaluation of the testing process.</p>
<p>安全审计的主要目标是评估 SPL 治理合约和相关程序的安全状况，进而识别潜在的漏洞。 Ackee 区块链旨在通过审查目标源代码和文档、执行渗透测试和评估测试过程来实现这一目标。</p>
<h1 id="安全审计程序-the-security-audit-procedure">安全审计程序 (The Security Audit Procedure)</h1>
<p><strong>1. 代码审查 Code Review</strong></p>
<p>Ackee began the security audit by reviewing the specifications, sources, and instructions related to Neon’s SPL Governance contract. Following the initial review, the Ackee team conducted a manual line-by-line review of Neon’s in-scope source code.</p>
<p>Ackee 通过审查与 Neon 的 SPL 治理合约相关的规范、来源和说明开始了安全审计。在初步审查之后，Ackee 团队对 Neon 范围内的源代码进行了手动逐行审查。</p>
<p><strong>2. 测试和自动分析 Testing and Automated Analysis</strong></p>
<p>Following the code review, Ackee ran automated tests to ensure the SPL Governance contract functioned as intended. As part of the testing, Ackee also wrote missing unit or “fuzzy tests” using their Solana testing framework, <a href="https://solana.com/riptide/voting/trdelnik">Trdelnik</a>.</p>
<p>在代码审查之后，Ackee 运行自动化测试来确保 SPL 治理合约按预期运行。作为测试的一部分，Ackee 还使用他们的 Solana 测试框架 <a href="https://solana.com/riptide/voting/trdelnik">Trdelnik</a> 编写了缺失的单元或“模糊测试”。</p>
<p><strong>3. 本地部署 + 黑客攻击 Local Deployment + Hacking</strong></p>
<p>In the final steps of the security audit, Ackee initiated a white hat hacking campaign to try and manipulate the system based on their findings from steps one and two. Programs were deployed locally in an attempt to attack and break the in-scope system. Hacking is a beneficial way to round out the audit and ensure there are no additional holes in the source code and platform.</p>
<p>在安全审计的最后阶段，Ackee 发起了一场白帽黑客攻击活动，试图根据他们在第一步和第二步中的发现来操纵系统。程序被部署在本地，试图攻击和破坏范围内的系统。黑客攻击是完成审计并确保源代码和平台中没有额外漏洞的有益方式。</p>
<h1 id="neon-evm-安全审计结果-neon-evm-security-audit-outcome">Neon EVM 安全审计结果 (Neon EVM Security Audit Outcome)</h1>
<p>The Ackee Security Audit presented findings by categorizing issues according to severity, impact, and likelihood. The results identified some core issues and mandatory clean-ups for the Neon Labs team to address, along with some recommendations to be implemented.</p>
<p>Ackee 安全审计通过根据严重性、影响和可能性对问题进行分类来展示调查结果。结果确定了 Neon Labs 团队需要解决的一些核心问题和要做的强制清理，以及一些需要实施的建议。</p>
<p>The security audit identified eight issues that range from critical to informational in terms of severity. The Neon Labs team has reviewed these issues and has already begun to address them.</p>
<p>安全审计确定了八个问题，从严重程度来看，从严重到知会不等。 Neon Labs 团队已经审查了这些问题，并且已经开始着手解决这些问题。</p>
<p>The two critical issues identified by the audit are as:</p>
<p>审计发现的两个关键问题如下：</p>
<p><strong>1. It is possible to manipulate the voting process while using the fixed-weights addin.</strong><br>
可以在使用固定权重插件时操纵投票过程</p>
<p><em>This vulnerability allows users to select a number higher than 100%, which gives additional weight to their vote to such an extent that a single user (member of governance) could practically decide on any proposal by themself.</em></p>
<p><em>此漏洞允许用户选择高于 100% 的数字，这为他们的投票提供了额外的权重，以至于单个用户(治理成员)实际上可以自己决定任何提案</em></p>
<p><strong>2. When using the add in-vesting (for realm), the first user will be able to decide on any proposal after their deposit.</strong><br>
使用附加注入时(针对领域)时，第一个用户将能够在存款后决定任何提案。</p>
<p><em>In this scenario, the first user who calls a deposit can immediately create a proposal and vote for it. Since their vote would have 100% weight, the proposal would be marked as successful.</em></p>
<p><em>在这种情况下，第一个调用存款的用户可以立即创建提案并对其进行投票。由于他们的投票权重为 100%，因此提案将被标记为成功。</em></p>
<h1 id="结论-conclusion">结论 (Conclusion)</h1>
<p>We hope you found this article informative. If you have any questions about the security audit of Neon’s SPL Governance contract, don’t hesitate to reach out. You can contact the team via <a href="https://discord.com/invite/9jVYEDVwn8">Discord</a>. Lastly, stay connected with the team on <a href="https://twitter.com/neonlabsorg">Twitter</a>, <a href="https://github.com/neonlabsorg">GitHub</a>, <a href="https://www.youtube.com/channel/UCAL2uFkKkfBgz3mXFN3UDTQ">YouTube</a>, and <a href="https://neonlabsorg.medium.com/">Medium</a> for more development updates and announcements.</p>
<p>我们希望您发现这篇文章内容丰富。如果您对 Neon 的 SPL 治理合约的安全审计有任何疑问，请随时与我们联系。您可以通过 <a href="https://discord.com/invite/9jVYEDVwn8">Discord</a> 联系团队。最后，在 <a href="https://twitter.com/neonlabsorg">Twitter</a>、<a href="https://github.com/neonlabsorg">GitHub</a>、<a href="https://www.youtube">YouTube</a>  <a href="https://neonlabsorg.medium.com/">Medium</a> 了解更多开发更新和公告，与团队保持联系。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Neon EVM：如何使用 Hardhat 部署 Neon dApps (Neon EVM：How to Deploy Neon dApps Using Hardhat)]]></title>
        <id>https://chainguys.github.io/post/neon-evmru-he-shi-yong-hardhat-bu-shu-neon-dapps-neon-evmhow-to-deploy-neon-dapps-using-hardhat/</id>
        <link href="https://chainguys.github.io/post/neon-evmru-he-shi-yong-hardhat-bu-shu-neon-dapps-neon-evmhow-to-deploy-neon-dapps-using-hardhat/">
        </link>
        <updated>2022-10-13T08:48:48.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://miro.medium.com/max/1400/1*ilG7YYUkiJdBFDadmhcmJg.png" alt="" loading="lazy"></figure>
<p>The third and final article in our Deploying Neon dApps series explores how to deploy Solidity dApps using Hardhat. (We previously discussed how to deploy Neon with <a href="https://medium.com/neon-labs/neon-evm-how-to-deploy-dapps-using-remix-363ebe946ed2">Remix</a> and <a href="https://medium.com/neon-labs/neon-evm-how-to-deploy-dapps-using-truffle-4a80e57395c2">Truffle</a>.</p>
<p>我们部署 Neon dApps 系列的第三篇也是最后一篇文章探讨了如何使用 Hardhat 部署 Solidity dApp。 （我们之前讨论过如何使用 <a href="https://medium.com/neon-labs/neon-evm-how-to-deploy-dapps-using-remix-363ebe946ed2">Remix</a> 和 <a href="https://medium.com/neon-labs/neon-evm-how-to-deploy-dapps-using-truffle-4a80e57395c2">Truffle</a>。)</p>
<p><a href="https://hardhat.org/">Hardhat</a> is a development and deployment tool for EVM contracts and applications. Of the three deployment tools explored in this series, Hardhat is the most versatile, allowing for plenty of customizable settings and secure deployment to Neon’s mainnet, devnet, and testnet. However, unlike Remix, hHardhat can only be used via a command-line interface, and is not an IDE.</p>
<p><a href="https://hardhat.org/">Hardhat</a> 是用于 EVM 合约和应用的开发和部署工具。在本系列探讨的三种部署工具中，Hardhat 是最通用的，它允许大量可自定义的设置并安全地部署到 Neon 的主网、开发网和测试网。但是，与 Remix 不同的是，Hardhat 只能通过命令行界面使用，而不是 IDE。</p>
<h2 id="准备工作before-you-begin">准备工作(Before You Begin)</h2>
<p>Before you start the tutorial below, make sure that the following is true:</p>
<p>在开始下面的教程之前，请确保满足以下条件：</p>
<ul>
<li>
<p>MetaMask is installed on your device.<br>
MetaMask 已安装在您的设备上。</p>
</li>
<li>
<p>MetaMask is configured for the Neon EVM.<br>
MetaMask已为Neon EVM 配置过。</p>
</li>
<li>
<p>NodeJS v8.9.4 or later is installed on your device.<br>
NodeJS v8.9.4 或更高版本已安装在您的设备上。</p>
</li>
<li>
<p>Git is installed on your device. On Windows, use Git Bash.<br>
Git 已安装在您的设备上。在 Windows 上，使用 Git Bash。</p>
</li>
</ul>
<p><a href="https://docs.neon-labs.org/docs/wallet/metamask_setup">Follow this guide to install and configure MetaMask</a>.</p>
<p><a href="https://docs.neon-labs.org/docs/wallet/metamask_setup">按照本指南安装和配置 MetaMask</a>。</p>
<h1 id="erc-20-教程-erc-20-tutorial">ERC-20 教程 (ERC-20 Tutorial)</h1>
<p>The following tutorial will explain how to deploy a simple ERC-20 token contract to the Neon Devnet using Hardhat.</p>
<p>以下教程将解释如何使用 Hardhat 将简单的 ERC-20 代币合约部署到 Neon Devnet。</p>
<p><strong>第1步：安装Hardhat (Step 1: Install Hardhat)</strong></p>
<p>Using Git, clone the ERC-20 Hardhat project from Neon’s remote repository and navigate to it with the following commands:</p>
<p>使用 Git，从 Neon 的远程存储库中克隆 ERC-20 Hardhat 项目，并使用以下命令导航到该项目：</p>
<pre><code>git clone https://github.com/neonlabsorg/examples.git

cd examples/simple-erc20-hardhat
</code></pre>
<p>Then, run the following command to install Hardhat and the dependencies necessary to run the example project:</p>
<p>然后，运行以下命令来安装 Hardhat 和运行示例项目所需的依赖项：</p>
<pre><code>npm install
</code></pre>
<p>If the above command results in an error, run the following command:</p>
<p>如果上述命令导致错误，请运行以下命令：</p>
<pre><code>npm cache clear --force

npm install
</code></pre>
<p><strong>第2步：设置 MetaMask 帐户 (Step 2: Set Up MetaMask Accounts)</strong></p>
<p>To interact with the soon-to-be-deployed contracts, you’ll need to create two new accounts in MetaMask. Before you begin this step, make sure that MetaMask is connected to the Neon Devnet.</p>
<p>要与即将部署的合约交互，您需要在 MetaMask 中创建两个新账户。在开始此步骤之前，请确保 MetaMask 已连接到 Neon Devnet。</p>
<p>In MetaMask, create two new accounts. To create a new account in MetaMask, click on your current account’s icon in the top right of the MetaMask extension pop-up. A drop-down menu will appear. From the drop-down menu, select“Create an Account”.</p>
<p>在 MetaMask 中，创建两个新帐户。要在 MetaMask 中创建新帐户，请单击 MetaMask 扩展弹出窗口右上角的当前帐户图标。将出现一个下拉菜单。从下拉菜单中，选择“创建帐户”。</p>
<p>Then, obtain some Devnet NEON tokens for these accounts using the <a href="https://docs.neon-labs.org/docs/developing/utilities/faucet">NeonFaucet</a>.</p>
<p>然后，使用 <a href="https://docs.neon-labs.org/docs/developing/utilities/faucet">NeonFaucet</a> 为这些帐户获取一些 Devnet NEON代币。</p>
<p>Next, click on the three vertical dots to the right of your currently displayed account name and wallet address. In this drop-down menu that opens, select “Account Details” then “Export Private Key”. Enter your password and select “Confirm” to get access to the private key for that account.</p>
<p>接下来，单击您当前显示的帐户名称和钱包地址右侧的三个垂直点。在打开的下拉菜单中，选择“帐户详细信息”，然后选择“导出私钥”。输入您的密码并选择“确认”，访问该帐户的私钥。</p>
<p>Copy both accounts’ private keys and paste them into the hardhat.config.js file in the project folder, replacing the placeholder text in lines 11 and 12 of that file. Make sure to prefix these keys with “0x” in the configuration file.</p>
<p>复制两个帐户的私钥并将它们粘贴到项目文件夹中的 hardhat.config.js 文件中，替换该文件第 11 行和第 12 行中的占位符文本。确保在配置文件中为这些键添加前缀“0x”。</p>
<p><strong>第3步：编译合约 (Step 3: Compile Contracts)</strong></p>
<p>To compile the project’s contracts (located in the “contracts/” folder), run the following command:</p>
<p>要编译项目的合约（位于“contracts/”文件夹中)，请运行以下命令：</p>
<pre><code>./node_modules/.bin/hardhat compile
</code></pre>
<p>The output from this command should be similar to the following:</p>
<p>此命令的输出应类似于以下内容：</p>
<figure data-type="image" tabindex="2"><img src="https://miro.medium.com/max/1390/0*3UmBzLArH17UDm8a" alt="" loading="lazy"></figure>
<p><strong>第4步：运行测试 (Step 4: Run Tests)</strong></p>
<p>To run the project tests before deploying, run the following command. It will compile the contracts, deploy them to the Neon Devnet, and run all the tests in the “tests/” folder to make sure the contracts are working as expected.</p>
<p>要在部署之前运行项目测试，请运行以下命令。它将编译合约，将它们部署到 Neon Devnet，并运行“tests/”文件夹中的所有测试，确保合约按预期工作。</p>
<pre><code>./node_modules/.bin/hardhat test
</code></pre>
<p>If the tests all pass, the output of this command should look something like this:</p>
<p>如果测试全部通过，则此命令的输出应如下所示：</p>
<figure data-type="image" tabindex="3"><img src="https://miro.medium.com/max/1400/0*HTPrkW1NlR4db3rW" alt="" loading="lazy"></figure>
<p><strong>第5步：部署合约 (Step 5: Deploy Contracts)</strong></p>
<p>To deploy the project’s contracts, simply run the command below to run the deployment script in the “scripts/” directory:</p>
<p>要部署项目的合约，只需运行以下命令以运行“scripts/”目录中的部署脚本：</p>
<pre><code>./node_modules/.bin/hardhat run ./scripts/deploy.js
</code></pre>
<p>You should see output in your terminal similar to the following:</p>
<p>您应该会在终端中看到类似于以下内容的输出：</p>
<figure data-type="image" tabindex="4"><img src="https://miro.medium.com/max/1400/0*yc0OWZJ6bh44kzuc" alt="" loading="lazy"></figure>
<p><strong>第6步：将项目连接到 (MetaMaskStep 6: Connect Project to MetaMask)</strong></p>
<p>To use this newly deployed ERC-20-style Neon Devnet token with ease, follow <a href="https://metamask.zendesk.com/hc/en-us/articles/360015489031-How-to-add-unlisted-tokens-custom-tokens-in-MetaMask#h_01FWH492CHY60HWPC28RW0872H">these instructions</a> to import the token as an asset in MetaMask. Use the “contract address” from the output in Step 5 for the “Token Contract Address” in the instructions.</p>
<p>要轻松使用这个新部署的 ERC-20 式 Neon Devnet 代币，请按照 <a href="https://metamask.zendesk.com/hc/en-us/articles/360015489031-How-to-add-unlisted-tokens-custom-tokens-in-MetaMask#h_01FWH492CHY60HWPC28RW0872H">这些说明</a>将代币作为资产导入 MetaMask。将步骤 5 输出中的“合约地址”用于说明中的“代币合约地址”。</p>
<p>Once you complete this final step, you will be able to see your new ERC-20 assets in the MetaMask profiles of the new test accounts.</p>
<p>完成最后一步后，您将能够在新测试帐户的 MetaMask 配置文件中看到您的新 ERC-20 资产。</p>
<h2 id="结论-conclusion">结论 (Conclusion)</h2>
<p>Of the three tools for Neon deployment explored over the course of this article series, Hardhat is the most useful and versatile. With a variety of customization options available, plus the ability to deploy to Mainnet due to no security vulnerabilities like with Truffle, Hardhat is the go-to tool for developers looking to launch their project into the “real world” using Neon.</p>
<p>在本系列文章中探讨的用于 Neon 部署的三种工具中，Hardhat 是最有用和最通用的。凭借各种可用的自定义选项，以及没有Truffle类似的安全漏洞，而有能力可以部署到主网，Hardhat 是希望使用 Neon 将项目启动到“现实世界”的开发人员的首选工具。</p>
<p>Visit the <a href="https://docs.neon-labs.org/docs/developing/deploy_facilities/using_truffle">Neon docs</a> for a complete tutorial on using Hardhat to deploy your dApps.</p>
<p>访问 <a href="https://docs.neon-labs.org/docs/developing/deploy_facilities/using_truffle">Neon 文档</a>，获取有关使用 Hardhat 部署 dApp 的完整教程。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模块化执行的案例(第一部分) The Case for Modular Execution (Part 1)]]></title>
        <id>https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/</id>
        <link href="https://chainguys.github.io/post/mo-kuai-hua-zhi-xing-de-an-li-di-yi-bu-fen-the-case-for-modular-execution-part-1/">
        </link>
        <updated>2022-10-13T03:22:52.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://fuel-labs.ghost.io/content/images/size/w2000/2022/10/the-case-for-modular-execution-part-1.png" alt="The Case for Modular Execution (Part 1)" loading="lazy"><br>
How modular execution layers enable scalability by decoupling computation from verification.<br>
模块化执行层如何通过将计算与验证解耦来实现可扩展性。</p>
<hr>
<h2 id="模块化执行案例-the-case-for-modular-execution">模块化执行案例 (The Case for Modular Execution)</h2>
<p>The blockchain space is increasingly moving toward a modular architecture in order to achieve true scalability. Even chains like Ethereum, which were previously fully monolithic, are <a href="https://ethereum.org/en/upgrades/sharding/">shifting</a> to a modular design to overcome the challenges that come with monolithic blockchain designs.</p>
<p>为了实现真正的可扩展性，区块链空间正越来越多地向模块化架构发展。甚至像以太坊这样以前完全是单片的，现在正在 <a href="https://ethereum.org/en/upgrades/sharding/">转变</a> 到模块化设计，进而克服单片区块链设计带来的挑战。</p>
<p>One of the core components of the <a href="https://fuel-labs.ghost.io/beyond-monolithic-the-modular-blockchain-paradigm/">modular blockchain stack</a> is the execution layer. <strong><a href="https://www.fuel.network/">Fuel</a> is building the fastest execution layer for the modular blockchain stack.</strong></p>
<p><a href="https://fuel-labs.ghost.io/beyond-monolithic-the-modular-blockchain-paradigm/">模块化区块链技术栈</a> 的核心组件之一是执行层。 <strong><a href="https://www.fuel.network/">Fuel</a> 正在为模块化区块链技术栈构建最快的执行层。</strong></p>
<figure data-type="image" tabindex="1"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-13.png" alt="" loading="lazy"></figure>
<p><strong>What is a modular execution layer? And how will they enable more scalable blockchain systems?</strong></p>
<p><strong>什么是模块化执行层？他们将如何启用更具可扩展性的区块链系统？</strong></p>
<p>Modular execution layers offer two core benefits over their monolithic counterparts:<br>
与单体执行层相比，模块化执行层提供了两个核心优势：</p>
<ol>
<li>
<p>Monolithic chains couple computation and verification on the same layer, leading to sub-par security and limited scalability. <strong>Modular execution layers</strong> avoid this by decoupling computation and verification, allowing for much more robust security guarantees at scale.<br>
单片链将计算和验证耦合在同一层，导致安全性低于标准，可扩展性有限。 <strong>模块化执行层</strong>通过解耦计算和验证来避免这种情况，在规模上提供更强大的安全保证。</p>
</li>
<li>
<p>Monolithic chains are locked into inefficient technologies when it comes to the speed and variety of computation they can support. On the other hand, <strong>modular execution layers</strong> can be specifically designed to optimize for efficient computation.<br>
单片链在可以支持的计算速度和多样性方面被锁定在低效的技术中。另一方面，<strong>模块化执行层</strong>可以专门设计用于优化高效计算。</p>
</li>
</ol>
<p>This post elaborates on the first core benefit, with the second being explored in an upcoming Part 2.</p>
<p>本文详细阐述第一个核心优势，第二个核心优势将在即将发布的第二部分中进行探讨。</p>
<hr>
<h2 id="单片区块链基础知识计算和验证-monolithic-blockchain-basics-computation-verification">单片区块链基础知识：计算和验证 (Monolithic Blockchain Basics: Computation &amp; Verification)</h2>
<p>To understand the innovations that come from modular execution layers (MELs), first we need to understand how monolithic blockchains handle computation and verification.</p>
<p>了解来自模块化执行层 (MEL) 的创新，需要我们首先了解单片区块链如何处理计算和验证。</p>
<p>Blockchains rely on a network of entities which execute transactions and bundle them together into a block - these are known as <em>block producers</em>. Without checks and balances, a malicious block producer could include invalid transactions in a block (for example, minting tokens to their own address). To prevent this, blockchains rely on a network of other nodes to determine the validity of a block before adding it to their version of the chain.</p>
<p>区块链依赖于一个实体网络，这些实体执行交易并将它们打包在一起形成一个区块——这些被称为 <em>区块生产者</em> 。如果没有制衡，恶意区块生产者可能会在区块中包含无效交易(例如，将代币铸造到他们自己的地址)。为了防止这种情况，区块链依赖于其他节点的网络来确定一个块的有效性，然后再将其添加到他们链的版本中。</p>
<p>This leads to two core functions required for a blockchain to operate:<br>
这导致了区块链运行所需的两个核心功能：</p>
<ul>
<li><strong>Block Production (i.e. computation)</strong> - Executing transactions and applying individual state transitions to build a block.<br>
<strong>区块生产(即计算)</strong> - 执行交易并应用单个状态转换来构建块。</li>
<li><strong>Block Validation (i.e. verification)</strong> - Confirming that the state transitions are valid.<br>
<strong>区块验证(即验证)</strong> - 确认状态转换有效。</li>
</ul>
<h3 id="单片链上的计算和验证-computation-verification-on-monolithic-chains">单片链上的计算和验证 (Computation &amp; Verification on Monolithic Chains)</h3>
<p><em>NOTE: For ease of understanding, this section provides a simplified explanation of how block production and verification work on monolithic blockchains. In reality, the process is more complex, and may differ depending on the design of the specific chain. However, many of the same core principles apply.</em></p>
<p><em>注意：为方便理解，本节提供了对如何在单片区块链上进行区块生产和验证工作的简化说明。实际上，该过程更复杂，并且可能因特定链的设计而异。然而，许多相同的核心原则也适用。</em></p>
<p>In most monolithic blockchain designs, computation and verification are performed by the same entities - validators (i.e. full nodes). When a user sends a transaction, a validator will execute the transaction and then include the corresponding state transition in a block. Once a block is created and propagated, other full nodes download the block and re-execute the transactions in the block in order to confirm it is valid. If the block is valid, assuming they are honest, the full nodes append that block onto their version of the chain, thereby attesting to its validity.</p>
<p>在大多数单片区块链设计中，计算和验证由相同的实体 - 验证者(即完整节点)执行。当用户发送交易时，验证者将执行交易，然后将相应的状态转换包含在块中。一旦创建并传播了一个块，其他完整节点就会下载该块并重新执行该块中的交易来确认它是有效的。如果该块是有效的，假设他们是诚实的，那么全节点将该块附加到他们链的版本上，从而证明它的有效性。</p>
<p>Sometimes, applications or users need to access the state of the blockchain, but don’t want to incur the high resource requirements of running a full node and independently validating all transactions. For this purpose they can run <a href="https://www.parity.io/blog/what-is-a-light-client/">light clients</a>, which assume the blocks provided by full nodes include only valid transactions. They do not download the full blockchain, nor do they verify that all previous transactions are valid. Instead, they have to trust that the majority of full nodes are honest (i.e. have only included valid blocks in their copy of the chain).</p>
<p>有时，应用或用户需要访问区块链的状态，但不希望产生运行完整节点和独立验证所有交易的高资源需求。为此，他们可以运行 <a href="https://www.parity.io/blog/what-is-a-light-client/">轻客户端</a>，假设全节点提供的块仅包含有效交易。他们不会下载完整的区块链，也不会验证所有之前的交易是否有效。相反，他们必须相信大多数完整节点是诚实的(即在其链副本中仅包含有效块)。</p>
<figure data-type="image" tabindex="2"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-14.png" alt="" loading="lazy"></figure>
<p>This is called the <em>honest majority assumption</em>, and is the reason that most monolithic blockchains are vulnerable to 51% attacks. Under the monolithic model, because an honest majority of full nodes is required to verify that the blockchain is valid, light clients are forced to trust the majority. If more than half of the full nodes are dishonest, light clients have no way of knowing this, so they will end up following an invalid chain.</p>
<p>这被称为 <em>诚实大多数假设</em>，这也是大多数单片区块链容易受到 51% 攻击的原因。在单片模型下，由于需要诚实的大多数完整节点来验证区块链是否有效，因此轻客户端被迫信任大多数。如果超过一半的全节点不诚实，轻客户端无法知道这一点，因此他们最终会跟随一条无效的链。</p>
<h3 id="诚实多数假设-可扩展性的限制-honest-majority-assumption-limits-to-scalability">诚实多数假设 - 可扩展性的限制 (Honest Majority Assumption - Limits to Scalability)</h3>
<p>The scalability of monolithic chains is severely limited by their reliance on this honest majority assumption. This is because, in order to increase transaction throughput, block size and/or frequency must be increased to enable more transactions to be processed in the same amount of time. This increases the resource requirements (and associated costs) for full nodes; bigger/faster blocks = more computation = higher costs.</p>
<p>单片链的可扩展性，受到其对这种诚实多数假设依赖的严重限制。这是因为，为了增加交易吞吐量，必须增加块大小和/或频率，以使更多交易能够在相同的时间内处理。这增加了全节点的资源需求(和相关成本)；更大/更快的块 = 更多的计算 = 更高的成本。</p>
<figure data-type="image" tabindex="3"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-15.png" alt="" loading="lazy"></figure>
<p>As the cost of running a full node increases, more entities will opt to run a light client instead, relying on a smaller and smaller network of full nodes to verify the validity of the chain. <strong>This increasing centralization of block validation is a major threat to security for monolithic chains</strong>, as a more centralized pool of validators is more vulnerable to attacks and also more easily able to collude.</p>
<p>随着运行全节点成本的增加，更多实体将选择运行轻客户端，依靠越来越小的全节点网络来验证链的有效性。 <strong>这种日益集中的区块验证是对单片链安全性的主要威胁</strong>，因为更集中的验证者池更容易受到攻击，也更容易串通。</p>
<hr>
<h2 id="模块化执行解耦计算和验证-modular-execution-decoupling-computation-verification">模块化执行：解耦计算和验证 (Modular Execution: Decoupling Computation &amp; Verification)</h2>
<p>The good news is that blockchain systems can move away from designs that rely on an honest majority assumption. In order to avoid this pitfall of monolithic design, <strong>the modular blockchain stack decouples computation from verification</strong>. By moving execution (i.e. computation) off the base chain (often referred to as the “parent chain”), increased scale can be achieved without compromising on decentralization.</p>
<p>好消息是区块链系统可以摆脱依赖诚实大多数假设的设计。为了避免这种单片设计的缺陷，<strong>模块化区块链技术栈将计算与验证分离</strong>。通过将执行(即计算)移出基础链(通常称为“父链”)，可以在不影响去中心化的情况下实现规模扩大。</p>
<h3 id="什么是模块化执行层-what-is-a-modular-execution-layer">什么是模块化执行层？ (What is a Modular Execution Layer?)</h3>
<p>Within the modular blockchain stack, the execution layer is responsible for computation - in other words, processing transactions and applying individual state transitions.</p>
<p>在模块化区块链技术栈中，执行层负责计算——换句话说，处理交易和应用单独的状态转换。</p>
<p>Fuel <a href="https://fuel-labs.ghost.io/introducing-fuel-the-fastest-modular-execution-layer/">defines</a> a modular execution layer as: <strong>a verifiable computation system designed for the modular blockchain stack</strong>. More concretely, a fraud- or validity-provable blockchain (or other computation system) that leverages a modular blockchain for data availability.</p>
<p>Fuel <a href="https://fuel-labs.ghost.io/introducing-fuel-the-fastest-modular-execution-layer/">定义</a> 了模块化执行层：<strong>为模块化区块链技术栈设计的可验证计算系统</strong>。更具体地说，一种可验证欺诈或有效性的区块链(或其他计算系统)，它利用模块化区块链来实现数据可用性。</p>
<figure data-type="image" tabindex="4"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-16.png" alt="" loading="lazy"></figure>
<p>To clarify further, computation systems are not modular execution layers if they: 1) are not fraud- or validity-provable, or 2) do not offload data availability to another layer.</p>
<p>为了进一步澄清，如果计算系统：1) 不能证明欺诈或有效性，或 2) 不将数据可用性重载到另一层，则它们不是模块化执行层。</p>
<p>Like monolithic blockchains, modular execution layers employ a network of dedicated block producers. These entities handle the resource-intensive process of executing transactions and producing blocks. However, unlike in monolithic systems, <strong>verification is not handled on the execution layer</strong>, but rather on the lower levels of the modular blockchain stack.</p>
<p>与单片区块链一样，模块化执行层采用专门的区块生产者网络。这些实体处理执行交易和生成区块的资源密集型过程。但是，与单片系统不同，<strong>验证不在执行层处理</strong>，而是在模块化区块链技术栈的较低级别处理。</p>
<h3 id="验证-让区块生产者保持诚实-verification-keeping-block-producers-honest">验证 - 让区块生产者保持诚实 (Verification - Keeping Block Producers Honest)</h3>
<p>The genius of modular execution is that as long as verification (i.e. block validation) is decentralized, computation (i.e. block production) does not need to be decentralized. Block sizes can be increased, leading to centralization of nodes which produce blocks - but as long as verification is decoupled, invalid blocks will not be added to the chain.</p>
<p>模块化执行的天才之处在于，只要验证(即区块验证)是去中心化的，计算(即区块生产)就不需要去中心化。可以增加块大小，从而导致产生块的节点集中化——但只要将验证解耦，无效块就不会被添加到链中。</p>
<p>But how does this work? <strong>How can we ensure security is preserved if we allow block production to remain centralized?</strong> This is where modularity comes into play.</p>
<p>但这是如何工作的？ <strong>如果我们允许块生产保持中心化，我们如何确保安全性？</strong> 这就是模块化发挥作用的地方。</p>
<p>Modular execution layers abstract the resource-intensive function of execution to powerful block producers which bundle and execute batches of transactions, and periodically post these as blocks to the parent chain (settlement/consensus/data availability layers). In order to keep these block producers honest, there are additional non-block-producing full nodes (often referred to as “verifiers” or “provers”) which download and re-execute the blocks posted to the parent chain to ensure they contain only valid transactions.</p>
<p>模块化执行层将资源密集型执行功能抽象给强大的区块生产者，这些区块生产者打包并执行批量交易，定期将这些作为区块发布到父链(结算/共识/数据可用性层)。为了让这些区块生产者保持诚实，还有额外的非区块生产完整节点(通常称为“验证者”或“证明者”)下载并重新执行发布到父链的区块，以确保它们仅包含有效交易。</p>
<p>The specifics of how these full nodes communicate the validity or invalidity of transactions differs depending on whether the modular execution layer employs an optimistic or zero-knowledge model. In the case of optimistic MELs, full nodes only take action (via fraud proofs) when they detect an invalid transaction. Conversely, in the case of zero-knowledge MELs, full nodes actively attest to the validity of transactions (via validity proofs). In either case, <strong>the validity or invalidity of all transactions provided by the block producer is attested to on the parent chain, not on the modular execution layer</strong>.</p>
<p>这些完整节点如何传达交易的有效性或无效性的细节，取决于模块化执行层是采用乐观模型还是零知识模型。在乐观 MEL 的情况下，全节点仅在检测到无效交易时才采取行动(通过欺诈证明)。相反，在零知识 MEL 的情况下，全节点主动证明交易的有效性(通过有效性证明)。无论哪种情况，<strong>区块生产者提供的所有交易的有效性或无效性都在父链上证明，而不是在模块化执行层上</strong>。</p>
<h3 id="一个例子乐观模块化执行层的欺诈证明-an-example-fraud-proofs-on-optimistic-modular-execution-layers">一个例子：乐观模块化执行层的欺诈证明 (An Example: Fraud Proofs on Optimistic Modular Execution Layers)</h3>
<p>To provide a deeper illustration, let’s explore the case of optimistic MELs (under which it is assumed that all transactions are valid unless otherwise proven). If even a single full node on the modular execution layer detects an invalid transaction within a block posted on the parent chain, they can generate a fraud proof (within a predefined “dispute resolution window”) which cryptographically proves that the transaction is invalid.</p>
<p>为了提供更深入的说明，让我们探讨乐观 MEL 的情况(假设所有交易都是有效的，除非另有证明)。即使模块化执行层上的单个完整节点检测到发布在父链上的块中的无效交易，它们也可以生成欺诈证明(在预定义的“争议解决窗口”内)，以加密方式证明交易无效。</p>
<p>Depending on the structure of the particular modular stack, this may be dealt with in several ways, for example:</p>
<p>根据特定模块化技术栈的结构，这可以通过多种方式处理，例如：</p>
<p><strong>In modular stacks with a settlement layer:</strong></p>
<p><strong>在具有结算层的模块化技术栈中：</strong></p>
<ul>
<li>
<p>The full node submits the fraud proof to a dedicated dispute resolution contract on the settlement layer, which re-executes the transaction directly (note that this requires the MEL transactions to be structured in a way which makes them fraud-provable on the settlement layer’s VM in a deterministic manner - for example, the <a href="https://fuellabs.github.io/fuel-docs/master/technology/fraud_proofs.html">FuelVM is designed to be fraud-provable within the EVM</a> to enable settlement on Ethereum).<br>
全节点将欺诈证明提交给结算层上的专用争议解决合约，该合约直接重新执行交易(请注意，这要求 MEL 交易的结构使其在结算层的欺诈可证明VM 以一种确定性的方式 - 例如，<a href="https://fuellabs.github.io/fuel-docs/master/technology/fraud_proofs.html">FuelVM被设计在 EVM 内完成可证明欺诈性</a> 来获得在以太坊的结算能力)。</p>
</li>
<li>
<p>If the transaction is invalid, the offending block producer is punished via slashing (i.e. they lose funds), the “whistleblower” is rewarded with a portion of these funds, and the state of the chain is reverted to before the invalid transaction. Because there is no guarantee that any transaction following the invalid one corresponds to a valid state, these subsequent transactions are re-executed.</p>
</li>
<li>
<p>如果交易无效，违规的区块生产者将受到惩罚(即他们损失资金)，“举报人”将获得部分资金奖励，并将链的状态恢复到无效交易之前的状态。因为不能保证在无效交易之后的任何交易都对应于有效状态，所以这些后续交易被重新执行。</p>
</li>
</ul>
<p><strong>In modular stacks <a href="https://forum.celestia.org/t/rollups-on-celestia/55#optimistic-rollups-10">without a settlement layer</a>:</strong></p>
<p><strong>在模块化技术栈中若<a href="https://forum.celestia.org/t/rollups-on-celestia/55#optimistic-rollups-10">没有结算层</a>：</strong></p>
<ul>
<li>
<p>The full node gossips the fraud proof via a peer-to-peer network to warn light clients that the block contains an invalid transaction. Using the fraud proof as evidence of the block producer’s dishonest behavior, full nodes can propose a penalty transaction on the parent chain, which slashes the block producer’s funds.<br>
全节点通过点对点网络传播欺诈证明，警告轻客户端该块包含无效交易。使用欺诈证明作为出块人不诚实行为的证据，全节点可以在父链上提出惩罚交易，从而削减出块人的资金。</p>
</li>
<li>
<p>Because there is no settlement layer to dictate the “canonical” version of the chain, malicious full nodes could theoretically choose not to reject the block; however, the fraud proof has already been communicated to light clients, so they know not to follow a malicious full node’s version of the chain. As a result, social consensus guarantees that the invalid block will be rejected.<br>
由于没有结算层来规定链的“规范”版本，恶意全节点理论上可以选择不拒绝区块；但是，欺诈证明已经传达给轻客户端，因此他们知道不要遵循恶意的全节点版本的链。结果，社会共识保证了无效块将被拒绝。</p>
</li>
</ul>
<p>In either case, because the verification process is enshrined on the parent chain instead of the execution layer, security is outsourced to the parent chain, meaning the execution layer on its own can operate with lower security guarantees. <strong>Even if 99% of full nodes on the execution layer are dishonest, it only takes one honest full node to ensure the execution layer only includes valid transactions.</strong></p>
<p>在任何一种情况下，由于验证过程是在父链上而不是在执行层上进行的，因此安全性被外包给了父链，这意味着执行层本身可以在较低的安全保证下运行。 <strong>即使执行层上 99% 的全节点都是不诚实的，也只需要一个诚实的全节点来确保执行层只包含有效交易。</strong></p>
<p>This means that instead of relying on an honest majority of full nodes, modular execution layers (and MEL light clients) can operate on a <em>single honest minority assumption</em>.</p>
<p>这意味着，模块化执行层(和 MEL 轻客户端)可以在 <em>单个诚实少数假设</em> 上运行，而不是依赖于诚实的大多数完整节点。</p>
<figure data-type="image" tabindex="5"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-17.png" alt="" loading="lazy"></figure>
<p><em>On modular execution layers, light clients only need to rely on there being a single honest full node in order to guarantee the validity of the chain</em></p>
<p><em>在模块化执行层上，轻客户端只需要依赖一个诚实的全节点就可以保证链的有效性</em></p>
<p>Whereas an invalid block can only be reverted by a majority of full nodes in a monolithic system, a single full node in a modular system can force an invalid transaction to be reverted by using fraud/validity proofs.</p>
<p>无效块只能由单片系统中的大多数完整节点恢复，而模块化系统中的单个完整节点可以通过使用欺诈/有效性证明来强制恢复无效交易。</p>
<h3 id="这如何实现可扩展性-how-this-enables-scalability">这如何实现可扩展性 (How this Enables Scalability)</h3>
<p>Allowing computation to happen off the parent chain allows for massive increases in transaction throughput. Block size can be significantly increased without concerns about centralization of block production, as the separate block validation process keeps block producers honest.</p>
<p>允许在父链之外进行计算可以大幅增加交易吞吐量。区块大小可以显着增加，而无需担心块生产的中心化，因为单独的块验证过程使块生产者保持诚实。</p>
<p>While larger blocks do place a higher burden on the full nodes performing validation, the honest minority assumption means that centralization in this area is less of a threat, as centralization-based vulnerabilities which rely on a dishonest majority are rendered impossible.</p>
<p>虽然较大的区块确实会给执行验证的完整节点带来更高的负担，但诚实的少数假设意味着该领域的中心化威胁较小，因为依赖不诚实多数的基于中心化的漏洞变得不可能。</p>
<p>Light clients can also run with significantly higher security guarantees under a modular architecture, as fraud proofs enable them to identify invalid transactions based on a proof from a single honest full node (as opposed to monolithic systems, which require light clients to trust that at least half of the full nodes are honest).</p>
<p>轻客户端还可以在模块化架构下以显着更高的安全保证运行，因为欺诈证明使他们能够根据来自单个诚实完整节点的证明来识别无效交易(与单片系统相反，单片系统至少需要轻客户端信任一半的完整节点是诚实的)。</p>
<figure data-type="image" tabindex="6"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-18.png" alt="" loading="lazy"></figure>
<p><em>Light clients on modular execution layers have significantly higher security guarantees than their monolithic counterparts</em> <em>模块化执行层上的轻客户端比它们的单体客户端具有更高的安全保证</em></p>
<p>In addition, block producers are aware that any malicious activity will be detected and will result in slashing, so they are less likely to even attempt to behave dishonestly. As such, the execution layer can be computation-optimized (i.e. handle a lot of transactions) while relying on security-optimized lower levels of the modular stack.</p>
<p>此外，区块生产者知道任何恶意活动都会被检测到并导致处罚，因此他们甚至不太可能试图做出不诚实的行为。因此，执行层可以进行计算优化(即处理大量交易)，同时依赖模块化技术栈的安全优化的较低级别。</p>
<hr>
<h2 id="模块化执行潜在挑战-modular-execution-potential-challenges">模块化执行：潜在挑战 (Modular Execution: Potential Challenges)</h2>
<p>This modular architecture does present some additional technical and game-theoretic challenges.</p>
<p>这种模块化架构确实提出了一些额外的技术和博弈论挑战。</p>
<h3 id="数据可用性-data-availability">数据可用性 (Data Availability)</h3>
<p>While fraud/validity proofs enable honest full nodes to prove fraud, there is an additional problem: <strong>data availability</strong>. In order to generate proofs, full nodes rely on block availability, as they need to download and re-execute all transactions in a block to determine its validity and generate a proof.</p>
<p>虽然欺诈/有效性证明使诚实的完整节点能够证明欺诈，但还有一个问题：<strong>数据可用性</strong>。为了生成证明，全节点依赖于区块的可用性，因为它们需要下载并重新执行块中的所有交易以确定其有效性并生成证明。</p>
<p>A malicious block producer could theoretically publish only block headers to the parent chain, potentially withholding some or all of the corresponding data. This prevents full nodes from being able to generate fraud/validity proofs to alert light clients to the issue.</p>
<p>理论上，恶意区块生产者可以只向父链发布区块头，可能会保留部分或全部相应数据。这可以防止完整节点生成欺诈/有效性证明来提醒轻客户端注意问题。</p>
<p>When attempting to validate a block, it is trivial for full nodes to identify when data has been withheld by a malicious block producer. In this case, they can simply assume the chain is invalid and fork away from it. <strong>But how can light clients determine whether data has been withheld by a block producer without downloading the whole block?</strong></p>
<p>当尝试验证一个块时，全节点很容易识别数据何时被恶意块生产者扣留。在这种情况下，他们可以简单地假设该链无效并从中分叉。 <strong>但是轻客户端如何在不下载整个区块的情况下确定数据是否被区块生产者扣留？</strong></p>
<p>A new technology called <a href="https://hackmd.io/@vbuterin/sharding_proposal#ELI5-data-availability-sampling">data availability sampling</a> (DAS) enables light clients to probabilistically determine whether the entirety of a block has been published. In short, light clients request small random small portions (or “samples”) of the block from full nodes.</p>
<p>一种称为<a href="https://hackmd.io/@vbuterin/sharding_proposal#ELI5-data-availability-sampling">数据可用性采样</a> (DAS) 的新技术使轻客户端能够以概率方式确定是否已发布整个块。简而言之，轻客户端从完整节点请求块的小随机小部分(或“样本”)。</p>
<figure data-type="image" tabindex="7"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-19.png" alt="" loading="lazy"></figure>
<p><em>Light clients request subsets (“samples”) of the block from full nodes (source:</em> <a href="https://hackmd.io/@vbuterin/sharding_proposal#ELI5-data-availability-sampling"><em>Vitalik Buterin</em></a><em>)</em> <em>轻客户端从完整节点请求区块的子集(“样本”)(来源：</em> <a href="https://hackmd.io/@vbuterin/sharding_proposal#ELI5-data-availability-sampling"><em>Vitalik Buterin</em></a><em>)</em></p>
<p>If all the requested samples are available, then assuming there are enough light clients performing data availability sampling, this probabilistically proves that the entire block is available. If any portions of the block are not available, light clients know that data has been withheld, and can therefore fork away from that version of the chain.</p>
<p>如果所有请求的样本都可用，那么假设有足够多的轻客户端执行数据可用性采样，这在概率上证明了整个块是可用的。如果块的任何部分不可用，轻客户端知道数据已被保留，因此可以从该版本的链中分叉。</p>
<p>A full explanation of this technology is out of scope for this post, but you can read more about it <a href="https://www.paradigm.xyz/2022/08/das">here</a>. Ultimately, the important takeaway is that DAS enables light clients to identify invalid blocks even when a malicious block producer withholds data.</p>
<p>对这项技术的完整解释超出了本文的范围，但您可以在 <a href="https://www.paradigm.xyz/2022/08/das">此处</a> 阅读更多相关信息。最终，重要的一点是 DAS 使轻客户端能够识别无效块，即使恶意块生产者隐瞒数据也是如此。</p>
<h3 id="验证者的困境-verifiers-dilemma">验证者的困境 (Verifier’s Dilemma)</h3>
<p>Another potential issue is the phenomenon referred to as the “verifier’s dilemma”. The simplified version is as follows:</p>
<p>另一个潜在的问题是被称为“验证者困境”的现象。简化版如下：</p>
<ul>
<li>
<p>If block producers know that full nodes will identify dishonest activity, they will behave honestly in order to avoid being slashed.<br>
如果区块生产者知道全节点会识别不诚实的活动，他们会诚实行事以避免被处罚。</p>
</li>
<li>
<p>Over time, if full nodes assume block producers will continue to behave honestly, they have no incentive to continue validating blocks, as they will never receive a reward for identifying an invalid transaction.<br>
随着时间的推移，如果全节点假设区块生产者将继续诚实行事，他们就没有动力继续验证区块，因为他们永远不会因识别无效交易而获得奖励。</p>
</li>
<li>
<p>If full nodes are not financially incentivized to continue validating blocks, they may stop doing so. At this point, it becomes viable for block producers to behave dishonestly. Even if there is still a non-zero amount of full nodes, it may become financially viable for the block producer to bribe the remaining full nodes to ignore a sufficiently valuable invalid transaction.<br>
如果全节点没有经济上的激励来继续验证区块，他们可能会停止这样做。在这一点上，区块生产者的不诚实行为变得可行。即使仍然存在非零数量的完整节点，对于区块生产者而言，贿赂剩余的完整节点以忽略足够有价值的无效交易可能在财务上是可行的。</p>
</li>
</ul>
<p>This ends in a circular conundrum whereby the more secure a modular execution layer becomes (i.e. the less incentive there is for a block producer to behave dishonestly), the more it tends toward lower security (i.e. full nodes are no longer incentivized to validate blocks). On the other hand, the less secure it is, the more it tends toward higher security.</p>
<p>这以一个循环难题告终，即模块化执行层变得越安全(即区块生产者不诚实行为的动机越少)，它就越倾向于降低安全性(即不再激励完整节点来验证区块) .另一方面，它越不安全，它就越倾向于更高的安全性。</p>
<figure data-type="image" tabindex="8"><img src="https://fuel-labs.ghost.io/content/images/2022/10/image-22.png" alt="" loading="lazy"></figure>
<p>This dilemma can be mitigated through a number of avenues (for a game-theoretic analysis of these factors, <a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-enough-than-you-think-cb23e6e6f11c">see this extensive post</a>):</p>
<p>可以通过多种途径缓解这种困境(有关这些因素的博弈论分析，<a href="https://medium.com/onther-tech/optimistic-rollup-is-not-secure-%E6%AF%94%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E8%BF%98%E5%A4%9A-cb23e6e6f11c">请参阅这篇帖子</a>)：</p>
<ul>
<li>
<p><strong>Altruism</strong> - Because MELs only require a single honest validator, as long as there is at least one altruistic full node operating, the system remains secure. However, while this may be secure enough in practice, it is not a sufficient guarantee for a system controlling a large amount of assets.<br>
<strong>利他主义</strong> - 因为 MEL 只需要一个诚实的验证者，只要至少有一个利他的全节点在运行，系统就会保持安全。然而，虽然这在实践中可能足够安全，但对于控制大量资产的系统来说，这并不是充分的保证。</p>
</li>
<li>
<p><strong>Economic interest</strong> - There are many entities which have financial incentives to run full nodes that go beyond the potential whistleblower reward. For example, products and services like block explorers, liquidity providers, or dapps need to access the full state of the MEL to effectively run their business. However, these entities are (in theory) susceptible to being bribed by a malicious block producer.<br>
<strong>经济利益</strong> - 许多实体拥有运行完整节点的经济激励，这些激励超出了潜在的举报人奖励。例如，区块浏览器、流动性提供者或 dapp 等产品和服务需要访问 MEL 的完整状态才能有效地开展业务。然而，这些实体(理论上)容易受到恶意区块生产者的贿赂。</p>
</li>
<li>
<p><strong>Whales</strong> - Entities with a large number of assets on an MEL may choose to run a full node in order to ensure their interests are protected and that the chain is secure.<br>
<strong>巨鲸</strong> - 在 MEL 上拥有大量资产的实体可以选择运行一个完整节点，以确保他们的利益受到保护并且链是安全的。</p>
</li>
<li>
<p><strong>Fast withdrawals</strong> - Because optimistic MELs rely on a dispute resolution window before guaranteeing finality on the lower layers of the modular stack, withdrawals from the MEL to the settlement layer are not finalized until this window has elapsed. As such, there is a market for third-party services which offer fast withdrawals, accepting tokens on the MEL and instantly sending the same tokens (minus a fee) to the user on the settlement layer. In order to ensure the MEL state isn’t reverted after they have sent funds on the settlement layer, the service provider is incentivized to verify the validity of the chain before entering into such a transaction.<br>
<strong>快速取款</strong> - 因为乐观 MEL 在保证模块化技术栈较低层的最终确定性之前，依赖争议解决窗口，所以在此窗口过去之前，从 MEL 到结算层的取款不会最终确定。因此，存在提供快速提款、在 MEL 上接受代币并在结算层立即向用户发送相同代币(减去费用)的第三方服务市场。为了确保 MEL 状态在他们在结算层发送资金后不会恢复，激励服务提供商在进行此类交易之前验证链的有效性。</p>
</li>
<li>
<p><strong>Block producers</strong> - It is possible to introduce a penalty for block producers who submit blocks which build on top of previous invalid blocks. With such a mechanism in place, block producers would be incentivized to verify the validity of the chain before submitting a block.<br>
<strong>区块生产者</strong> - 可以对提交构建在先前无效块之上的新块的生产者引入惩罚。有了这样的机制，区块生产者将被激励在提交区块之前验证链的有效性。</p>
</li>
</ul>
<p>While the above mitigation strategies may not be completely effective on their own, when combined there is a clear incentive for a number of different parties to continue running full nodes on the MEL and validating the state of the chain.</p>
<p>虽然上述缓解策略本身可能并不完全有效，但当结合使用时，有明显的动机让许多不同的各方继续在 MEL 上运行完整节点并验证链的状态。</p>
<hr>
<h2 id="新的设计空间超越-evm-a-new-design-space-going-beyond-the-evm">新的设计空间：超越 EVM (A New Design Space: Going Beyond the EVM)</h2>
<p>By adopting a design that enables high security under a single honest minority assumption, the modular blockchain stack enables the development of much higher-throughput blockchains than have previously been possible under monolithic designs.</p>
<p>通过采用在单一诚实少数假设下实现高安全性的设计，模块化区块链技术栈能够开发比以前在单片设计下可实现的更高吞吐量的区块链。</p>
<p>However, alongside the scalability benefits that come from separating computation from verification, further strides can be made in scalability by focusing specifically on the design of the top of the stack: the modular execution layer. <strong>Making computation more scalable and efficient on this layer is the next step in building better blockchains.</strong></p>
<p>然而，除了计算与验证分离带来的可扩展性优势之外，还可以通过专门关注技术栈顶部的设计：模块化执行层，在可扩展性方面取得进一步进展。 <strong>在这一层上使计算更具可扩展性和效率是构建更好的区块链的下一步。</strong></p>
<p>Most modular execution layers currently under development use Ethereum as their parent chain, so default to using the EVM as an execution environment. This is the design equivalent of improving the energy efficiency of an internal combustion engine: an incremental improvement on an already outdated technology.</p>
<p>目前正在开发的大多数模块化执行层都使用以太坊作为其父链，因此默认使用 EVM 作为执行环境。这相当于提高内燃机的能源效率的设计：对已经过时的技术进行增量改进。</p>
<p>In reality, the modular stack opens up a much wider design space, removing the need for modular execution layers to rely on the inefficient EVM. <strong>Fuel is taking advantage of this newly expanded design space to build a modular execution layer which <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">goes beyond the EVM</a></strong>, optimizing for efficient &amp; scalable computation, superior developer experience, and maximum security.</p>
<p>实际上，模块化技术栈开辟了更广阔的设计空间，不再需要模块化执行层来依赖低效的 EVM。 <strong>Fuel 正在利用这个新扩展的设计空间来构建一个<a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">超越 EVM</a> 的模块化执行层</strong> ，优化高效和可扩展的计算、卓越的开发人员体验和最大的安全性。</p>
<p>In Part 2, we will explore the ways in which modular execution layers can transcend the technological limitations of the previous generation of blockchain design to achieve true scalability.</p>
<p>在第 2 部分中，我们将探讨模块化执行层如何超越上一代区块链设计的技术限制以实现真正的可扩展性。</p>
<hr>
<h2 id="敬请关注-follow-us"><strong>敬请关注 (Follow Us)</strong></h2>
<ul>
<li><a href="https://twitter.com/fuellabs_"><strong><strong>Twitter</strong></strong></a></li>
<li><a href="http://discord.com/invite/xfpK4Pe"><strong><strong>Discord</strong></strong></a></li>
<li><a href="https://www.linkedin.com/company/fuel-labs/"><strong><strong>LinkedIn</strong></strong></a></li>
<li><a href="https://www.youtube.com/channel/UCam2Sj3SvFSAIfDbP-4jWZQ"><strong><strong>YouTube</strong></strong></a></li>
</ul>
<h2 id="关于我们-about-us"><strong>关于我们 (About Us)</strong></h2>
<p><a href="https://www.fuel.network/">Fuel</a> is the <strong><strong>fastest execution layer</strong></strong> for the modular blockchain stack. Powerful and sleek, the technology enables parallel transaction execution, empowering developers with the <strong><strong>highest flexible throughput</strong></strong> and <strong><strong>maximum security</strong></strong> required to scale. Developers choose the <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> for its <strong><strong>superior developer experience</strong></strong> and the ability to go <strong><strong>beyond the limitations of the EVM</strong></strong>.</p>
<p><a href="https://www.fuel.network/">Fuel</a> 是模块化区块链技术栈的<strong>最快执行层</strong>。该技术功能强大且时尚，支持并行交易执行，为开发人员提供了扩展所需的<strong>最高灵活吞吐量</strong>和<strong>最大安全性</strong>。开发人员选择 <a href="https://fuellabs.github.io/fuel-docs/master/vs-evm.html">FuelVM</a> 是因为它<strong>卓越的开发人员体验和运行能力</strong> ，突破了 EVM 的限制****。</p>
<h2 id="成为贡献者-become-a-contributor"><strong>成为贡献者 (Become a Contributor)</strong></h2>
<ul>
<li>
<p><a href="https://jobs.lever.co/fuellabs">Explore our current job openings</a><br>
<a href="https://jobs.lever.co/fuellabs">探索我们目前的职位空缺</a></p>
</li>
<li>
<p><a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">Apply for a grant</a><br>
<a href="https://1v1l4ftv9zy.typeform.com/fuelgrants">申请资助</a></p>
</li>
<li>
<p><a href="https://fuellabs.github.io/sway/v0.24.5/">Learn Sway</a><br>
<a href="https://fuellabs.github.io/sway/v0.24.5/">学习Sway</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SeiNetwork长推-20221012 (SeiNetwork twitter threads-20221012)]]></title>
        <id>https://chainguys.github.io/post/seinetwork-chang-tui-20221012-seinetwork-twitter-threads-20221012/</id>
        <link href="https://chainguys.github.io/post/seinetwork-chang-tui-20221012-seinetwork-twitter-threads-20221012/">
        </link>
        <updated>2022-10-12T00:57:55.000Z</updated>
        <content type="html"><![CDATA[<p>原文地址:https://twitter.com/SeiNetwork/status/1575181008349302785</p>
<p>A $50,000,000 ecosystem &amp; liquidity fund awaits strong teams that build on Sei.  every week we work with<a href="https://twitter.com/Cryptocito">@Cryptocito</a> <a href="https://twitter.com/strangelovelabs">@strangelovelabs</a> <a href="https://twitter.com/Galileo_xyz">@galileo_xyz</a>to lay out the best developer opportunities in Web3. This week we're highlighting Tokenized Time.</p>
<p>一个价值 50,000,000 美元的生态系统和流动性基金正在等待建立在 Sei 之上的强大团队。每周我们都使用<a href="https://twitter.com/Cryptocito">@Cryptocito</a> <a href="https://twitter.com/strangelovelabs">@strangelovelabs</a> <a href="https://twitter.com/Galileo_xyz">@galileo_xyz</a>布局 Web3 中最好的开发人员机会。本周我们将重点介绍代币化时间。</p>
<p>Crypto has not yet disrupted one of the largest markets: Labor ![👷‍♂️]( Sei has been brainstorming ways to tokenize developer time, allowing for protocols and ecosystems to make better use of their valuable war-chests.</p>
<p>加密货币尚未扰乱最大的市场之一：人工！[👷‍♂️]（Sei 一直在集思广益，来标记开发人员的时间，允许协议和生态系统更好地利用其宝贵的资金。</p>
<p>Rather than giving out millions of incentives via liquidity mining, protocols can instead pay for developer hours to deploy towards key projects. We’re looking for the right team to explore this exciting, wide-open concept on crypto rails Ready to SEIze the opportunity?</p>
<p>与其通过流动性挖矿提供数百万的奖励，协议可以支付开发人员的时间来部署关键项目。我们正在寻找合适的团队来探索这个令人兴奋的、广泛开放的加密轨道概念 准备好抓住机会了吗？</p>
<p>Sei's Mission:<br>
Give DeFI protocols an unfair advantage.  Create a robust ecosystem tailored for trading.  Enable what cannot be done on any other Layer 1.</p>
<p>Sei的使命：<br>
给 DeFI 协议一个无与伦比优势。创建一个为交易量身定制的强大生态系统。达成在任何其他第 1 层上无法完成的事情。</p>
<p>To learn more about the $50 Million ecosystem fund check out these resources below</p>
<p>要了解有关 5000 万美元生态系统基金的更多信息，请查看以下资源</p>
<p><a href="https://twitter.com/SeiNetwork/status/1575181008349302785">点击此处</a></p>
<p>If you're interested in building anything on the chain made for DeFi fill out the ecosystem form:</p>
<p>如果您有兴趣在为 DeFi 制造的链上构建任何东西，请填写生态系统表格：</p>
<figure data-type="image" tabindex="1"><img src="https://pbs.twimg.com/card_img/1577423600331771905/qq_JGYRE?format=png&amp;name=900x900" alt="" loading="lazy"></figure>
<p><a href="https://y8e47wadwqp.typeform.com/to/Ia7t8DxY?typeform-source=t.co">https://y8e47wadwqp.typeform.com/to/Ia7t8DxY?typeform-source=t.co</a></p>
]]></content>
    </entry>
</feed>